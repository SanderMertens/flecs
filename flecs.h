#define flecs_STATIC

#ifndef FLECS_H
#define FLECS_H

/* FLECS_LEGACY should be defined when building for C89 */
// #define FLECS_LEGACY

/* FLECS_NO_CPP should be defined when building for C++ without the C++ API */
// #define FLECS_NO_CPP

/* FLECS_NO_MODULES should be defined when modules should not be included */
// #define FLECS_NO_MODULES

/* FLECS_NO_ADDONS should be defined when optional addons should not be included */
// #define FLECS_NO_ADDONS

/**
 * @file api_defines.h
 * @brief Supporting defines for the public API.
 *
 * This file contains constants / macro's that are typically not used by an
 * application but support the public API, and therefore must be exposed. This
 * header should not be included by itself.
 */

#ifndef FLECS_API_DEFINES_H
#define FLECS_API_DEFINES_H

#ifdef __cplusplus
extern "C" {
#endif

/* Standard library dependencies */
#include <time.h>
#include <stdlib.h>
#include <assert.h>
#include <stdarg.h>
#include <string.h>
#include <stdio.h>
#include <limits.h>
#include <string.h>

/* Non-standard but required. If not provided by platform, add manually. If
 * flecs is built by bake, stdint.h from bake is included. */
#ifndef __BAKE__
#include <stdint.h>
#endif

/* Contains macro's for importing / exporting symbols */
/*
                                   )
                                  (.)
                                  .|.
                                  | |
                              _.--| |--._
                           .-';  ;`-'& ; `&.
                          \   &  ;    &   &_/
                           |"""---...---"""|
                           \ | | | | | | | /
                            `---.|.|.|.---'

 * This file is generated by bake.lang.c for your convenience. Headers of
 * dependencies will automatically show up in this file. Include bake_config.h
 * in your main project file. Do not edit! */

#ifndef FLECS_BAKE_CONFIG_H
#define FLECS_BAKE_CONFIG_H

/* Headers of public dependencies */
#ifdef __BAKE__
#include <bake_util.h>
#endif

/* Convenience macro for exporting symbols */
#ifndef flecs_STATIC
#if flecs_EXPORTS && (defined(_MSC_VER) || defined(__MINGW32__))
  #define FLECS_EXPORT __declspec(dllexport)
#elif flecs_EXPORTS
  #define FLECS_EXPORT __attribute__((__visibility__("default")))
#elif defined _MSC_VER
  #define FLECS_EXPORT __declspec(dllimport)
#else
  #define FLECS_EXPORT
#endif
#else
  #define FLECS_EXPORT
#endif

#endif


#ifdef __BAKE_LEGACY__
#define FLECS_LEGACY
#endif


////////////////////////////////////////////////////////////////////////////////
//// Language support defines
////////////////////////////////////////////////////////////////////////////////

/* The API uses the native bool type in C++, or a custom one in C */
#ifndef __cplusplus
#undef bool
#undef true
#undef false
typedef char bool;
#define false 0
#define true !false
#endif

typedef uint32_t ecs_flags32_t;
typedef uint64_t ecs_flags64_t;

/* Keep unsigned integers out of the codebase as they do more harm than good */
typedef int32_t ecs_size_t;
#define ECS_SIZEOF(T) (ecs_size_t)sizeof(T)

/* Use alignof in C++, or a trick in C. */
#ifdef __cplusplus
#define ECS_ALIGNOF(T) (int64_t)alignof(T)
#elif defined(_MSC_VER)
#define ECS_ALIGNOF(T) (int64_t)__alignof(T)
#else
#define ECS_ALIGNOF(T) ((int64_t)&((struct { char c; T d; } *)0)->d)
#endif

#if defined(__GNUC__)
#define ECS_UNUSED __attribute__((unused))
#else
#define ECS_UNUSED
#endif

#define ECS_ALIGN(size, alignment) (((((size) - 1) / (alignment)) + 1) * (alignment))

/* Simple utility for determining the max of two values */
#define ECS_MAX(a, b) ((a > b) ? a : b)


////////////////////////////////////////////////////////////////////////////////
//// Reserved component ids
////////////////////////////////////////////////////////////////////////////////

/** Builtin component ids */
#define FLECS__EEcsComponent (1)
#define FLECS__EEcsComponentLifecycle (2)
#define FLECS__EEcsType (3)
#define FLECS__EEcsName (6)

/** System module component ids */
#define FLECS__EEcsTrigger (4)
#define FLECS__EEcsSystem (5)
#define FLECS__EEcsTickSource (7)
#define FLECS__EEcsSignatureExpr (8)
#define FLECS__EEcsSignature (9)
#define FLECS__EEcsQuery (10)
#define FLECS__EEcsIterAction (11)
#define FLECS__EEcsContext (12)

/** Pipeline module component ids */
#define FLECS__EEcsPipelineQuery (13)

/** Timer module component ids */
#define FLECS__EEcsTimer (14)
#define FLECS__EEcsRateFilter (15)


////////////////////////////////////////////////////////////////////////////////
//// Type role macro's
////////////////////////////////////////////////////////////////////////////////

#define ECS_TYPE_ROLE_MASK ((ecs_entity_t)(ECS_INSTANCEOF | ECS_CHILDOF | ECS_TRAIT | ECS_AND | ECS_OR | ECS_XOR | ECS_NOT))
#define ECS_ENTITY_MASK ((ecs_entity_t)~ECS_TYPE_ROLE_MASK)
#define ECS_TYPE_ROLE_START ECS_CHILDOF


////////////////////////////////////////////////////////////////////////////////
//// Convert between C typenames and variables
////////////////////////////////////////////////////////////////////////////////

/** Translate C type to type variable. */
#define ecs_type(T) FLECS__T##T

/** Translate C type to entity variable. */
#define ecs_entity(T) FLECS__E##T

/** Translate C type to module struct. */
#define ecs_module(T) FLECS__M##T

/** Translate C type to module struct. */
#define ecs_module_ptr(T) FLECS__M##T##_ptr

/** Translate C type to module struct. */
#define ecs_iter_action(T) FLECS__F##T

#ifndef FLECS_LEGACY
////////////////////////////////////////////////////////////////////////////////
//// Utilities for working with trait identifiers
////////////////////////////////////////////////////////////////////////////////

#define ecs_entity_t_lo(value) ((uint32_t)(value))
#define ecs_entity_t_hi(value) ((uint32_t)((value) >> 32))
#define ecs_entity_t_comb(v1, v2) (((uint64_t)(v2) << 32) + (uint32_t)(v1))
#define ecs_trait(comp, trait) ECS_TRAIT | ecs_entity_t_comb(comp, trait)


////////////////////////////////////////////////////////////////////////////////
//// Convenience macro's for ctor, dtor, move and copy
////////////////////////////////////////////////////////////////////////////////

/* Constructor / destructor convenience macro */
#define ECS_XTOR_IMPL(type, postfix, var, ...)\
    void type##_##postfix(\
        ecs_world_t *world,\
        ecs_entity_t component,\
        const ecs_entity_t *entity_ptr,\
        void *_ptr,\
        size_t _size,\
        int32_t _count,\
        void *ctx)\
    {\
        (void)world;\
        (void)component;\
        (void)entity_ptr;\
        (void)_ptr;\
        (void)_size;\
        (void)_count;\
        (void)ctx;\
        for (int32_t i = 0; i < _count; i ++) {\
            ecs_entity_t entity = entity_ptr[i];\
            type *var = &((type*)_ptr)[i];\
            (void)entity;\
            (void)var;\
            __VA_ARGS__\
        }\
    }

/* Copy convenience macro */
#define ECS_COPY_IMPL(type, dst_var, src_var, ...)\
    void type##_##copy(\
        ecs_world_t *world,\
        ecs_entity_t component,\
        const ecs_entity_t *dst_entities,\
        const ecs_entity_t *src_entities,\
        void *_dst_ptr,\
        const void *_src_ptr,\
        size_t _size,\
        int32_t _count,\
        void *ctx)\
    {\
        (void)world;\
        (void)component;\
        (void)dst_entities;\
        (void)src_entities;\
        (void)_dst_ptr;\
        (void)_src_ptr;\
        (void)_size;\
        (void)_count;\
        (void)ctx;\
        for (int32_t i = 0; i < _count; i ++) {\
            ecs_entity_t dst_entity = dst_entities[i];\
            ecs_entity_t src_entity = src_entities[i];\
            type *dst_var = &((type*)_dst_ptr)[i];\
            type *src_var = &((type*)_src_ptr)[i];\
            (void)dst_entity;\
            (void)src_entity;\
            (void)dst_var;\
            (void)src_var;\
            __VA_ARGS__\
        }\
    }

/* Move convenience macro */
#define ECS_MOVE_IMPL(type, dst_var, src_var, ...)\
    void type##_##move(\
        ecs_world_t *world,\
        ecs_entity_t component,\
        const ecs_entity_t *dst_entities,\
        const ecs_entity_t *src_entities,\
        void *_dst_ptr,\
        void *_src_ptr,\
        size_t _size,\
        int32_t _count,\
        void *ctx)\
    {\
        (void)world;\
        (void)component;\
        (void)dst_entities;\
        (void)src_entities;\
        (void)_dst_ptr;\
        (void)_src_ptr;\
        (void)_size;\
        (void)_count;\
        (void)ctx;\
        for (int32_t i = 0; i < _count; i ++) {\
            ecs_entity_t dst_entity = dst_entities[i];\
            ecs_entity_t src_entity = src_entities[i];\
            type *dst_var = &((type*)_dst_ptr)[i];\
            type *src_var = &((type*)_src_ptr)[i];\
            (void)dst_entity;\
            (void)src_entity;\
            (void)dst_var;\
            (void)src_var;\
            __VA_ARGS__\
        }\
    }
#endif
#ifdef __cplusplus
}
#endif

#endif
#ifndef FLECS_VECTOR_H
#define FLECS_VECTOR_H


#ifdef __cplusplus
extern "C" {
#endif

/* Public, so we can do compile-time offset calculation */
struct ecs_vector_t {
    int32_t count;
    int32_t size;
    
#ifndef NDEBUG
    int64_t elem_size;
#endif
};

#define ECS_VECTOR_U(size, alignment) size, ECS_MAX(ECS_SIZEOF(ecs_vector_t), alignment)
#define ECS_VECTOR_T(T) ECS_VECTOR_U(ECS_SIZEOF(T), ECS_ALIGNOF(T))

/* Macro's for creating vector on stack */
#ifndef NDEBUG
#define ECS_VECTOR_VALUE(T, elem_count)\
{\
    .elem_size = (int32_t)(ECS_SIZEOF(T)),\
    .count = elem_count,\
    .size = elem_count\
}
#else
#define ECS_VECTOR_VALUE(T, elem_count)\
{\
    .count = elem_count,\
    .size = elem_count\
}
#endif

#define ECS_VECTOR_DECL(name, T, elem_count)\
struct {\
    union {\
        ecs_vector_t vector;\
        uint64_t align;\
    } header;\
    T array[elem_count];\
} __##name##_value = {\
    .header.vector = ECS_VECTOR_VALUE(T, elem_count),\
};\
const ecs_vector_t *name = (ecs_vector_t*)&__##name##_value

#define ECS_VECTOR_IMPL(name, T, elems, elem_count)\
ecs_os_memcpy(__##name##_value.array, elems, sizeof(T) * elem_count)

#define ECS_VECTOR_STACK(name, T, elems, elem_count)\
ECS_VECTOR_DECL(name, T, elem_count);\
ECS_VECTOR_IMPL(name, T, elems, elem_count)

typedef struct ecs_vector_t ecs_vector_t;

typedef int (*ecs_comparator_t)(
    const void* p1,
    const void *p2);

FLECS_EXPORT
ecs_vector_t* _ecs_vector_new(
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count);

#define ecs_vector_new(T, elem_count) \
    _ecs_vector_new(ECS_VECTOR_T(T), elem_count)

#define ecs_vector_new_t(size, alignment, elem_count) \
    _ecs_vector_new(ECS_VECTOR_U(size, alignment), elem_count)    

FLECS_EXPORT
ecs_vector_t* _ecs_vector_from_array(
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count,
    void *array);

#define ecs_vector_from_array(T, elem_count, array)\
    _ecs_vector_from_array(ECS_VECTOR_T(T), elem_count, array)

FLECS_EXPORT
void ecs_vector_free(
    ecs_vector_t *vector);

FLECS_EXPORT
void ecs_vector_clear(
    ecs_vector_t *vector);

FLECS_EXPORT
void* _ecs_vector_add(
    ecs_vector_t **array_inout,
    ecs_size_t elem_size,
    int16_t offset);

#define ecs_vector_add(vector, T) \
    (T*)_ecs_vector_add(vector, ECS_VECTOR_T(T))

#define ecs_vector_add_t(vector, size, alignment) \
    _ecs_vector_add(vector, ECS_VECTOR_U(size, alignment))

FLECS_EXPORT
void* _ecs_vector_addn(
    ecs_vector_t **array_inout,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count);

#define ecs_vector_addn(vector, T, elem_count) \
    (T*)_ecs_vector_addn(vector, ECS_VECTOR_T(T), elem_count)

#define ecs_vector_addn_t(vector, size, alignment, elem_count) \
    _ecs_vector_addn(vector, ECS_VECTOR_U(size, alignment), elem_count)

FLECS_EXPORT
void* _ecs_vector_get(
    const ecs_vector_t *vector,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t index);

#define ecs_vector_get(vector, T, index) \
    (T*)_ecs_vector_get(vector, ECS_VECTOR_T(T), index)

#define ecs_vector_get_t(vector, size, alignment, index) \
    _ecs_vector_get(vector, ECS_VECTOR_U(size, alignment), index)

FLECS_EXPORT
void* _ecs_vector_last(
    const ecs_vector_t *vector,
    ecs_size_t elem_size,
    int16_t offset);

#define ecs_vector_last(vector, T) \
    _ecs_vector_last(vector, ECS_VECTOR_T(T))

FLECS_EXPORT
int32_t _ecs_vector_remove(
    ecs_vector_t *vector,
    ecs_size_t elem_size,
    int16_t offset,
    void *elem);

#define ecs_vector_remove(vector, T, index) \
    _ecs_vector_remove(vector, ECS_VECTOR_T(T), index)

FLECS_EXPORT
void ecs_vector_remove_last(
    ecs_vector_t *vector);

FLECS_EXPORT
bool _ecs_vector_pop(
    ecs_vector_t *vector,
    ecs_size_t elem_size,
    int16_t offset,
    void *value);

#define ecs_vector_pop(vector, T, value) \
    _ecs_vector_pop(vector, ECS_VECTOR_T(T), value)

FLECS_EXPORT
int32_t _ecs_vector_move_index(
    ecs_vector_t **dst,
    ecs_vector_t *src,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t index);

#define ecs_vector_move_index(dst, src, T, index) \
    _ecs_vector_move_index(dst, src, ECS_VECTOR_T(T), index)

FLECS_EXPORT
int32_t _ecs_vector_remove_index(
    ecs_vector_t *vector,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t index);

#define ecs_vector_remove_index(vector, T, index) \
    _ecs_vector_remove_index(vector, ECS_VECTOR_T(T), index)

#define ecs_vector_remove_index_t(vector, size, alignment, index) \
    _ecs_vector_remove_index(vector, ECS_VECTOR_U(size, alignment), index)

FLECS_EXPORT
void _ecs_vector_reclaim(
    ecs_vector_t **vector,
    ecs_size_t elem_size,
    int16_t offset);

#define ecs_vector_reclaim(vector, T)\
    _ecs_vector_reclaim(vector, ECS_VECTOR_T(T))

FLECS_EXPORT
int32_t _ecs_vector_grow(
    ecs_vector_t **vector,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count);

#define ecs_vector_grow(vector, T, size) \
    _ecs_vector_grow(vector, ECS_VECTOR_T(T), size)

FLECS_EXPORT
int32_t _ecs_vector_set_size(
    ecs_vector_t **vector,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count);

#define ecs_vector_set_size(vector, T, elem_count) \
    _ecs_vector_set_size(vector, ECS_VECTOR_T(T), elem_count)

#define ecs_vector_set_size_t(vector, size, alignment, elem_count) \
    _ecs_vector_set_size(vector, ECS_VECTOR_U(size, alignment), elem_count)

FLECS_EXPORT
int32_t _ecs_vector_set_count(
    ecs_vector_t **vector,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count);

#define ecs_vector_set_count(vector, T, elem_count) \
    _ecs_vector_set_count(vector, ECS_VECTOR_T(T), elem_count)

#define ecs_vector_set_count_t(vector, size, alignment, elem_count) \
    _ecs_vector_set_count(vector, ECS_VECTOR_U(size, alignment), elem_count)

FLECS_EXPORT
int32_t _ecs_vector_set_min_size(
    ecs_vector_t **array_inout,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count);

#define ecs_vector_set_min_size(vector, T, size) \
    _ecs_vector_set_min_size(vector, ECS_VECTOR_T(T), size)

FLECS_EXPORT
int32_t _ecs_vector_set_min_count(
    ecs_vector_t **vector_inout,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count);

#define ecs_vector_set_min_count(vector, T, size) \
    _ecs_vector_set_min_count(vector, ECS_VECTOR_T(T), size)

FLECS_EXPORT
int32_t ecs_vector_count(
    const ecs_vector_t *vector);

FLECS_EXPORT
int32_t ecs_vector_size(
    const ecs_vector_t *vector);

FLECS_EXPORT
void* _ecs_vector_first(
    const ecs_vector_t *vector,
    ecs_size_t elem_size,
    int16_t offset);

#define ecs_vector_first(vector, T) \
    (T*)_ecs_vector_first(vector, ECS_VECTOR_T(T))

#define ecs_vector_first_t(vector, size, alignment) \
    _ecs_vector_first(vector, ECS_VECTOR_U(size, alignment))

FLECS_EXPORT
void _ecs_vector_sort(
    ecs_vector_t *vector,
    ecs_size_t elem_size,
    int16_t offset,
    ecs_comparator_t compare_action);

#define ecs_vector_sort(vector, T, compare_action) \
    _ecs_vector_sort(vector, ECS_VECTOR_T(T), compare_action)

FLECS_EXPORT
void _ecs_vector_memory(
    const ecs_vector_t *vector,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t *allocd,
    int32_t *used);

#define ecs_vector_memory(vector, T, allocd, used) \
    _ecs_vector_memory(vector, ECS_VECTOR_T(T), allocd, used)

#define ecs_vector_memory_t(vector, size, alignment, allocd, used) \
    _ecs_vector_memory(vector, ECS_VECTOR_U(size, alignment), allocd, used)

ecs_vector_t* _ecs_vector_copy(
    const ecs_vector_t *src,
    ecs_size_t elem_size,
    int16_t offset);

#define ecs_vector_copy(src, T) \
    _ecs_vector_copy(src, ECS_VECTOR_T(T))

#define ecs_vector_copy_t(src, size, alignment) \
    _ecs_vector_copy(src, ECS_VECTOR_U(size, alignment))

#ifndef FLECS_LEGACY
#define ecs_vector_each(vector, T, var, ...)\
    {\
        int var##_i, var##_count = ecs_vector_count(vector);\
        T* var##_array = ecs_vector_first(vector, T);\
        for (var##_i = 0; var##_i < var##_count; var##_i ++) {\
            T* var = &var##_array[var##_i];\
            __VA_ARGS__\
        }\
    }
#endif
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
#ifndef FLECS_NO_CPP

#include <iostream>

namespace flecs {

template <typename T>
class vector {
public:
    vector(int32_t count = 0) : m_vector( nullptr ) { 
        if (count) {
            init(count);
        }
    }

    vector(std::initializer_list<T> elems) : m_vector( nullptr) {
        init(elems.size());
        *this = elems;
    }

    void operator=(std::initializer_list<T> elems) {
        for (auto elem : elems) {
            this->add(elem);
        }
    }

    void clear() {
        ecs_vector_clear(m_vector);
    }

    void add(T& value) {
        T* elem = ecs_vector_add(&m_vector, T);
        *elem = value;
    }

    void add(T&& value) {
        T* elem = ecs_vector_add(&m_vector, T);
        *elem = value;
    }    

    T& get(int32_t index) {
        return ecs_vector_get(m_vector, T, index);
    }

    T& first() {
        return ecs_vector_first(m_vector, T);
    }

    T& last() {
        return ecs_vector_last(m_vector, T);
    }

    int32_t count() {
        return ecs_vector_count(m_vector);
    }

    int32_t size() {
        return ecs_vector_size(m_vector);
    }

private:
    void init(int32_t count) {
        m_vector = ecs_vector_new(T, count);
    }

    ecs_vector_t *m_vector;
};

}

#endif
#endif

#endif
#ifndef FLECS_SPARSE_H
#define FLECS_SPARSE_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct ecs_sparse_t ecs_sparse_t;

FLECS_EXPORT
ecs_sparse_t* _ecs_sparse_new(
    ecs_size_t elem_size,
    int32_t element_count);

#define ecs_sparse_new(type, element_count)\
    _ecs_sparse_new(sizeof(type), element_count)

FLECS_EXPORT
void ecs_sparse_free(
    ecs_sparse_t *sparse);

FLECS_EXPORT
void ecs_sparse_clear(
    ecs_sparse_t *sparse);

FLECS_EXPORT
void* _ecs_sparse_add(
    ecs_sparse_t *sparse,
    ecs_size_t elem_size);

#define ecs_sparse_add(sparse, type)\
    ((type*)_ecs_sparse_add(sparse, sizeof(type)))

FLECS_EXPORT
void* _ecs_sparse_recycle(
    ecs_sparse_t *sparse,
    ecs_size_t elem_size,
    int32_t *sparse_index_out);

#define ecs_sparse_recycle(sparse, T, sparse_index_out) \
    _ecs_sparse_recycle(sparse, sizeof(T), sparse_index_out)

FLECS_EXPORT
void* _ecs_sparse_remove(
    ecs_sparse_t *sparse,
    ecs_size_t elem_size,
    int32_t index);

#define ecs_sparse_remove(sparse, type, index)\
    ((type*)_ecs_sparse_remove(sparse, sizeof(type), index))

FLECS_EXPORT
void* _ecs_sparse_get(
    const ecs_sparse_t *sparse,
    ecs_size_t elem_size,
    int32_t index);

#define ecs_sparse_get(sparse, type, index)\
    ((type*)_ecs_sparse_get(sparse, sizeof(type), index))

FLECS_EXPORT
int32_t ecs_sparse_count(
    const ecs_sparse_t *sparse);

FLECS_EXPORT
int32_t ecs_sparse_size(
    const ecs_sparse_t *sparse);

FLECS_EXPORT
void* _ecs_sparse_get_sparse(
    const ecs_sparse_t *sparse,
    ecs_size_t elem_size,
    int32_t index);

#define ecs_sparse_get_sparse(sparse, type, index)\
    ((type*)_ecs_sparse_get_sparse(sparse, sizeof(type), index))

FLECS_EXPORT
void* _ecs_sparse_get_or_set_sparse(
    ecs_sparse_t *sparse,
    ecs_size_t elem_size,
    int32_t index,
    bool *is_new);

#define ecs_sparse_get_or_set_sparse(sparse, type, index, is_new)\
    ((type*)_ecs_sparse_get_or_set_sparse(sparse, sizeof(type), index, is_new))

FLECS_EXPORT
const int32_t* ecs_sparse_indices(
    const ecs_sparse_t *sparse);

FLECS_EXPORT
const int32_t* ecs_sparse_unused_indices(
    const ecs_sparse_t *sparse);

FLECS_EXPORT
int32_t ecs_sparse_unused_count(
    const ecs_sparse_t *sparse);

FLECS_EXPORT
void ecs_sparse_set_size(
    ecs_sparse_t *sparse,
    int32_t elem_count);

FLECS_EXPORT
void ecs_sparse_grow(
    ecs_sparse_t *sparse,
    int32_t count);

FLECS_EXPORT
ecs_sparse_t* ecs_sparse_copy(
    const ecs_sparse_t *src);    

FLECS_EXPORT
void ecs_sparse_restore(
    ecs_sparse_t *dst,
    ecs_sparse_t *src);

FLECS_EXPORT
void ecs_sparse_memory(
    ecs_sparse_t *sparse,
    int32_t *allocd,
    int32_t *used);

#ifndef FLECS_LEGACY
#define ecs_sparse_each(sparse, T, var, ...)\
    {\
        int var##_i, var##_count = ecs_sparse_count(sparse);\
        for (var##_i = 0; var##_i < var##_count; var##_i ++) {\
            T* var = ecs_sparse_get(sparse, T, var##_i);\
            __VA_ARGS__\
        }\
    }
#endif

#ifdef __cplusplus
}
#endif

#endif
#ifndef FLECS_MAP_H
#define FLECS_MAP_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct ecs_map_t ecs_map_t;
typedef struct ecs_bucket_t ecs_bucket_t;
typedef uint64_t ecs_map_key_t;

typedef struct ecs_map_iter_t {
    const ecs_map_t *map;
    ecs_bucket_t *bucket;
    int32_t bucket_index;
    int32_t element_index;
    void *payload;
} ecs_map_iter_t;

FLECS_EXPORT
ecs_map_t * _ecs_map_new(
    ecs_size_t elem_size,
    ecs_size_t alignment, 
    int32_t elem_count);

#define ecs_map_new(T, elem_count)\
    _ecs_map_new(sizeof(T), ECS_ALIGNOF(T), elem_count)

FLECS_EXPORT
void * _ecs_map_get(
    const ecs_map_t *map,
    ecs_size_t elem_size,
    ecs_map_key_t key);

#define ecs_map_get(map, T, key)\
    (T*)_ecs_map_get(map, sizeof(T), (ecs_map_key_t)key)

FLECS_EXPORT
bool _ecs_map_has(
    const ecs_map_t *map,
    ecs_size_t elem_size,
    ecs_map_key_t key,
    void *payload);

#define ecs_map_has(map, key, payload)\
    _ecs_map_has(map, sizeof(*payload), (ecs_map_key_t)key, payload)

FLECS_EXPORT
void * _ecs_map_get_ptr(
    const ecs_map_t *map,
    ecs_map_key_t key);

#define ecs_map_get_ptr(map, T, key)\
    (T)_ecs_map_get_ptr(map, key)

FLECS_EXPORT
void _ecs_map_set(
    ecs_map_t *map,
    ecs_size_t elem_size,
    ecs_map_key_t key,
    const void *payload);

#define ecs_map_set(map, key, payload)\
    _ecs_map_set(map, sizeof(*payload), (ecs_map_key_t)key, payload);

FLECS_EXPORT
void ecs_map_free(
    ecs_map_t *map);

FLECS_EXPORT
void ecs_map_remove(
    ecs_map_t *map,
    ecs_map_key_t key);

FLECS_EXPORT
void ecs_map_clear(
    ecs_map_t *map);

FLECS_EXPORT
int32_t ecs_map_count(
    const ecs_map_t *map);

FLECS_EXPORT
int32_t ecs_map_bucket_count(
    const ecs_map_t *map);

FLECS_EXPORT
ecs_map_iter_t ecs_map_iter(
    const ecs_map_t *map);

FLECS_EXPORT
void* _ecs_map_next(
    ecs_map_iter_t* iter,
    ecs_size_t elem_size,
    ecs_map_key_t *key);

#define ecs_map_next(iter, T, key) \
    (T*)_ecs_map_next(iter, sizeof(T), key)

FLECS_EXPORT
void* _ecs_map_next_ptr(
    ecs_map_iter_t* iter,
    ecs_map_key_t *key);

#define ecs_map_next_ptr(iter, T, key) \
    (T)_ecs_map_next_ptr(iter, key)

FLECS_EXPORT
void ecs_map_grow(
    ecs_map_t *map, 
    int32_t elem_count);

FLECS_EXPORT
void ecs_map_set_size(
    ecs_map_t *map, 
    int32_t elem_count);

FLECS_EXPORT
void ecs_map_memory(
    ecs_map_t *map, 
    int32_t *allocd,
    int32_t *used);

FLECS_EXPORT
ecs_map_t* ecs_map_copy(
    const ecs_map_t *map);

#ifndef FLECS_LEGACY
#define ecs_map_each(map, T, key, var, ...)\
    {\
        ecs_map_iter_t it = ecs_map_iter(map);\
        ecs_map_key_t key;\
        T* var;\
        (void)key;\
        (void)var;\
        while ((var = ecs_map_next(&it, T, &key))) {\
            __VA_ARGS__\
        }\
    }
#endif
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
#ifndef FLECS_NO_CPP

#include <iostream>

namespace flecs {

template <typename K, typename T>
class map {
public:
    map(int32_t count = 0) { 
        init(count);
    }

    map(std::initializer_list<std::pair<K, T>> elems) {
        init(elems.size());
        *this = elems;
    }

    void operator=(std::initializer_list<std::pair<K, T>> elems) {
        for (auto elem : elems) {
            this->set(elem.first, elem.second);
        }
    }

    void clear() {
        ecs_map_clear(m_map);
    }

    int32_t count() {
        return ecs_map_count(m_map);
    }

    void set(K& key, T& value) {
        ecs_map_set(m_map, reinterpret_cast<ecs_map_key_t>(key), &value);
    }

    T& get(K& key) {
        *(T*)ecs_map_get(m_map, T, reinterpret_cast<ecs_map_key_t>(key));
    }

private:
    void init(int32_t count) {
        m_map = ecs_map_new(T, count);
    }

    ecs_map_t *m_map;
};

}

#endif
#endif

#endif
#ifndef FLECS_STRBUF_H_
#define FLECS_STRBUF_H_


#ifdef __cplusplus
extern "C" {
#endif

#define ECS_STRBUF_INIT (ecs_strbuf_t){0}
#define ECS_STRBUF_ELEMENT_SIZE (511)
#define ECS_STRBUF_MAX_LIST_DEPTH (32)

/* A buffer builds up a list of elements which individually can be up to N bytes
 * large. While appending, data is added to these elements. More elements are
 * added on the fly when needed. When an application calls ecs_strbuf_get, all
 * elements are combined in one string and the element administration is freed.
 *
 * This approach prevents reallocs of large blocks of memory, and therefore
 * copying large blocks of memory when appending to a large buffer. A buffer
 * preallocates some memory for the element overhead so that for small strings
 * there is hardly any overhead, while for large strings the overhead is offset
 * by the reduced time spent on copying memory.
 */

typedef struct ecs_strbuf_element {
    bool buffer_embedded;
    int32_t pos;
    char *buf;
    struct ecs_strbuf_element *next;
} ecs_strbuf_element;

typedef struct ecs_strbuf_element_embedded {
    ecs_strbuf_element super;
    char buf[ECS_STRBUF_ELEMENT_SIZE + 1];
} ecs_strbuf_element_embedded;

typedef struct ecs_strbuf_element_str {
    ecs_strbuf_element super;
    char *alloc_str;
} ecs_strbuf_element_str;

typedef struct ecs_strbuf_list_elem {
    int32_t count;
    const char *separator;
} ecs_strbuf_list_elem;

typedef struct ecs_strbuf_t {
    /* When set by an application, append will write to this buffer */
    char *buf;

    /* The maximum number of characters that may be printed */
    int32_t max;

    /* Size of elements minus current element */
    int32_t size;

    /* The number of elements in use */
    int32_t elementCount;

    /* Always allocate at least one element */
    ecs_strbuf_element_embedded firstElement;

    /* The current element being appended to */
    ecs_strbuf_element *current;

    /* Stack that keeps track of number of list elements, used for conditionally
     * inserting a separator */
    ecs_strbuf_list_elem list_stack[ECS_STRBUF_MAX_LIST_DEPTH];
    int32_t list_sp;
} ecs_strbuf_t;

/* Append format string to a buffer.
 * Returns false when max is reached, true when there is still space */
FLECS_EXPORT
bool ecs_strbuf_append(
    ecs_strbuf_t *buffer,
    const char *fmt,
    ...);

/* Append format string with argument list to a buffer.
 * Returns false when max is reached, true when there is still space */
FLECS_EXPORT
bool ecs_strbuf_vappend(
    ecs_strbuf_t *buffer,
    const char *fmt,
    va_list args);

/* Append string to buffer.
 * Returns false when max is reached, true when there is still space */
FLECS_EXPORT
bool ecs_strbuf_appendstr(
    ecs_strbuf_t *buffer,
    const char *str);

/* Append source buffer to destination buffer.
 * Returns false when max is reached, true when there is still space */
FLECS_EXPORT
bool ecs_strbuf_mergebuff(
    ecs_strbuf_t *dst_buffer,
    ecs_strbuf_t *src_buffer);

/* Append string to buffer, transfer ownership to buffer.
 * Returns false when max is reached, true when there is still space */
FLECS_EXPORT
bool ecs_strbuf_appendstr_zerocpy(
    ecs_strbuf_t *buffer,
    char *str);

/* Append string to buffer, do not free/modify string.
 * Returns false when max is reached, true when there is still space */
FLECS_EXPORT
bool ecs_strbuf_appendstr_zerocpy_const(
    ecs_strbuf_t *buffer,
    const char *str);

/* Append n characters to buffer.
 * Returns false when max is reached, true when there is still space */
FLECS_EXPORT
bool ecs_strbuf_appendstrn(
    ecs_strbuf_t *buffer,
    const char *str,
    int32_t n);

/* Return result string (also resets buffer) */
FLECS_EXPORT
char *ecs_strbuf_get(
    ecs_strbuf_t *buffer);

/* Reset buffer without returning a string */
FLECS_EXPORT
void ecs_strbuf_reset(
    ecs_strbuf_t *buffer);

/* Push a list */
FLECS_EXPORT
void ecs_strbuf_list_push(
    ecs_strbuf_t *buffer,
    const char *list_open,
    const char *separator);

/* Pop a new list */
FLECS_EXPORT
void ecs_strbuf_list_pop(
    ecs_strbuf_t *buffer,
    const char *list_close);

/* Insert a new element in list */
FLECS_EXPORT
void ecs_strbuf_list_next(
    ecs_strbuf_t *buffer);

/* Append formatted string as a new element in list */
FLECS_EXPORT
bool ecs_strbuf_list_append(
    ecs_strbuf_t *buffer,
    const char *fmt,
    ...);

/* Append string as a new element in list */
FLECS_EXPORT
bool ecs_strbuf_list_appendstr(
    ecs_strbuf_t *buffer,
    const char *str);

#ifdef __cplusplus
}
#endif

#endif

#ifndef FLECS_OS_API_H
#define FLECS_OS_API_H

#include <stdarg.h>

#if defined(_MSC_VER) || defined(__MINGW32__)
#include <malloc.h>
#else
#include <alloca.h>
#endif

#if defined(_WIN32)
#define ECS_OS_WINDOWS
#elif defined(__linux__)
#define ECS_OS_LINUX
#elif defined(__APPLE__) && defined(__MACH__)
#define ECS_OS_DARWIN
#else
/* Unknown OS */
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct ecs_time_t {
    uint32_t sec;
    uint32_t nanosec;
} ecs_time_t;

/* Allocation counters (not thread safe) */
extern int64_t ecs_os_api_malloc_count;
extern int64_t ecs_os_api_realloc_count;
extern int64_t ecs_os_api_calloc_count;
extern int64_t ecs_os_api_free_count;

/* Use handle types that _at least_ can store pointers */
typedef uintptr_t ecs_os_thread_t;
typedef uintptr_t ecs_os_cond_t;
typedef uintptr_t ecs_os_mutex_t;
typedef uintptr_t ecs_os_dl_t;

/* Generic function pointer type */
typedef void (*ecs_os_proc_t)(void);

/* Memory management */
typedef 
void* (*ecs_os_api_malloc_t)(
    ecs_size_t size);

typedef 
void (*ecs_os_api_free_t)(
    void *ptr);

typedef
void* (*ecs_os_api_realloc_t)(
    void *ptr, 
    ecs_size_t size);

typedef
void* (*ecs_os_api_calloc_t)(
    ecs_size_t size);

typedef
char* (*ecs_os_api_strdup_t)(
    const char *str);

/* Threads */
typedef
void* (*ecs_os_thread_callback_t)(
    void*);

typedef
ecs_os_thread_t (*ecs_os_api_thread_new_t)(
    ecs_os_thread_callback_t callback,
    void *param);

typedef
void* (*ecs_os_api_thread_join_t)(
    ecs_os_thread_t thread);


/* Atomic increment / decrement */
typedef
int (*ecs_os_api_ainc_t)(
    int32_t *value);


/* Mutex */
typedef
ecs_os_mutex_t (*ecs_os_api_mutex_new_t)(
    void);

typedef
void (*ecs_os_api_mutex_lock_t)(
    ecs_os_mutex_t mutex);

typedef
void (*ecs_os_api_mutex_unlock_t)(
    ecs_os_mutex_t mutex);

typedef
void (*ecs_os_api_mutex_free_t)(
    ecs_os_mutex_t mutex);

/* Condition variable */
typedef
ecs_os_cond_t (*ecs_os_api_cond_new_t)(
    void);

typedef
void (*ecs_os_api_cond_free_t)(
    ecs_os_cond_t cond);

typedef
void (*ecs_os_api_cond_signal_t)(
    ecs_os_cond_t cond);

typedef
void (*ecs_os_api_cond_broadcast_t)(
    ecs_os_cond_t cond);

typedef
void (*ecs_os_api_cond_wait_t)(
    ecs_os_cond_t cond,
    ecs_os_mutex_t mutex);

typedef 
void (*ecs_os_api_sleep_t)(
    int32_t sec,
    int32_t nanosec);

typedef
void (*ecs_os_api_get_time_t)(
    ecs_time_t *time_out);

/* Logging */
typedef
void (*ecs_os_api_log_t)(
    const char *fmt,
    va_list args);

/* Application termination */
typedef
void (*ecs_os_api_abort_t)(
    void);

/* Dynamic libraries */
typedef
ecs_os_dl_t (*ecs_os_api_dlopen_t)(
    const char *libname);

typedef
ecs_os_proc_t (*ecs_os_api_dlproc_t)(
    ecs_os_dl_t lib,
    const char *procname);

typedef
void (*ecs_os_api_dlclose_t)(
    ecs_os_dl_t lib);

typedef
char* (*ecs_os_api_module_to_path_t)(
    const char *module_id);

typedef struct ecs_os_api_t {
    /* Memory management */
    ecs_os_api_malloc_t malloc;
    ecs_os_api_realloc_t realloc;
    ecs_os_api_calloc_t calloc;
    ecs_os_api_free_t free;

    /* Strings */
    ecs_os_api_strdup_t strdup;

    /* Threads */
    ecs_os_api_thread_new_t thread_new;
    ecs_os_api_thread_join_t thread_join;

    /* Atomic incremenet / decrement */
    ecs_os_api_ainc_t ainc;
    ecs_os_api_ainc_t adec;

    /* Mutex */
    ecs_os_api_mutex_new_t mutex_new;
    ecs_os_api_mutex_free_t mutex_free;
    ecs_os_api_mutex_lock_t mutex_lock;
    ecs_os_api_mutex_lock_t mutex_unlock;

    /* Condition variable */
    ecs_os_api_cond_new_t cond_new;
    ecs_os_api_cond_free_t cond_free;
    ecs_os_api_cond_signal_t cond_signal;
    ecs_os_api_cond_broadcast_t cond_broadcast;
    ecs_os_api_cond_wait_t cond_wait;

    /* Time */
    ecs_os_api_sleep_t sleep;
    ecs_os_api_get_time_t get_time;

    /* Logging */
    ecs_os_api_log_t log;
    ecs_os_api_log_t log_error;
    ecs_os_api_log_t log_debug;
    ecs_os_api_log_t log_warning;

    /* Application termination */
    ecs_os_api_abort_t abort;

    /* Dynamic library loading */
    ecs_os_api_dlopen_t dlopen;
    ecs_os_api_dlproc_t dlproc;
    ecs_os_api_dlclose_t dlclose;

    /* Overridable function that translates from a logical module id to a
     * shared library filename */
    ecs_os_api_module_to_path_t module_to_dl;

    /* Overridable function that translates from a logical module id to a
     * path that contains module-specif resources or assets */
    ecs_os_api_module_to_path_t module_to_etc;    
} ecs_os_api_t;

FLECS_EXPORT
extern ecs_os_api_t ecs_os_api;

FLECS_EXPORT
void ecs_os_set_api(
    ecs_os_api_t *os_api);

FLECS_EXPORT
void ecs_os_set_api_defaults(void);

/* Memory management */
#define ecs_os_malloc(size) ecs_os_api.malloc(size);
#define ecs_os_free(ptr) ecs_os_api.free(ptr);
#define ecs_os_realloc(ptr, size) ecs_os_api.realloc(ptr, size)
#define ecs_os_calloc(size) ecs_os_api.calloc(size)
#if defined(_MSC_VER) || defined(__MINGW32__)
#define ecs_os_alloca(size) _alloca((size_t)(size))
#else
#define ecs_os_alloca(size) alloca((size_t)(size))
#endif

/* Strings */
#define ecs_os_strdup(str) ecs_os_api.strdup(str)
#define ecs_os_strlen(str) (ecs_size_t)strlen(str)
#define ecs_os_strcmp(str1, str2) strcmp(str1, str2)
#define ecs_os_strncmp(str1, str2, num) strncmp(str1, str2, (size_t)(num))
#define ecs_os_strcpy(str1, str2) strcpy(str1, str2)
#define ecs_os_strncpy(str1, str2, num) strncpy(str1, str2, (size_t)(num))
#define ecs_os_memcmp(ptr1, ptr2, num) memcmp(ptr1, ptr2, (size_t)(num))
#define ecs_os_memcpy(ptr1, ptr2, num) memcpy(ptr1, ptr2, (size_t)(num))
#define ecs_os_memset(ptr, value, num) memset(ptr, value, (size_t)(num))


/* Threads */
#define ecs_os_thread_new(callback, param) ecs_os_api.thread_new(callback, param)
#define ecs_os_thread_join(thread) ecs_os_api.thread_join(thread)

/* Atomic increment / decrement */
#define ecs_os_ainc(value) ecs_os_api.ainc(value)
#define ecs_os_adec(value) ecs_os_api.adec(value)

/* Mutex */
#define ecs_os_mutex_new() ecs_os_api.mutex_new()
#define ecs_os_mutex_free(mutex) ecs_os_api.mutex_free(mutex)
#define ecs_os_mutex_lock(mutex) ecs_os_api.mutex_lock(mutex)
#define ecs_os_mutex_unlock(mutex) ecs_os_api.mutex_unlock(mutex)

/* Condition variable */
#define ecs_os_cond_new() ecs_os_api.cond_new()
#define ecs_os_cond_free(cond) ecs_os_api.cond_free(cond)
#define ecs_os_cond_signal(cond) ecs_os_api.cond_signal(cond)
#define ecs_os_cond_broadcast(cond) ecs_os_api.cond_broadcast(cond)
#define ecs_os_cond_wait(cond, mutex) ecs_os_api.cond_wait(cond, mutex)

/* Time */
#define ecs_os_sleep(sec, nanosec) ecs_os_api.sleep(sec, nanosec)
#define ecs_os_get_time(time_out) ecs_os_api.get_time(time_out)

/* Logging (use functions to avoid using variadic macro arguments) */
FLECS_EXPORT
void ecs_os_log(const char *fmt, ...);

FLECS_EXPORT
void ecs_os_warn(const char *fmt, ...);

FLECS_EXPORT
void ecs_os_err(const char *fmt, ...);

FLECS_EXPORT
void ecs_os_dbg(const char *fmt, ...);

/* Application termination */
#define ecs_os_abort() ecs_os_api.abort()

/* Dynamic libraries */
#define ecs_os_dlopen(libname) ecs_os_api.dlopen(libname)
#define ecs_os_dlproc(lib, procname) ecs_os_api.dlproc(lib, procname)
#define ecs_os_dlclose(lib) ecs_os_api.dlclose(lib)

/* Module id translation */
#define ecs_os_module_to_dl(lib) ecs_os_api.module_to_dl(lib)
#define ecs_os_module_to_etc(lib) ecs_os_api.module_to_etc(lib)

/* Sleep with floating point time */
FLECS_EXPORT
void ecs_sleepf(
    double t);

/* Measure time since provided timestamp */
FLECS_EXPORT
double ecs_time_measure(
    ecs_time_t *start);

/* Calculate difference between two timestamps */
FLECS_EXPORT
ecs_time_t ecs_time_sub(
    ecs_time_t t1,
    ecs_time_t t2);

/* Convert time value to a double */
FLECS_EXPORT
double ecs_time_to_double(
    ecs_time_t t);

FLECS_EXPORT
void* ecs_os_memdup(
    const void *src, 
    ecs_size_t size);
    

#ifdef __cplusplus
}
#endif

#endif

#ifdef __cplusplus
extern "C" {
#endif


////////////////////////////////////////////////////////////////////////////////
//// Basic API types
////////////////////////////////////////////////////////////////////////////////

/** An entity identifier. */
typedef uint64_t ecs_entity_t;

/** A vector containing component identifiers used to describe a type. */
typedef const ecs_vector_t* ecs_type_t;

/** An ECS world is the container for all ECS data and supporting features. */
typedef struct ecs_world_t ecs_world_t;

/** A snapshot stores the state of a world in a particular point in time. */
typedef struct ecs_snapshot_t ecs_snapshot_t;

/** Queries are the primary mechanism for iterating (prematched) entities. */
typedef struct ecs_query_t ecs_query_t;

/* An iterator lets an application iterate entities across tables. */
typedef struct ecs_iter_t ecs_iter_t;

/** Refs cache data that lets them access components faster than ecs_get. */
typedef struct ecs_ref_t ecs_ref_t;

/** Describes how a filter should match components with a table. */
typedef enum ecs_match_kind_t {
    EcsMatchDefault = 0,
    EcsMatchAll,            /**< Match all components in a type */
    EcsMatchAny,            /**< Match one of the components in a type */
    EcsMatchExact           /**< Match the type exactly */
} ecs_match_kind_t;

/** Filters alllow for ad-hoc quick filtering of entity tables. */
typedef struct ecs_filter_t {
    ecs_type_t include;             /**< Components that should match */
    ecs_type_t exclude;             /**< Components that should not match */
    ecs_match_kind_t include_kind;  /**< Match kind for include components */
    ecs_match_kind_t exclude_kind;  /**< Match kind for exclude components */
} ecs_filter_t;

/** Type that contains various statistics of a world. */
typedef struct ecs_world_info_t {
    ecs_entity_t last_component_id;   /**< Last issued component entity id */
    ecs_entity_t last_id;             /**< Last issued entity id */
    ecs_entity_t min_id;              /**< First allowed entity id */
    ecs_entity_t max_id;              /**< Last allowed entity id */

    float delta_time_raw;       /**< Raw delta time (no time scaling) */
    float delta_time;           /**< Time passed to or computed by ecs_progress */
    float time_scale;           /**< Time scale applied to delta_time */
    float target_fps;           /**< Target fps */
    float frame_time_total;    /**< Total time spent processing a frame */
    float system_time_total;   /**< Total time spent in systems */
    float merge_time_total;    /**< Total time spent in merges */
    float world_time_total;    /**< Time elapsed in simulation */
    float world_time_total_raw; /**< Time elapsed in simulation (no scaling) */
    float sleep_err;           /**< Measured sleep error */
    
    int32_t frame_count_total;  /**< Total number of frames */
    int32_t merge_count_total;  /**< Total number of merges */
    int32_t pipeline_build_count_total; /**< Total number of pipeline builds */
    int32_t systems_ran_frame;  /**< Total number of systems ran in last frame */
} ecs_world_info_t;


////////////////////////////////////////////////////////////////////////////////
//// Function types
////////////////////////////////////////////////////////////////////////////////

/** Action callback for systems and triggers */
typedef void (*ecs_iter_action_t)(
    ecs_iter_t *it);

typedef bool (*ecs_iter_next_action_t)(
    ecs_iter_t *it);

/** Compare callback used for sorting */
typedef int (*ecs_compare_action_t)(
    ecs_entity_t e1,
    void *ptr1,
    ecs_entity_t e2,
    void *ptr2);    

/** Compare callback used for sorting */
typedef int32_t (*ecs_rank_type_action_t)(
    ecs_world_t *world,
    ecs_entity_t rank_component,
    ecs_type_t type);

/** Initialization action for modules */
typedef void (*ecs_module_action_t)(
    ecs_world_t *world);    

/** Action callback on world exit */
typedef void (*ecs_fini_action_t)(
    ecs_world_t *world,
    void *ctx);

/**
 * @file api_defines.h
 * @brief Supporting types for the public API.
 *
 * This file containstypes that are typically not used by an application but 
 * support the public API, and therefore must be exposed. This header should not
 * be included by itself.
 */

#ifndef FLECS_API_TYPES_H
#define FLECS_API_TYPES_H


#ifdef __cplusplus
extern "C" {
#endif


////////////////////////////////////////////////////////////////////////////////
//// Opaque types
////////////////////////////////////////////////////////////////////////////////

/** A stage enables modification while iterating and from multiple threads */
typedef struct ecs_stage_t ecs_stage_t;

/** A table is where entities and components are stored */
typedef struct ecs_table_t ecs_table_t;

/** A record stores data to map an entity id to a location in a table */
typedef struct ecs_record_t ecs_record_t;

/** Table column */
typedef struct ecs_column_t ecs_column_t;

/** Table data */
typedef struct ecs_data_t ecs_data_t;


////////////////////////////////////////////////////////////////////////////////
//// Non-opaque types
////////////////////////////////////////////////////////////////////////////////

/** Cached reference. */
struct ecs_ref_t {
    ecs_entity_t entity;    /**< Entity of the reference */
    ecs_entity_t component; /**< Component of the reference */
    void *table;            /**< Last known table */
    int32_t row;            /**< Last known location in table */
    int32_t alloc_count;    /**< Last known alloc count of table */
    ecs_stage_t *stage;     /**< Last known stage */
    ecs_record_t *record;   /**< Pointer to record, if in main stage */
    const void *ptr;        /**< Cached ptr */
};

/** Array of entity ids that, other than a type, can live on the stack */
typedef struct ecs_entities_t {
    ecs_entity_t *array;    /**< An array with entity ids */
    int32_t count;          /**< The number of entities in the array */
} ecs_entities_t;

/** Scope-iterator specific data */
typedef struct ecs_scope_iter_t {
    ecs_filter_t filter;
    ecs_vector_t *tables;
    int32_t index;
} ecs_scope_iter_t;

/** Filter-iterator specific data */
typedef struct ecs_filter_iter_t {
    ecs_filter_t filter;
    ecs_sparse_t *tables;
    int32_t index;
} ecs_filter_iter_t;

/** Query-iterator specific data */
typedef struct ecs_query_iter_t {
    ecs_query_t *query;
    int32_t offset;
    int32_t limit;
    int32_t remaining;
    int32_t index;
} ecs_query_iter_t;  

/** Query-iterator specific data */
typedef struct ecs_snapshot_iter_t {
    ecs_filter_t filter;
    ecs_vector_t *tables; /* ecs_table_leaf_t */
    int32_t index;
} ecs_snapshot_iter_t;  

/** The ecs_iter_t struct allows applications to iterate tables.
 * Queries and filters, among others, allow an application to iterate entities
 * that match a certain set of components. Because of how data is stored 
 * internally, entiites with a given set of components may be stored in multiple
 * consecutive arrays, stored across multiple tables. The ecs_iter_t type 
 * enables iteration across tables. */
struct ecs_iter_t {
    ecs_world_t *world;          /**< The world */
    ecs_entity_t system;         /**< The current system (if applicable) */

    int32_t *columns;        /**< Mapping from query columns to table columns */
    int32_t table_count;         /**< Active table count for query */
    int32_t inactive_table_count; /**< Inactive table count for query */
    int32_t column_count;        /**< Number of columns for system */
    ecs_table_t *table;          /**< The current table. */
    void *table_columns;         /**< Table component data */
    ecs_query_t *query;          /**< Current query being evaluated */
    ecs_ref_t *references;       /**< References to entities (from query) */
    ecs_entity_t *components;    /**< Components in current table */
    ecs_entity_t *entities;      /**< Entity identifiers */

    void *param;                 /**< User data passed system (EcsContext) */
    float delta_time;            /**< Time elapsed since last frame */
    float delta_system_time;     /**< Time elapsed since last system invocation */
    float world_time;            /**< Time elapsed since start of simulation */
    int32_t frame_offset;       /**< Offset relative to frame */
    int32_t table_offset;       /**< Current active table being processed */
    int32_t offset;             /**< Offset relative to current table */
    int32_t count;              /**< Number of entities to process by system */
    int32_t total_count;        /**< Total number of entities in table */

    ecs_entities_t *triggered_by; /**< Component(s) that triggered the system */
    ecs_entity_t interrupted_by; /**< When set, system execution is interrupted */

    union {
        ecs_scope_iter_t parent;
        ecs_filter_iter_t filter;
        ecs_query_iter_t query;
        ecs_snapshot_iter_t snapshot;
    } iter;                       /**< Iterator specific data */
};

typedef enum EcsMatchFailureReason {
    EcsMatchOk,
    EcsMatchNotASystem,
    EcsMatchSystemIsATask,
    EcsMatchEntityIsDisabled,
    EcsMatchEntityIsPrefab,
    EcsMatchFromSelf,
    EcsMatchFromOwned,
    EcsMatchFromShared,
    EcsMatchFromContainer,
    EcsMatchFromEntity,
    EcsMatchOrFromSelf,
    EcsMatchOrFromOwned,
    EcsMatchOrFromShared,
    EcsMatchOrFromContainer,
    EcsMatchNotFromSelf,
    EcsMatchNotFromOwned,
    EcsMatchNotFromShared,
    EcsMatchNotFromContainer,
} EcsMatchFailureReason;

typedef struct ecs_match_failure_t {
    EcsMatchFailureReason reason;
    int32_t column;
} ecs_match_failure_t;

////////////////////////////////////////////////////////////////////////////////
//// Function types
////////////////////////////////////////////////////////////////////////////////

/** Constructor/destructor. Used for initializing / deinitializing components. */
typedef void (*ecs_xtor_t)(
    ecs_world_t *world,
    ecs_entity_t component,
    const ecs_entity_t *entity_ptr,
    void *ptr,
    size_t size,
    int32_t count,
    void *ctx);

/** Copy is invoked when a component is copied into another component. */
typedef void (*ecs_copy_t)(
    ecs_world_t *world,
    ecs_entity_t component,    
    const ecs_entity_t *dst_entity,
    const ecs_entity_t *src_entity,
    void *dst_ptr,
    const void *src_ptr,
    size_t size,
    int32_t count,
    void *ctx);

/** Move is invoked when a component is moved to another component. */
typedef void (*ecs_move_t)(
    ecs_world_t *world,
    ecs_entity_t component,
    const ecs_entity_t *dst_entity,
    const ecs_entity_t *src_entity,
    void *dst_ptr,
    void *src_ptr,
    size_t size,
    int32_t count,
    void *ctx);


#ifdef __cplusplus
}
#endif

#endif
#ifndef FLECS_API_SUPPORT_H
#define FLECS_API_SUPPORT_H


/** Supporting types and functions that need to be exposed either in support of 
 * the public API or for unit tests, but that may change between minor / patch 
 * releases. */

#ifdef __cplusplus
extern "C" {
#endif

/** This reserves entity ids for components. Regular entity ids will start after
 * this constant. This affects performance of table traversal, as edges with ids 
 * lower than this constant are looked up in an array, whereas constants higher
 * than this id are looked up in a map. Increasing this value can improve
 * performance at the cost of (significantly) higher memory usage. */
#define ECS_HI_COMPONENT_ID (256) /* Maximum number of components */


////////////////////////////////////////////////////////////////////////////////
//// Global type handles
////////////////////////////////////////////////////////////////////////////////

/** Type handles to builtin components */
FLECS_EXPORT
extern ecs_type_t 
    ecs_type(EcsComponent),
    ecs_type(EcsComponentLifecycle),
    ecs_type(EcsType),
    ecs_type(EcsName);

/** This allows passing 0 as type to functions that accept types */
#define FLECS__TNULL 0
#define FLECS__T0 0


////////////////////////////////////////////////////////////////////////////////
//// Functions used in declarative (macro) API
////////////////////////////////////////////////////////////////////////////////

FLECS_EXPORT
ecs_entity_t ecs_new_entity(
    ecs_world_t *world,
    ecs_entity_t e,
    const char *id,
    const char *components);

FLECS_EXPORT
ecs_entity_t ecs_new_component(
    ecs_world_t *world,
    ecs_entity_t e,
    const char *id,
    size_t size,
    size_t alignment);

FLECS_EXPORT
ecs_entity_t ecs_new_module(
    ecs_world_t *world,
    ecs_entity_t e,
    const char *name,
    size_t size,
    size_t alignment);

FLECS_EXPORT
ecs_entity_t ecs_new_type(
    ecs_world_t *world,
    ecs_entity_t e,
    const char *id,
    const char *components);

FLECS_EXPORT
ecs_entity_t ecs_new_prefab(
    ecs_world_t *world,
    ecs_entity_t e,
    const char *id,
    const char *sig);

FLECS_EXPORT
ecs_entity_t ecs_new_system(
    ecs_world_t *world,
    ecs_entity_t e,
    const char *name,
    ecs_entity_t phase,
    const char *signature,
    ecs_iter_action_t action);

FLECS_EXPORT
ecs_entity_t ecs_new_trigger(
    ecs_world_t *world,
    ecs_entity_t e,
    const char *name,
    ecs_entity_t kind,
    const char *component,
    ecs_iter_action_t action);

FLECS_EXPORT
ecs_entity_t ecs_new_pipeline(
    ecs_world_t *world,
    ecs_entity_t e,
    const char *name,
    const char *expr);

FLECS_EXPORT
char* ecs_module_path_from_c(
    const char *c_name);


////////////////////////////////////////////////////////////////////////////////
//// Signature API
////////////////////////////////////////////////////////////////////////////////

typedef enum ecs_sig_inout_kind_t {
    EcsInOut,
    EcsIn,
    EcsOut
} ecs_sig_inout_kind_t;

/** Type that is used by systems to indicate where to fetch a component from */
typedef enum ecs_sig_from_kind_t {
    EcsFromAny,            /* Get component from self (default) */
    EcsFromOwned,           /* Get owned component from self */
    EcsFromShared,          /* Get shared component from self */
    EcsFromParent,          /* Get component from container */
    EcsFromSystem,          /* Get component from system */
    EcsFromEmpty,           /* Get entity handle by id */
    EcsFromEntity,          /* Get component from other entity */
    EcsCascade              /* Walk component in cascading (hierarchy) order */
} ecs_sig_from_kind_t;

/** Type describing an operator used in an signature of a system signature */
typedef enum ecs_sig_oper_kind_t {
    EcsOperAnd = 0,
    EcsOperOr = 1,
    EcsOperNot = 2,
    EcsOperOptional = 3,
    EcsOperLast = 4
} ecs_sig_oper_kind_t;

/** Type that describes a single column in the system signature */
typedef struct ecs_sig_column_t {
    ecs_sig_from_kind_t from_kind;        /* Element kind (Entity, Component) */
    ecs_sig_oper_kind_t oper_kind;   /* Operator kind (AND, OR, NOT) */
    ecs_sig_inout_kind_t inout_kind; /* Is component read or written */
    union {
        ecs_vector_t *type;          /* Used for OR operator */
        ecs_entity_t component;      /* Used for AND operator */
    } is;
    ecs_entity_t source;             /* Source entity (used with FromEntity) */
} ecs_sig_column_t;

/** Type that stores a parsed signature */
typedef struct ecs_sig_t {
    const char *name;           /* Optional name used for debugging */
    char *expr;                 /* Original expression string */
    ecs_vector_t *columns;      /* Columns that contain parsed data */
} ecs_sig_t;

/** Add column to signature. */
FLECS_EXPORT
int ecs_sig_add(
    ecs_sig_t *sig,
    ecs_sig_from_kind_t from_kind,
    ecs_sig_oper_kind_t oper_kind,
    ecs_sig_inout_kind_t access_kind,
    ecs_entity_t component,
    ecs_entity_t source);

/** Create query based on signature object. */
FLECS_EXPORT
ecs_query_t* ecs_query_new_w_sig(
    ecs_world_t *world,
    ecs_entity_t system,
    ecs_sig_t *sig);


#define ECS_INVALID_HANDLE (1)
#define ECS_INVALID_PARAMETER (2)
#define ECS_INVALID_COMPONENT_ID (3)
#define ECS_INVALID_EXPRESSION (4)
#define ECS_INVALID_TYPE_EXPRESSION (5)
#define ECS_INVALID_SIGNATURE (6)
#define ECS_UNKNOWN_COMPONENT_ID (7)
#define ECS_UNKNOWN_TYPE_ID (8)
#define ECS_TYPE_NOT_AN_ENTITY (9)
#define ECS_MISSING_SYSTEM_CONTEXT (10)
#define ECS_NOT_A_COMPONENT (11)
#define ECS_INTERNAL_ERROR (12)
#define ECS_MORE_THAN_ONE_PREFAB (13)
#define ECS_ALREADY_DEFINED (14)
#define ECS_INVALID_COMPONENT_SIZE (15)
#define ECS_INVALID_COMPONENT_ALIGNMENT (16)
#define ECS_OUT_OF_MEMORY (17)
#define ECS_MODULE_UNDEFINED (18)
#define ECS_COLUMN_INDEX_OUT_OF_RANGE (19)
#define ECS_COLUMN_IS_NOT_SHARED (20)
#define ECS_COLUMN_IS_SHARED (21)
#define ECS_COLUMN_HAS_NO_DATA (22)
#define ECS_COLUMN_TYPE_MISMATCH (23)
#define ECS_INVALID_WHILE_MERGING (24)
#define ECS_INVALID_WHILE_ITERATING (25)
#define ECS_INVALID_FROM_WORKER (26)
#define ECS_UNRESOLVED_IDENTIFIER (27)
#define ECS_OUT_OF_RANGE (28)
#define ECS_COLUMN_IS_NOT_SET (29)
#define ECS_UNRESOLVED_REFERENCE (30)
#define ECS_THREAD_ERROR (31)
#define ECS_MISSING_OS_API (32)
#define ECS_TYPE_TOO_LARGE (33)
#define ECS_INVALID_PREFAB_CHILD_TYPE (34)
#define ECS_UNSUPPORTED (35)
#define ECS_NO_OUT_COLUMNS (36)
#define ECS_COLUMN_ACCESS_VIOLATION (37)
#define ECS_DESERIALIZE_COMPONENT_ID_CONFLICT (38)
#define ECS_DESERIALIZE_COMPONENT_SIZE_CONFLICT (39)
#define ECS_DESERIALIZE_FORMAT_ERROR (40)
#define ECS_INVALID_REACTIVE_SIGNATURE (41)
#define ECS_INCONSISTENT_COMPONENT_NAME (42)
#define ECS_TYPE_CONSTRAINT_VIOLATION (43)

/** Declare type variable */
#define ECS_TYPE_VAR(type)\
    ecs_type_t ecs_type(type)

/** Declare entity variable */
#define ECS_ENTITY_VAR(type)\
    ecs_entity_t ecs_entity(type)

/** Utility macro for setting a component in a module function */
#define ECS_SET_COMPONENT(type)\
    if (handles) handles->ecs_entity(type) = ecs_entity(type);\
    if (handles) handles->ecs_type(type) = ecs_type(type)

/** Utility macro for setting a system in a module function */
#define ECS_SET_ENTITY(entity)\
    if (handles) handles->entity = entity;

/** Calculate offset from address */
#define ECS_OFFSET(o, offset) (void*)(((uintptr_t)(o)) + ((uintptr_t)(offset)))

#ifdef __cplusplus
}
#endif

#endif
#ifndef FLECS_LOG_H
#define FLECS_LOG_H


#ifdef __cplusplus
extern "C" {
#endif


////////////////////////////////////////////////////////////////////////////////
//// Color macro's
////////////////////////////////////////////////////////////////////////////////

#define ECS_BLACK   "\033[1;30m"
#define ECS_RED     "\033[0;31m"
#define ECS_GREEN   "\033[0;32m"
#define ECS_YELLOW  "\033[0;33m"
#define ECS_BLUE    "\033[0;34m"
#define ECS_MAGENTA "\033[0;35m"
#define ECS_CYAN    "\033[0;36m"
#define ECS_WHITE   "\033[1;37m"
#define ECS_GREY    "\033[0;37m"
#define ECS_NORMAL  "\033[0;49m"
#define ECS_BOLD    "\033[1;49m"


////////////////////////////////////////////////////////////////////////////////
//// Tracing
////////////////////////////////////////////////////////////////////////////////

FLECS_EXPORT
void _ecs_trace(
    int level,
    const char *file,
    int32_t line,
    const char *fmt,
    ...);

FLECS_EXPORT
void _ecs_warn(
    const char *file,
    int32_t line,
    const char *fmt,
    ...);

FLECS_EXPORT
void _ecs_err(
    const char *file,
    int32_t line,
    const char *fmt,
    ...);
FLECS_EXPORT
void ecs_log_push(void);

FLECS_EXPORT
void ecs_log_pop(void);

#ifndef FLECS_LEGACY

#define ecs_trace(lvl, ...)\
    _ecs_trace(lvl, __FILE__, __LINE__, __VA_ARGS__)

#define ecs_warn(...)\
    _ecs_warn(__FILE__, __LINE__, __VA_ARGS__)

#define ecs_err(...)\
    _ecs_err(__FILE__, __LINE__, __VA_ARGS__)


/* If in debug mode and no tracing verbosity is defined, compile all tracing */
#if !defined(NDEBUG) && !(defined(ECS_TRACE_0) || defined(ECS_TRACE_1) || defined(ECS_TRACE_2) || defined(ECS_TRACE_3))
#define ECS_TRACE_3
#endif

#ifndef NDEBUG
#if defined(ECS_TRACE_3)
#define ecs_trace_1(...) ecs_trace(1, __VA_ARGS__);
#define ecs_trace_2(...) ecs_trace(2, __VA_ARGS__);
#define ecs_trace_3(...) ecs_trace(3, __VA_ARGS__);

#elif defined(ECS_TRACE_2)
#define ecs_trace_1(...) ecs_trace(1, __VA_ARGS__);
#define ecs_trace_2(...) ecs_trace(2, __VA_ARGS__);
#define ecs_trace_3(...)

#elif defined(ECS_TRACE_1)
#define ecs_trace_1(...) ecs_trace(1, __VA_ARGS__);
#define ecs_trace_2(...)
#define ecs_trace_3(...)
#endif
#else
#define ecs_trace_1(...)
#define ecs_trace_2(...)
#define ecs_trace_3(...)
#endif
#endif

////////////////////////////////////////////////////////////////////////////////
//// Exceptions
////////////////////////////////////////////////////////////////////////////////

/** Get description for error code */
FLECS_EXPORT
const char* ecs_strerror(
    int32_t error_code);

/** Abort */
FLECS_EXPORT
void _ecs_abort(
    int32_t error_code,
    const char *param,
    const char *file,
    int32_t line);

#define ecs_abort(error_code, param)\
    _ecs_abort(error_code, param, __FILE__, __LINE__); abort()

/** Assert */
FLECS_EXPORT
void _ecs_assert(
    bool condition,
    int32_t error_code,
    const char *param,
    const char *condition_str,
    const char *file,
    int32_t line);

#ifdef NDEBUG
#define ecs_assert(condition, error_code, param)
#else
#define ecs_assert(condition, error_code, param)\
    _ecs_assert(condition, error_code, param, #condition, __FILE__, __LINE__);\
    assert(condition)
#endif

FLECS_EXPORT
void _ecs_parser_error(
    const char *name,
    const char *expr, 
    int64_t column,
    const char *fmt,
    ...);

#ifndef FLECS_LEGACY

#define ecs_parser_error(name, expr, column, ...)\
    _ecs_parser_error(name, expr, column, __VA_ARGS__);\
    abort()

#endif

#ifdef __cplusplus
}
#endif

#endif
/**
 * @file type.h
 * @brief Type API.
 */

#ifndef FLECS_TYPE_H
#define FLECS_TYPE_H

#ifdef __cplusplus
extern "C" {
#endif

FLECS_EXPORT
ecs_type_t ecs_type_from_entity(
    ecs_world_t *world,
    ecs_entity_t entity);

FLECS_EXPORT
ecs_entity_t ecs_type_to_entity(
    ecs_world_t *world,
    ecs_type_t type);

FLECS_EXPORT
char* ecs_type_str(
    ecs_world_t *world,
    ecs_type_t type);

FLECS_EXPORT
ecs_type_t ecs_type_from_str(
    ecs_world_t *world,
    const char *expr);    

FLECS_EXPORT
ecs_type_t ecs_type_find(
    ecs_world_t *world,
    ecs_entity_t *array,
    int32_t count);

FLECS_EXPORT
ecs_type_t ecs_type_merge(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_type_t type_add,
    ecs_type_t type_remove);

FLECS_EXPORT
ecs_type_t ecs_type_add(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_entity_t entity);

FLECS_EXPORT
ecs_type_t ecs_type_remove(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_entity_t entity);

FLECS_EXPORT
bool ecs_type_has_entity(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_entity_t entity);

FLECS_EXPORT
bool ecs_type_has_type(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_type_t has);

FLECS_EXPORT
bool ecs_type_owns_entity(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_entity_t entity,
    bool owned);

FLECS_EXPORT
bool ecs_type_owns_type(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_type_t has,
    bool owned);

FLECS_EXPORT
ecs_entity_t ecs_type_get_entity_for_xor(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_entity_t xor_tag);

FLECS_EXPORT
int32_t ecs_type_index_of(
    ecs_type_t type,
    ecs_entity_t component);

FLECS_EXPORT
int32_t ecs_type_trait_index_of(
    ecs_type_t type, 
    int32_t start_index, 
    ecs_entity_t trait);

#ifdef __cplusplus
}
#endif

#endif


////////////////////////////////////////////////////////////////////////////////
//// Builtin components
////////////////////////////////////////////////////////////////////////////////

/** Entity name. */
typedef struct EcsName {
    const char *value;     /**< Entity name */
    const char *symbol;    /**< Optional symbol name, if it differs from name */
    char *alloc_value;     /**< If set, value will be freed on destruction */
} EcsName;

/** Component information. */
typedef struct EcsComponent {
    ecs_size_t size;           /**< Component size */
    ecs_size_t alignment;      /**< Component alignment */
} EcsComponent;

/** Component that stores an ecs_type_t. 
 * This component allows for the creation of entities that represent a type, and
 * therefore the creation of named types. This component is typically 
 * instantiated by ECS_TYPE. */
typedef struct EcsType {
    ecs_type_t type;        /**< Preserved nested types */
    ecs_type_t normalized;  /**< Union of type and nested AND types */
} EcsType;

/** Component that contains lifecycle callbacks for a component. */
typedef struct EcsComponentLifecycle {
    ecs_xtor_t ctor;        /**< Component constructor */
    ecs_xtor_t dtor;        /**< Component destructor */
    ecs_copy_t copy;        /**< Component copy */
    ecs_move_t move;        /**< Component move */
    void *ctx;              /**< User defined context */
} EcsComponentLifecycle;

/* Component used for registering component triggers */
typedef struct EcsTrigger {
    ecs_entity_t kind;
    ecs_iter_action_t action;
    ecs_entity_t component;
    ecs_entity_t self;
    void *ctx;
} EcsTrigger;


////////////////////////////////////////////////////////////////////////////////
//// Type roles
////////////////////////////////////////////////////////////////////////////////

/* Type roles are used to indicate the role of an entity in a type. If no flag
 * is specified, the entity is interpreted as a regular component or tag. Flags
 * are added to an entity by using a bitwise OR (|). An example:
 *
 * ecs_entity_t parent = ecs_new(world, 0);
 * ecs_entity_t child = ecs_add_entity(world, e, ECS_CHILDOF | parent);
 *
 * Type flags can also be used in type expressions, without the ECS prefix:
 *
 * ECS_ENTITY(world, Base, Position);
 * ECS_TYPE(world, InstanceOfBase, INSTANCEOF | Base);
 */

/** The INSTANCEOF role indicates that the components from the entity should be
 * shared with the entity that instantiates the type. */
#define ECS_INSTANCEOF ((ecs_entity_t)1 << 63)

/** The CHILDOF role indicates that the entity should be treated as a parent of
 * the entity that instantiates the type. */
#define ECS_CHILDOF ((ecs_entity_t)1 << 62)

/** The TRAIT role indicates that the entity is a trait identifier. */
#define ECS_TRAIT ((ecs_entity_t)1 << 61)

/** Enforce that all entities of a type are present in the type.
 * This flag can only be used in combination with an entity that has EcsType. */
#define ECS_AND ((ecs_entity_t)1 << 60)

/** Enforce that at least one entity of a type must be present in the type.
 * This flag can only be used in combination with an entity that has EcsType. */
#define ECS_OR ((ecs_entity_t)1 << 59)

/** Enforce that exactly one entity of a type must be present in the type.
 * This flag can only be used in combination with an entity that has EcsType. 
 * When another entity of the XOR'd type is added to an entity of this type, the
 * previous entity is removed from the entity. This makes XOR useful for
 * implementing state machines, as it allows for traversing states while 
 * ensuring that only one state is ever active at the same time. */
#define ECS_XOR ((ecs_entity_t)1 << 58)

/** None of the entities in a type may be added to the type.
 * This flag can only be used in combination with an entity that has EcsType. */
#define ECS_NOT ((ecs_entity_t)1 << 57)


////////////////////////////////////////////////////////////////////////////////
//// Builtin tags
////////////////////////////////////////////////////////////////////////////////

/* Builtin tag ids */
#define EcsModule (ECS_HI_COMPONENT_ID + 0)
#define EcsPrefab (ECS_HI_COMPONENT_ID + 1)
#define EcsHidden (ECS_HI_COMPONENT_ID + 2)
#define EcsDisabled (ECS_HI_COMPONENT_ID + 3)
#define EcsDisabledIntern (ECS_HI_COMPONENT_ID + 4)
#define EcsInactive (ECS_HI_COMPONENT_ID + 5)
#define EcsOnDemand (ECS_HI_COMPONENT_ID + 6)
#define EcsMonitor (ECS_HI_COMPONENT_ID + 7)
#define EcsPipeline (ECS_HI_COMPONENT_ID + 8)

/* Trigger tags */
#define EcsOnAdd (ECS_HI_COMPONENT_ID + 9)
#define EcsOnRemove (ECS_HI_COMPONENT_ID + 10)

/* Set system tags */
#define EcsOnSet (ECS_HI_COMPONENT_ID + 11)
#define EcsUnSet (ECS_HI_COMPONENT_ID + 12)

/* Builtin pipeline tags */
#define EcsPreFrame (ECS_HI_COMPONENT_ID + 13)
#define EcsOnLoad (ECS_HI_COMPONENT_ID + 14)
#define EcsPostLoad (ECS_HI_COMPONENT_ID + 15)
#define EcsPreUpdate (ECS_HI_COMPONENT_ID + 16)
#define EcsOnUpdate (ECS_HI_COMPONENT_ID + 17)
#define EcsOnValidate (ECS_HI_COMPONENT_ID + 18)
#define EcsPostUpdate (ECS_HI_COMPONENT_ID + 19)
#define EcsPreStore (ECS_HI_COMPONENT_ID + 20)
#define EcsOnStore (ECS_HI_COMPONENT_ID + 21)
#define EcsPostFrame (ECS_HI_COMPONENT_ID + 22)

/** Builtin entity ids */
#define EcsFlecs (ECS_HI_COMPONENT_ID + 23)
#define EcsFlecsCore (ECS_HI_COMPONENT_ID + 24)
#define EcsWorld (ECS_HI_COMPONENT_ID + 25)
#define EcsSingleton ((ecs_entity_t)(ECS_ENTITY_MASK) - 1)

/* Value used to quickly check if component is builtin. This is used to quickly
 * filter out tables with builtin components (for example for ecs_delete) */
#define EcsLastInternalComponentId (ecs_entity(EcsSystem))

/* The first user-defined component starts from this id. Ids up to this number
 * are reserved for builtin components */
#define EcsFirstUserComponentId (32)

/* The first user-defined entity starts from this id. Ids up to this number
 * are reserved for builtin components */
#define EcsFirstUserEntityId (ECS_HI_COMPONENT_ID + 32)


////////////////////////////////////////////////////////////////////////////////
//// Convenience macro's
////////////////////////////////////////////////////////////////////////////////

/* Macro's rely on variadic arguments which are C99 and above */
#ifndef FLECS_LEGACY

/** Declare a named entity with a type expression. 
 * Example:
 *   ECS_ENTITY(world, MyEntity, Position, Velocity);
 */ 
#define ECS_ENTITY(world, id, ...)\
    ecs_entity_t id = ecs_new_entity(world, 0, #id, #__VA_ARGS__);\
    (void)id;

/** Declare a prefab with a type expression. 
 * Example:
 *   ECS_PREFAB(world, MyEntity, Position, Velocity);
 */
#define ECS_PREFAB(world, id, ...) \
    ecs_entity_t id = ecs_new_prefab(world, 0, #id, #__VA_ARGS__);\
    (void)id;

/** Declare a component.
 * Example:
 *   ECS_COMPONENT(world, Position);
 */
#define ECS_COMPONENT(world, id) \
    ECS_ENTITY_VAR(id) = ecs_new_component(world, 0, #id, sizeof(id), ECS_ALIGNOF(id));\
    ECS_VECTOR_STACK(FLECS__T##id, ecs_entity_t, &FLECS__E##id, 1);\
    (void)ecs_entity(id);\
    (void)ecs_type(id);\

/** Declare a tag.
 * Example:
 *   ECS_TAG(world, MyTag);
 */
#define ECS_TAG(world, id) \
    ECS_ENTITY(world, id, 0);\
    ECS_VECTOR_STACK(FLECS__T##id, ecs_entity_t, &id, 1);\
    (void)ecs_type(id);\

/** Declare a type.
 * Example:
 *   ECS_TYPE(world, MyType, Position, Velocity);
 */
#define ECS_TYPE(world, id, ...) \
    ecs_entity_t id = ecs_new_type(world, 0, #id, #__VA_ARGS__);\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, id);\
    (void)id;\
    (void)ecs_type(id);\

/** Declare a constructor.
 * Example:
 *   ECS_CTOR(MyType, ptr, { ptr->value = NULL; });
 */
#define ECS_CTOR(type, var, ...)\
    ECS_XTOR_IMPL(type, ctor, var, __VA_ARGS__)

/** Declare a destructor.
 * Example:
 *   ECS_DTOR(MyType, ptr, { free(ptr->value); });
 */
#define ECS_DTOR(type, var, ...)\
    ECS_XTOR_IMPL(type, dtor, var, __VA_ARGS__)

/** Declare a copy action.
 * Example:
 *   ECS_COPY(MyType, dst, src, { dst->value = strdup(src->value); });
 */
#define ECS_COPY(type, dst_var, src_var, ...)\
    ECS_COPY_IMPL(type, dst_var, src_var, __VA_ARGS__)

/** Declare a move action.
 * Example:
 *   ECS_MOVE(MyType, dst, src, { dst->value = src->value; src->value = 0; });
 */
#define ECS_MOVE(type, dst_var, src_var, ...)\
    ECS_MOVE_IMPL(type, dst_var, src_var, __VA_ARGS__)

/* Map from typename to function name of component lifecycle action */
#define ecs_ctor(type) type##_ctor
#define ecs_dtor(type) type##_dtor
#define ecs_copy(type) type##_copy
#define ecs_move(type) type##_move

#endif /* FLECS_LEGACY */


////////////////////////////////////////////////////////////////////////////////
//// World API
////////////////////////////////////////////////////////////////////////////////

/** Create a new world.
 * A world manages all the ECS data and supporting infrastructure. Applications 
 * must have at least one world. Entities, component and system handles are 
 * local to a world and should not be shared between worlds.
 *
 * @return A new world object
 */
FLECS_EXPORT
ecs_world_t* ecs_init(void);

/** Same as ecs_init, but with minimal set of modules loaded.
 *
 * @return A new world object
 */
FLECS_EXPORT
ecs_world_t* ecs_mini(void);

/** Create a new world with arguments.
 * Same as ecs_init, but allows passing in command line arguments. These can be
 * used to dynamically enable flecs features to an application, like performance
 * monitoring or the web dashboard (if it is installed) without having to modify
 * the code of an application.
 * 
 * The following options are available:
 * --threads [n]   Use n worker threads
 * --fps [hz]      Run at hz FPS
 * --admin [port]  Enable admin dashboard (requires flecs-systems-admin & flecs-systems-civetweb)
 * --console       Enables console (requires flecs-systems-console)
 * --debug         Enables debug tracing
 *
 * @return A new world object
 */
FLECS_EXPORT
ecs_world_t* ecs_init_w_args(
    int argc,
    char *argv[]);

/** Delete a world.
 * This operation deletes the world, and everything it contains.
 *
 * @param world The world to delete.
 * @return Zero if successful, non-zero if failed.
 */
FLECS_EXPORT
int ecs_fini(
    ecs_world_t *world);

/** Register action to be executed when world is destroyed.
 * Fini actions are typically used when a module needs to clean up before a
 * world shuts down.
 * 
 * @param world The world.
 * @param action The function to execute.
 * @param ctx Userdata to pass to the function */
FLECS_EXPORT
void ecs_atfini(
    ecs_world_t *world,
    ecs_fini_action_t action,
    void *ctx);

/** Register action to be executed once after frame.
 * Post frame actions are typically used for calling operations that cannot be
 * invoked during iteration, such as changing the number of threads.
 * 
 * @param world The world.
 * @param action The function to execute.
 * @param ctx Userdata to pass to the function */
FLECS_EXPORT
void ecs_run_post_frame(
    ecs_world_t *world,
    ecs_fini_action_t action,
    void *ctx);    

/** Register ctor, dtor, copy & move actions for component.
 *
 * @param world The world.
 * @param component The component id for which to register the actions
 * @param actions Type that contains the component actions.
 */
FLECS_EXPORT
void ecs_set_component_actions_w_entity(
    ecs_world_t *world,
    ecs_entity_t component,
    EcsComponentLifecycle *actions);

#ifndef FLECS_LEGACY
#define ecs_set_component_actions(world, component, ...)\
    ecs_set_component_actions_w_entity(world, ecs_entity(component), &(EcsComponentLifecycle)__VA_ARGS__)

#endif
/** Set a world context.
 * This operation allows an application to register custom data with a world
 * that can be accessed anywhere where the application has the world object.
 *
 * @param world The world.
 * @param ctx A pointer to a user defined structure.
 */
FLECS_EXPORT
void ecs_set_context(
    ecs_world_t *world,
    void *ctx);

/** Get the world context.
 * This operation retrieves a previously set world context.
 *
 * @param world The world.
 * @return The context set with ecs_set_context. If no context was set, the
 *         function returns NULL.
 */
FLECS_EXPORT
void* ecs_get_context(
    ecs_world_t *world);

/** Get world info.
 *
 * @param world The world.
 * @return Pointer to the world info. This pointer will remain valid for as long
 *         as the world is valid.
 */
FLECS_EXPORT
const ecs_world_info_t* ecs_get_world_info(
    ecs_world_t *world);

/** Dimension the world for a specified number of entities.
 * This operation will preallocate memory in the world for the specified number
 * of entities. Specifying a number lower than the current number of entities in
 * the world will have no effect. Note that this function does not allocate
 * memory for components (use ecs_dim_type for that).
 *
 * @param world The world.
 * @param entity_count The number of entities to preallocate.
 */
FLECS_EXPORT
void ecs_dim(
    ecs_world_t *world,
    int32_t entity_count);

/** Dimension a type for a specified number of entities.
 * This operation will preallocate memory for a type (table) for the
 * specified number of entites. Specifying a number lower than the current
 * number of entities in the table will have no effect.
 *
 * @param world The world.
 * @param type Handle to the type, as obtained by ecs_type_get.
 * @param entity_count The number of entities to preallocate.
 */
FLECS_EXPORT
void ecs_dim_type(
    ecs_world_t *world,
    ecs_type_t type,
    int32_t entity_count);

/** Set a range for issueing new entity ids.
 * This function constrains the entity identifiers returned by ecs_new to the 
 * specified range. This operation can be used to ensure that multiple processes
 * can run in the same simulation without requiring a central service that
 * coordinates issueing identifiers.
 * 
 * If id_end is set to 0, the range is infinite. If id_end is set to a non-zero
 * value, it has to be larger than id_start. If id_end is set and ecs_new is
 * invoked after an id is issued that is equal to id_end, the application will
 * abort.
 * 
 * @param world The world.
 * @param id_start The start of the range.
 * @param id_end The end of the range.
 */
FLECS_EXPORT
void ecs_set_entity_range(
    ecs_world_t *world,
    ecs_entity_t id_start,
    ecs_entity_t id_end);

/** Enable/disable range limits.
 * When an application is both a receiver of range-limited entities and a
 * producer of range-limited entities, range checking needs to be temporarily
 * disabled when inserting received entities. Range checking is disabled on a 
 * stage, so setting this value is thread safe.
 *
 * @param world The world.
 * @param enable True if range checking should be enabled, false to disable.
 * @return The previous value.
 */
FLECS_EXPORT
bool ecs_enable_range_check(
    ecs_world_t *world,
    bool enable);

/** Enable world locking while in progress.
 * When locking is enabled, Flecs will lock the world while in progress. This
 * allows applications to interact with the world from other threads without
 * running into race conditions.
 *
 * This is a better alternative to applications putting a lock around calls to
 * ecs_progress, since ecs_progress can sleep when FPS control is enabled,
 * which is time during which other threads could perform work.
 *
 * Locking must be enabled before applications can use the ecs_lock and
 * ecs_unlock functions. Locking is turned off by default.
 *
 * @param world The world.
 * @param enable True if locking is to be enabled.
 * @result The previous value of the setting.
 */
FLECS_EXPORT
bool ecs_enable_locking(
    ecs_world_t *world,
    bool enable);

/** Locks the world.
 * See ecs_enable_locking for details.
 *
 * @param world The world.
 */
FLECS_EXPORT
void ecs_lock(
    ecs_world_t *world);

/** Unlocks the world.
 * See ecs_enable_locking for details.
 * 
 * @param world The world.
 */
FLECS_EXPORT
void ecs_unlock(
    ecs_world_t *world);

/** Wait until world becomes available.
 * When a non-flecs thread needs to interact with the world, it should invoke
 * this function to wait until the world becomes available (as in, it is not
 * progressing the frame). Invoking this function guarantees that the thread
 * will not starve. (as opposed to simply taking the world lock).
 *
 * An application will have to invoke ecs_end_wait after this function returns.
 * 
 * @param world The world.
 */
void ecs_begin_wait(
    ecs_world_t *world);

/** Release world after calling ecs_begin_wait.
 * This operation should be invoked after invoking ecs_begin_wait, and will
 * release the world back to the thread running the main loop.
 *
 * @param world The world.
 */
void ecs_end_wait(
    ecs_world_t *world);

/** Enable or disable tracing.
 * This will enable builtin tracing. For tracing to work, it will have to be
 * compiled in which requires defining one of the following macro's:
 *
 * ECS_TRACE_0 - All tracing is disabled
 * ECS_TRACE_1 - Enable tracing level 1
 * ECS_TRACE_2 - Enable tracing level 2 and below
 * ECS_TRACE_3 - Enable tracing level 3 and below
 *
 * If no tracing level is defined and this is a debug build, ECS_TRACE_3 will
 * have been automatically defined.
 *
 * The provided level corresponds with the tracing level. If -1 is provided as
 * value, warnings are disabled. If -2 is provided, errors are disabled as well.
 *
 * @param level Desired tracing level.
 */
FLECS_EXPORT
void ecs_tracing_enable(
    int level);


////////////////////////////////////////////////////////////////////////////////
//// Entity Creation
////////////////////////////////////////////////////////////////////////////////

/** Create new entity.
 * This operation creates a new entity with a single entity in its type. The
 * entity may contain type roles. This operation recycles ids.
 *
 * @param world The world.
 * @param entity The entity to initialize the new entity with.
 * @return The new entity.
 */
FLECS_EXPORT
ecs_entity_t ecs_new_w_entity(
    ecs_world_t *world,
    ecs_entity_t entity);

/** Create new entity.
 * This operation creates a new entity initialized with a type. This operation 
 * recycles ids.
 *
 * @param world The world.
 * @param type The type to initialize the new entity with.
 * @return The new entity.
 */
FLECS_EXPORT
ecs_entity_t ecs_new_w_type(
    ecs_world_t *world,
    ecs_type_t type);

/** Create a new entity.
 * This operation creates a new entity with a single component in its type. This
 * operation accepts variables created with ECS_COMPONENT, ECS_TYPE and ECS_TAG.
 * This operation recycles ids.
 * 
 * @param world The world.
 * @param type The component type.
 * @return The new entity.
 */
#define ecs_new(world, type)\
    ecs_new_w_type(world, ecs_type(type))

/** Create N new entities.
 * This operation is the same as ecs_new_w_entity, but creates N entities
 * instead of one and does not recycle ids. Ids of created entities are
 * guaranteed to be consecutive.
 * 
 * @param world The world.
 * @param entity The entity.
 * @param count The number of entities to create.
 * @return The first entity id of the newly created entities.
 */
FLECS_EXPORT
ecs_entity_t ecs_bulk_new_w_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    int32_t count);

/** Create N new entities.
 * This operation is the same as ecs_new_w_type, but creates N entities
 * instead of one and does not recycle ids. Ids of created entities are
 * guaranteed to be consecutive.
 * 
 * @param world The world.
 * @param type The type.
 * @param count The number of entities to create.
 * @return The first entity id of the newly created entities.
 */
FLECS_EXPORT
ecs_entity_t ecs_bulk_new_w_type(
    ecs_world_t *world,
    ecs_type_t type,
    int32_t count);

/** Create N new entities and initialize components.
 * This operation is the same as ecs_bulk_new_w_type, but initializes components
 * with the provided component array. Instead of a type the operation accepts an
 * array of component identifiers (entities). The component arrays need to be
 * provided in the same order as the component identifiers.
 * 
 * @param world The world.
 * @param components Array with component identifiers.
 * @param count The number of entities to create.
 * @param data The data arrays to initialize the components with.
 * @return The first entity id of the newly created entities.
 */
FLECS_EXPORT
ecs_entity_t ecs_bulk_new_w_data(
    ecs_world_t *world,
    int32_t count,
    ecs_entities_t *component_ids,
    void *data);

/** Create N new entities.
 * This operation is the same as ecs_new, but creates N entities
 * instead of one and does not recycle ids. Ids of created entities are
 * guaranteed to be consecutive.
 * 
 * @param world The world.
 * @param component The component type.
 * @param count The number of entities to create.
 * @return The first entity id of the newly created entities.
 */
#define ecs_bulk_new(world, component, count)\
    ecs_bulk_new_w_type(world, ecs_type(component), count)


////////////////////////////////////////////////////////////////////////////////
//// Adding components
////////////////////////////////////////////////////////////////////////////////

/** Add an entity to an entity.
 * This operation adds a single entity to the type of an entity. Type roles may
 * be used in combination with the added entity. If the entity already has the
 * entity, this operation will have no side effects.
 *
 * @param world The world.
 * @param entity The entity.
 * @param entity_add The entity to add.
 */
FLECS_EXPORT
void ecs_add_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t entity_add);

/** Add a type to an entity.
 * This operation adds a type to an entity. The resulting type of the entity
 * will be the union of the previous type and the provided type. If the added
 * type did not have new components, this operation will have no side effects.
 *
 * @param world The world.
 * @param entity The entity.
 * @param type The type to add.
 */
FLECS_EXPORT
void ecs_add_type(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

/** Add a component, type or tag to an entity.
 * This operation adds a type to an entity. The resulting type of the entity
 * will be the union of the previous type and the provided type. If the added
 * type did not have new components, this operation will have no side effects.
 *
 * This operation accepts variables declared by ECS_COMPONENT, ECS_TYPE and
 * ECS_TAG.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The component, type or tag to add.
 */
#define ecs_add(world, entity, component)\
    ecs_add_type(world, entity, ecs_type(component))

/** Add an entity to entities matching a filter.
 * This operation is the same as ecs_add_entity, but is applied to all entities
 * that match the provided filter.
 *
 * @param world The world.
 * @param entity_add The entity to add.
 * @param filter The filter.
 */
FLECS_EXPORT
void ecs_bulk_add_entity(
    ecs_world_t *world,
    ecs_entity_t entity_add,
    const ecs_filter_t *filter);

/** Add a type to entities matching a filter.
 * This operation is the same as ecs_add_type but is applied to all entities
 * that match the provided filter.
 *
 * @param world The world.
 * @param type The type to add.
 * @param filter The filter.
 */
FLECS_EXPORT
void ecs_bulk_add_type(
    ecs_world_t *world,
    ecs_type_t type,
    const ecs_filter_t *filter);

/** Add a component / type / tag to entities matching a filter.
 * This operation is the same as ecs_add but is applied to all entities
 * that match the provided filter.
 *
 * @param world The world.
 * @param type The component, type or tag to add.
 * @param filter The filter.
 */
#define ecs_bulk_add(world, type, filter)\
    ecs_bulk_add_type(world, ecs_type(type), filter)

////////////////////////////////////////////////////////////////////////////////
//// Removing components
////////////////////////////////////////////////////////////////////////////////

/** Remove an entity from an entity.
 * This operation removes a single entity from the type of an entity. Type roles
 * may be used in combination with the added entity. If the entity does not have
 * the entity, this operation will have no side effects.
 *
 * @param world The world.
 * @param entity The entity.
 * @param entity_remove The entity to remove.
 */
FLECS_EXPORT
void ecs_remove_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t entity_remove);

/** Remove a type from an entity.
 * This operation removes a type to an entity. The resulting type of the entity
 * will be the difference of the previous type and the provided type. If the 
 * type did not overlap with the entity type, this operation has no side effects.
 *
 * @param world The world.
 * @param entity The entity.
 * @param type The type to remove.
 */
FLECS_EXPORT
void ecs_remove_type(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

/** Remove a component, type or tag from an entity.
 * This operation removes a type to an entity. The resulting type of the entity
 * will be the difference of the previous type and the provided type. If the 
 * type did not overlap with the entity type, this operation has no side effects.
 *
 * This operation accepts variables declared by ECS_COMPONENT, ECS_TYPE and
 * ECS_TAG.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The component, type or tag to remove.
 */
#define ecs_remove(world, entity, type)\
    ecs_remove_type(world, entity, ecs_type(type))

/** Removes an entity from entities matching a filter.
 * This operation is the same as ecs_remove_entity, but is applied to all 
 * entities that match the provided filter.
 *
 * @param world The world.
 * @param entity_remove The entity to remove.
 * @param filter The filter.
 */
FLECS_EXPORT
void ecs_bulk_remove_entity(
    ecs_world_t *world,
    ecs_entity_t entity_remove,
    const ecs_filter_t *filter);

/** Remove a type from entities matching a filter.
 * This operation is the same as ecs_remove_type but is applied to all entities
 * that match the provided filter.
 *
 * @param world The world.
 * @param type The type to remove.
 * @param filter The filter.
 */
FLECS_EXPORT
void ecs_bulk_remove_type(
    ecs_world_t *world,
    ecs_type_t type,
    const ecs_filter_t *filter);

/** Add a component / type / tag to entities matching a filter.
 * This operation is the same as ecs_remove but is applied to all entities
 * that match the provided filter.
 *
 * @param world The world.
 * @param type The component, type or tag to remove.
 * @param filter The filter.
 */
#define ecs_bulk_remove(world, type, filter)\
    ecs_bulk_remove_type(world, ecs_type(type), filter)


////////////////////////////////////////////////////////////////////////////////
//// Adding + removing components
////////////////////////////////////////////////////////////////////////////////

/** Add / remove entity from entities matching a filter.
 * Combination of ecs_add_entity and ecs_remove_entity.
 *
 * @param world The world.
 * @param entity The entity.
 * @param to_add The entity to add.
 * @param to_remove The entity to remove.
 */
FLECS_EXPORT
void ecs_add_remove_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t to_add,
    ecs_entity_t to_remove);

/** Add / remove type from entities matching a filter.
 * Combination of ecs_add_type and ecs_remove_type.
 *
 * @param world The world.
 * @param entity The entity.
 * @param to_add The type to add.
 * @param to_remove The type to remove.
 */
FLECS_EXPORT
void ecs_add_remove_type(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t to_add,
    ecs_type_t to_remove);

/** Add / remove component, type or tag from entity.
 * Combination of ecs_add and ecs_remove.
 *
 * @param world The world.
 * @param entity The entity.
 * @param to_add The component, type or tag to add.
 * @param to_remove The component, type or tag to remove.
 */
#define ecs_add_remove(world, entity, to_add, to_remove)\
    ecs_add_remove_type(world, entity, ecs_type(to_add), ecs_type(to_remove))

/** Add / remove type from entities matching a filter.
 * Combination of ecs_bulk_add_type and ecs_bulk_remove_type.
 *
 * @param world The world.
 * @param to_add The type to add.
 * @param to_remove The type to remove.
 * @param filter The filter.
 */
FLECS_EXPORT
void ecs_bulk_add_remove_type(
    ecs_world_t *world,
    ecs_type_t to_add,
    ecs_type_t to_remove,
    const ecs_filter_t *filter);

/** Add / remove component, type or tag from entities matching a filter.
 * Combination of ecs_bulk_add and ecs_bulk_remove.
 *
 * @param world The world.
 * @param to_add The component, type or tag to add.
 * @param to_remove The component, type or tag to remove.
 * @param filter The filter.
 */
#define ecs_bulk_add_remove(world, to_add, to_remove, filter)\
    ecs_bulk_add_remove_type(world, ecs_type(to_add), ecs_type(to_remove), filter)


////////////////////////////////////////////////////////////////////////////////
//// Traits
////////////////////////////////////////////////////////////////////////////////

/** Add a trait
 * This operation adds a trait from an entity.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The entity for which to remove the trait.
 * @param trait The trait to remove.
 */
#define ecs_add_trait(world, entity, component, trait)\
    ecs_add_entity(world, entity, ecs_trait(ecs_entity(component), ecs_entity(trait)))

/** Remove a trait
 * This operation removes a trait from an entity.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The entity for which to remove the trait.
 * @param trait The trait to remove.
 */
#define ecs_remove_trait(world, entity, component, trait)\
    ecs_remove_entity(world, entity, ecs_trait(ecs_entity(component), ecs_entity(trait)))

/** Test if an entity has a trait.
 * This operation returns true if the entity has the provided trait for the
 * specified component in its type.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The entity.
 * @param trait The entity.
 * @return True if the entity has the trait, false if not.
 */
#define ecs_has_trait(world, entity, component, trait)\
    ecs_has_entity(world, entity, ecs_trait(ecs_entity(component), ecs_entity(trait)))


#ifndef FLECS_LEGACY
/** Set trait for component. 
 * This operation adds a trait for an entity and component. Traits can be added
 * multiple times to the same entity, as long as it is for different components.
 *
 * Traits can be matched with systems by providing the TRAIT role to the 
 * trait component in the system signature. A system will match multiple times
 * with the same entity if the trait is added for multiple components.
 *
 * * This operation can only be used with traits that are components.
 *
 * @param world The world.
 * @param e The entity.
 * @param component The component for which to add the trait.
 * @param trait The trait to add.
 */
#define ecs_set_trait(world, entity, component, trait, ...)\
    ecs_set_ptr_w_entity(world, entity, ecs_trait(ecs_entity(component), ecs_entity(trait)), sizeof(trait), &(trait)__VA_ARGS__)


/** Set tag trait for component. 
 * This operation is similar to ecs_set_trait, but is used for trait tags. When
 * a trait tag is set on an entity, the trait type is not used (tags have no
 * type) and instead the component type is used.
 *
 * This operation can only be used with traits that are not components.
 *
 * @param world The world.
 * @param e The entity.
 * @param component The component for which to add the trait.
 * @param trait The trait to add.
 */
#define ecs_set_trait_tag(world, entity, trait, component, ...)\
    ecs_set_ptr_w_entity(world, entity, ecs_trait(ecs_entity(component), trait), sizeof(component), &(component)__VA_ARGS__)

#endif
/** Get trait for component. 
 * This operation obtains the value of a trait for a componetn that has been 
 * added by ecs_set_trait.
 *
 * @param world The world.
 * @param e The entity.
 * @param component The component to which the trait was added.
 * @param trait The trait that was added.
 */
#define ecs_get_trait(world, entity, component, trait)\
    ((trait*)ecs_get_w_entity(world, entity, ecs_trait(ecs_entity(component), ecs_entity(trait))))


////////////////////////////////////////////////////////////////////////////////
//// Deleting entities
////////////////////////////////////////////////////////////////////////////////

/** Delete an entity.
 * This operation will delete an entity and all of its components. The entity id
 * will be recycled. Repeatedly calling ecs_delete without ecs_new, 
 * ecs_new_w_entity or ecs_new_w_type will cause a memory leak as it will cause
 * the list with ids that can be recycled to grow unbounded.
 *
 * @param world The world.
 * @param entity The entity.
 */
FLECS_EXPORT
void ecs_delete(
    ecs_world_t *world,
    ecs_entity_t entity);

/** Delete entities matching a filter.
 * This operation is the same as ecs_delete, but applies to all entities that
 * match a filter.
 *
 * @param world The world.
 * @param filter The filter.
 */
FLECS_EXPORT
void ecs_bulk_delete(
    ecs_world_t *world,
    const ecs_filter_t *filter);


////////////////////////////////////////////////////////////////////////////////
//// Cloning entities
////////////////////////////////////////////////////////////////////////////////

/** Clone an entity
 * This operation clones the components of one entity into another entity. If
 * no destination entity is provided, a new entity will be created. Component
 * values are not copied unless copy_value is true.
 *
 * @param world The world.
 * @param dst The entity to copy the components to.
 * @param src The entity to copy the components from.
 * @param copy_value If true, the value of components will be copied to dst.
 * @return The destination entity.
 */
FLECS_EXPORT
ecs_entity_t ecs_clone(
    ecs_world_t *world,
    ecs_entity_t dst,
    ecs_entity_t src,
    bool copy_value);


////////////////////////////////////////////////////////////////////////////////
//// Getting components
////////////////////////////////////////////////////////////////////////////////

/** Get an immutable pointer to a component.
 * This operation obtains a const pointer to the requested component. The
 * operation accepts the component entity id.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The entity id of the component to obtain.
 * @return The component pointer, NULL if the entity does not have the component.
 */
FLECS_EXPORT
const void* ecs_get_w_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component);

/** Get an immutable pointer to a component.
 * Same as ecs_get_w_entity, but accepts the typename of a component.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The component to obtain.
 * @return The component pointer, NULL if the entity does not have the component.
 */
#define ecs_get(world, entity, component)\
    ((const component*)ecs_get_w_entity(world, entity, ecs_entity(component)))

/* -- Get cached pointer -- */

/** Get an immutable reference to a component.
 * This operation is similar to ecs_get_w_entity but it stores temporary
 * information in a `ecs_ref_t` value which allows subsequent lookups to be
 * faster.
 *
 * @param world The world.
 * @param ref Pointer to a ecs_ref_t value. Must be initialized.
 * @param entity The entity.
 * @param component The entity id of the component to obtain.
 * @return The component pointer, NULL if the entity does not have the component.
 */
FLECS_EXPORT
const void* ecs_get_ref_w_entity(
    ecs_world_t *world,
    ecs_ref_t *ref,
    ecs_entity_t entity,
    ecs_entity_t component);

/** Get an immutable reference to a component.
 * Same as ecs_get_ref_w_entity, but accepts the typename of a component.
 *
 * @param world The world.
 * @param ref Pointer to a ecs_ref_t value. Must be initialized.
 * @param entity The entity.
 * @param component The component to obtain.
 * @return The component pointer, NULL if the entity does not have the component.
 */
#define ecs_get_ref(world, ref, entity, component)\
    ((const component*)ecs_get_ref_w_entity(world, ref, entity, ecs_entity(component)))

/** Get a mutable pointer to a component.
 * This operation is similar to ecs_get_w_entity but it returns a mutable 
 * pointer. If this operation is invoked from inside a system, the entity will
 * be staged and a pointer to the staged component will be returned.
 *
 * If the entity did not yet have the component, the component will be added by
 * this operation. In this case the is_added out parameter will be set to true.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The entity id of the component to obtain.
 * @param is_added Out parameter that returns true if the component was added.
 * @return The component pointer.
 */
FLECS_EXPORT
void* ecs_get_mut_w_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component,
    bool *is_added);

/** Get a mutable pointer to a component.
 * Same as ecs_get_mut_w_entity but accepts a component typename.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The component to obtain.
 * @param is_added Out parameter that returns true if the component was added.
 * @return The component pointer.
 */
#define ecs_get_mut(world, entity, component, is_added)\
    ((component*)ecs_get_mut_w_entity(world, entity, ecs_entity(component), is_added))

/** Signal that a component has been modified.
 * This operation allows an application to signal to Flecs that a component has
 * been modified. As a result, OnSet systems will be invoked.
 *
 * This operation is commonly used together with ecs_get_mut.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The entity id of the component that was modified.
 */
FLECS_EXPORT 
void ecs_modified_w_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component);

/** Signal that a component has been modified.
 * Same as ecs_modified_w_entity but accepts a component typename.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The component that was modified.
 */
#define ecs_modified(world, entity, component)\
    ecs_modified_w_entity(world, entity, ecs_entity(component))


////////////////////////////////////////////////////////////////////////////////
//// Setting components
////////////////////////////////////////////////////////////////////////////////

/** Set the value of a component.
 * This operation allows an application to set the value of a component. The
 * operation is equivalent to calling ecs_get_mut and ecs_modified.
 *
 * If the provided entity is 0, a new entity will be created.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The entity id of the component to set.
 * @param size The size of the pointer to the value.
 * @param ptr The pointer to the value.
 * @return The entity. A new entity if no entity was provided.
 */
FLECS_EXPORT
ecs_entity_t ecs_set_ptr_w_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component,
    size_t size,
    const void *ptr);

/** Set the value of a component.
 * Same as ecs_set_ptr_w_entity, but accepts a component typename and 
 * automatically determines the type size.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The component to set.
 * @param size The size of the pointer to the value.
 * @return The entity. A new entity if no entity was provided.
 */
#define ecs_set_ptr(world, entity, component, ptr)\
    ecs_set_ptr_w_entity(world, entity, ecs_entity(component), sizeof(component), ptr)

/* Conditionally skip macro's as compound literals and variadic arguments are 
 * not supported in C89 */
#ifndef FLECS_LEGACY

/** Set the value of a component.
 * Same as ecs_set_ptr, but accepts a value instead of a pointer to a value.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The component to set.
 * @param size The size of the pointer to the value.
 * @return The entity. A new entity if no entity was provided.
 */
#define ecs_set(world, entity, component, ...)\
    ecs_set_ptr_w_entity(world, entity, ecs_entity(component), sizeof(component), &(component)__VA_ARGS__)
#endif


////////////////////////////////////////////////////////////////////////////////
//// Testing for components
////////////////////////////////////////////////////////////////////////////////

/** Test if an entity has an entity.
 * This operation returns true if the entity has the provided entity in its 
 * type.
 *
 * @param world The world.
 * @param entity The entity.
 * @param to_check The entity to test for.
 * @return True if the entity has the entity, false if not.
 */
FLECS_EXPORT
bool ecs_has_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t to_check);

/** Test if an entity has a type.
 * This operation returns true if the entity has the provided type in its 
 * type.
 *
 * @param world The world.
 * @param entity The entity.
 * @param type The type to test for.
 * @return True if the entity has the type, false if not.
 */
FLECS_EXPORT
bool ecs_has_type(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

/** Test if an entity has a component, type or tag.
 * This operation returns true if the entity has the provided component, type or
 * tag in its type.
 *
 * @param world The world.
 * @param entity The entity.
 * @param type The component, type or tag to test for.
 * @return True if the entity has the type, false if not.
 */
#define ecs_has(world, entity, type)\
    ecs_has_type(world, entity, ecs_type(type))

/** Test if an entity owns component, type or tag.
 * This operation is similar to ecs_has, but will return false if the entity
 * does not own the component, which is the case if the component is defined on
 * a base entity with an INSTANCEOF role.
 *
 * @param world The world.
 * @param entity The entity.
 * @param type The component, type or tag to test for.
 * @return True if the entity owns the component, type or tag, false if not.
 */
#define ecs_owns(world, entity, type, owned)\
    ecs_type_owns_type(world, ecs_get_type(world, entity), ecs_type(type), owned)

/** Test if an entity owns an entity.
 * This operation is similar to ecs_has, but will return false if the entity
 * does not own the entity, which is the case if the entity is defined on
 * a base entity with an INSTANCEOF role.
 *
 * @param world The world.
 * @param entity The entity.
 * @param type The entity to test for.
 * @return True if the entity owns the entity, false if not.
 */
#define ecs_owns_entity(world, entity, has, owned)\
    ecs_type_owns_entity(world, ecs_get_type(world, entity), has, owned)


////////////////////////////////////////////////////////////////////////////////
//// Entity information
////////////////////////////////////////////////////////////////////////////////

/** Get the type of an entity.
 *
 * @param world The world.
 * @param entity The entity.
 * @return The type of the entity, NULL if the entity has no components.
 */
FLECS_EXPORT
ecs_type_t ecs_get_type(
    ecs_world_t *world,
    ecs_entity_t entity);

/** Get the name of an entity.
 * This will return the name as specified in the EcsName component.
 *
 * @param world The world.
 * @param entity The entity.
 * @return The type of the entity, NULL if the entity has no name.
 */
FLECS_EXPORT
const char* ecs_get_name(
    ecs_world_t *world,
    ecs_entity_t entity);

/** Get the parent of an entity.
 * This will return a parent of the entity that has the specified component. If
 * the component is 0, the operation will return the first parent that it finds
 * in the entity type (an entity with a CHILDOF role).
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The entity id of a component that the parent must have.
 * @return The parent of the entity, 0 if no parent was found.
 */
FLECS_EXPORT
ecs_entity_t ecs_get_parent_w_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component);

/** Get the parent of an entity.
 * Same as ecs_get_parent_w_entity but accepts a component typename.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component A component that the parent must have.
 * @return The parent of the entity, 0 if no parent was found.
 */
#define ecs_get_parent(world, entity, component)\
    ecs_get_parent_w_entity(world, entity, ecs_entity(component))


////////////////////////////////////////////////////////////////////////////////
//// Enabling / disabling entities
////////////////////////////////////////////////////////////////////////////////

/** Enable or disable an entity.
 * This operation enables or disables an entity by adding or removing the
 * EcsDisabled tag. A disabled entity will not be matched with any systems,
 * unless the system explicitly specifies the EcsDisabled tag.
 *
 * @param world The world.
 * @param entity The entity to enable or disable.
 * @param enabled true to enable the entity, false to disable.
 */
FLECS_EXPORT
void ecs_enable(
    ecs_world_t *world,
    ecs_entity_t entity,
    bool enabled);


////////////////////////////////////////////////////////////////////////////////
//// Filter API
////////////////////////////////////////////////////////////////////////////////

/** Return a filter iterator.
 * A filter iterator lets an application iterate over entities that match the
 * specified filter. If NULL is provided for the filter, the iterator will
 * iterate all tables in the world.
 * 
 * @param world The world.
 * @param filter The filter.
 * @return An iterator that can be used with ecs_filter_next.
 */
FLECS_EXPORT
ecs_iter_t ecs_filter_iter(
    ecs_world_t *world,
    const ecs_filter_t *filter);  

/** Iterate tables matched by filter.
 * This operation progresses the filter iterator to the next table. The 
 * iterator must have been initialized with `ecs_filter_iter`. This operation 
 * must be invoked at least once before interpreting the contents of the 
 * iterator.
 *
 * @param it The iterator
 * @return True if more data is available, false if not.
 */
FLECS_EXPORT
bool ecs_filter_next(
    ecs_iter_t *iter);


////////////////////////////////////////////////////////////////////////////////
//// Query API
////////////////////////////////////////////////////////////////////////////////

/** Create a query.
 * This operation creates a query. Queries are used to iterate over entities
 * that match a signature expression.
 * 
 * Queries are 'persistent' meaning they are registered with
 * the world and continuously matched with new entities (tables). Queries
 * are the fastest way to iterate over entities, as a lot of processing is
 * done when entities are matched, outside of the main loop.
 *
 * Queries are the mechanism used by systems, and as such both accept the
 * same signature expressions, and have similar performance. 
 *
 * Queries, like systems, iterate over component data from the main stage.
 * This means that when an application is iterating a query outside of a system,
 * care must be taken when adding/removing components or creating/deleting
 * entities, as this may corrupt the iteration.
 *
 * When a query is iterated over inside a system normal staging applies, and an
 * application can safely update entities.
 *
 * @param world The world.
 * @param sig The query signature expression.
 * @return The new query.
 */
FLECS_EXPORT
ecs_query_t* ecs_query_new(
    ecs_world_t *world,
    const char *sig);

/** Cleanup a query.
 * This operation frees a query.
 *
 * @param query The query.
 */
FLECS_EXPORT
void ecs_query_free(
    ecs_query_t *query);

/** Return a query iterator.
 * A query iterator lets an application iterate over entities that match the
 * specified query. If a sorting function is specified, the query will check
 * whether a resort is required upon creating the iterator.
 *
 * @param query The query to iterate.
 * @return The query iterator.
 */
FLECS_EXPORT
ecs_iter_t ecs_query_iter(
    ecs_query_t *query);  

/** Iterate over a query.
 * This operation is similar to ecs_query_iter, but starts iterating from a
 * specified offset, and will not iterate more than limit entities.
 *
 * @param query The query to iterate.
 * @param offset The number of entities to skip.
 * @param limit The maximum number of entities to iterate.
 * @return The query iterator.
 */
FLECS_EXPORT
ecs_iter_t ecs_query_iter_page(
    ecs_query_t *query,
    int32_t offset,
    int32_t limit);  

/** Progress the query iterator.
 * This operation progresses the query iterator to the next table. The 
 * iterator must have been initialized with `ecs_query_iter`. This operation 
 * must be invoked at least once before interpreting the contents of the 
 * iterator.
 *
 * @param iter The iterator.
 * @returns True if more data is available, false if not.
 */
FLECS_EXPORT
bool ecs_query_next(
    ecs_iter_t *iter);      

/** Progress the query iterator for a worker thread.
 * This operation is similar to ecs_query_next, but provides the ability to 
 * divide entities up across multiple worker threads. The operation accepts a
 * current thread id and a total thread id, which is used to determine which
 * subset of entities should be assigned to the current thread.
 *
 * Current should be less than total, and there should be as many as total
 * threads. If there are less entities in a table than there are threads, only
 * as many threads as there are entities will iterate that table.
 *
 * @param it The iterator.
 * @param current Thread id of current thread.
 * @param total Total number of threads.
 * @returns True if more data is available, false if not.
 */
bool ecs_query_next_worker(
    ecs_iter_t *it,
    int32_t current,
    int32_t total);

/** Sort the output of a query.
 * This enables sorting of entities across matched tables. As a result of this
 * operation, the order of entities in the matched tables may be changed. 
 * Resorting happens when a query iterator is obtained, and only if the table
 * data has changed.
 *
 * If multiple queries that match the same (sub)set of tables specify different 
 * sorting functions, resorting is likely to happen every time an iterator is
 * obtained, which can significantly slow down iterations.
 *
 * The sorting function will be applied to the specified component. Resorting
 * only happens if that component has changed, or when the entity order in the
 * table has changed. If no component is provided, resorting only happens when
 * the entity order changes.
 *
 * @param world The world.
 * @param query The query.
 * @param component The component used to sort.
 * @param compare The compare function used to sort the components.
 */
FLECS_EXPORT
void ecs_query_order_by(
    ecs_world_t *world,
    ecs_query_t *query,
    ecs_entity_t component,
    ecs_compare_action_t compare);

/** Group and sort matched tables.
 * Similar yo ecs_query_order_by, but instead of sorting individual entities, this
 * operation only sorts matched tables. This can be useful of a query needs to
 * enforce a certain iteration order upon the tables it is iterating, for 
 * example by giving a certain component or tag a higher priority.
 *
 * The sorting function assigns a "rank" to each type, which is then used to
 * sort the tables. Tables with higher ranks will appear later in the iteration.
 * 
 * Resorting happens when a query iterator is obtained, and only if the set of
 * matched tables for a query has changed. If table sorting is enabled together
 * with entity sorting, table sorting takes precedence, and entities will be
 * sorted within each set of tables that are assigned the same rank.
 *
 * @param world The world.
 * @param query The query.
 * @param component The component used to determine the group rank.
 * @param rank_action The rank action.
 */
FLECS_EXPORT
void ecs_query_group_by(
    ecs_world_t *world,
    ecs_query_t *query,
    ecs_entity_t component,
    ecs_rank_type_action_t rank_action);

/** Returns whether the query data changed since the last iteration.
 * This operation must be invoked before obtaining the iterator, as this will
 * reset the changed state. The operation will return true after:
 * - new entities have been matched with
 * - matched entities were deleted
 * - matched components were changed
 * 
 * @param query The query.
 * @return true if entities changed, otherwise false.
 */
FLECS_EXPORT
bool ecs_query_changed(
    ecs_query_t *query);

////////////////////////////////////////////////////////////////////////////////
//// Counting entities
////////////////////////////////////////////////////////////////////////////////

/** Count entities that have an entity.
 * Returns the number of entities that have the specified entity.
 *
 * @param world The world.
 * @param entity The entity.
 * @return The number of entities that have the entity.
 */
FLECS_EXPORT
int32_t ecs_count_entity(
    ecs_world_t *world,
    ecs_entity_t entity);

/** Count entities that have a type.
 * Returns the number of entities that have the specified type.
 *
 * @param world The world.
 * @param type The type.
 * @return The number of entities that have the type.
 */
FLECS_EXPORT
int32_t ecs_count_type(
    ecs_world_t *world,
    ecs_type_t type);

/** Count entities that have a component, type or tag.
 * Returns the number of entities that have the specified component, type or tag.
 *
 * @param world The world.
 * @param type The component, type or tag.
 * @return The number of entities that have the component, type or tag.
 */
#define ecs_count(world, type)\
    ecs_count_type(world, ecs_type(type))

/** Count entities that match a filter.
 * Returns the number of entities that match the specified filter.
 *
 * @param world The world.
 * @param type The type.
 * @return The number of entities that match the specified filter.
 */
FLECS_EXPORT
int32_t ecs_count_w_filter(
    ecs_world_t *world,
    const ecs_filter_t *filter);


////////////////////////////////////////////////////////////////////////////////
//// Looking up entities
////////////////////////////////////////////////////////////////////////////////

/** Lookup an entity by name.
 * Returns an entity that matches the specified name. Only looks for entities in
 * the current scope (root if no scope is provided).
 *
 * @param world The world.
 * @param name The entity name.
 * @return The entity with the specified name, or 0 if no entity was found.
 */
FLECS_EXPORT
ecs_entity_t ecs_lookup(
    ecs_world_t *world,
    const char *name);

/** Lookup a child entity by name.
 * Returns an entity that matches the specified name. Only looks for entities in
 * the provided parent. If no parent is provided, look in the current scope (
 * root if no scope is provided).
 *
 * @param world The world.
 * @param name The entity name.
 * @return The entity with the specified name, or 0 if no entity was found.
 */
FLECS_EXPORT
ecs_entity_t ecs_lookup_child(
    ecs_world_t *world,
    ecs_entity_t parent,
    const char *name);

/** Lookup an entity from a path.
 * Lookup an entity from a provided path, relative to the provided parent. The
 * operation will use the provided separator to tokenize the path expression. If
 * the provided path contains the prefix, the search will start from the root.
 *
 * If the entity is not found in the provided parent, the operation will 
 * continue to search in the parent of the parent, until the root is reached. If
 * the entity is still not found, the lookup will search in the flecs.core
 * scope. If the entity is not found there either, the function returns 0.
 *
 * @param world The world.
 * @param parent The entity from which to resolve the path.
 * @param path The path to resolve.
 * @param sep The path separator.
 * @param prefix The path prefix.
 * @return The entity if found, else 0.
 */
FLECS_EXPORT
ecs_entity_t ecs_lookup_path_w_sep(
    ecs_world_t *world,
    ecs_entity_t parent,
    const char *path,
    const char *sep,
    const char *prefix);

/** Lookup an entity from a path.
 * Same as ecs_lookup_path_w_sep, but with defaults for the separator and
 * prefix. These defaults are used when looking up identifiers in a type or
 * signature expression.
 *
 * @param world The world.
 * @param parent The entity from which to resolve the path.
 * @param path The path to resolve.
 * @return The entity if found, else 0. 
 */
#define ecs_lookup_path(world, parent, path)\
    ecs_lookup_path_w_sep(world, parent, path, ".", NULL)

/** Lookup an entity from a full path.
 * Same as ecs_lookup_pat, but  searches from the current scope, or root scope
 * if no scope is set.
 *
 * @param world The world.
 * @param path The path to resolve.
 * @return The entity if found, else 0. 
 */
#define ecs_lookup_fullpath(world, path)\
    ecs_lookup_path_w_sep(world, 0, path, ".", NULL)

/** Lookup an entity by its symbol name.
 * This looks up an entity by the symbol name that was provided in EcsName. The
 * operation does not take into account scoping, which means it will search all
 * entities that have an EcsName.
 *
 * This operation can be useful to resolve, for example, a type by its C 
 * identifier, which does not include the Flecs namespacing.
 */
FLECS_EXPORT
ecs_entity_t ecs_lookup_symbol(
    ecs_world_t *world,
    const char *name);

////////////////////////////////////////////////////////////////////////////////
//// Path utilities
////////////////////////////////////////////////////////////////////////////////

/** Get a path identifier for an entity.
 * This operation creates a path that contains the names of the entities from
 * the specified parent to the provided entity, separated by the provided 
 * separator. If no parent is provided the path will be relative to the root. If
 * a prefix is provided, the path will be prefixed by the prefix.
 *
 * If the parent is equal to the provided child, the operation will return an
 * empty string. If a nonzero component is provided, the path will be created by 
 * looking for parents with that component.
 *
 * The returned path should be freed by the application.
 *
 * @param world The world.
 * @param parent The entity from which to create the path.
 * @param child The entity to which to create the path.
 * @param component The component of the parent.
 * @return The relative entity path.
 */
FLECS_EXPORT
char* ecs_get_path_w_sep(
    ecs_world_t *world,
    ecs_entity_t parent,
    ecs_entity_t child,
    ecs_entity_t component,
    const char *sep,
    const char *prefix);

/** Get a path identifier for an entity.
 * Same as ecs_get_path_w_sep, but with default values for the separator and
 * prefix. These defaults are used throughout Flecs whenever identifiers are
 * used in type or signature expressions.
 *
 * @param world The world.
 * @param parent The entity from which to create the path.
 * @param child The entity to which to create the path.
 * @return The relative entity path.
 */
#define ecs_get_path(world, parent, child)\
    ecs_get_path_w_sep(world, parent, child, 0, ".", NULL)

/** Get a full path for an entity.
 * Same as ecs_get_path, but with default values for the separator and
 * prefix, and the path is created from the current scope, or root if no scope
 * is provided.
 *
 * @param world The world.
 * @param child The entity to which to create the path.
 * @return The entity path.
 */
#define ecs_get_fullpath(world, child)\
    ecs_get_path_w_sep(world, 0, child, 0, ".", NULL)

/** Find or create entity from path.
 * This operation will find or create an entity from a path, and will create any
 * intermediate entities if required. If the entity already exists, no entities
 * will be created.
 *
 * If the path starts with the prefix, then the entity will be created from the
 * root scope.
 *
 * @param world The world.
 * @param parent The entity relative to which the entity should be created.
 * @param path The path to create the entity for.
 * @param sep The separator used in the path.
 * @param prefix The prefix used in the path.
 * @return The entity.
 */
FLECS_EXPORT
ecs_entity_t ecs_new_from_path_w_sep(
    ecs_world_t *world,
    ecs_entity_t parent,
    const char *path,
    const char *sep,
    const char *prefix);

/** Find or create entity from path.
 * Same as ecs_new_from_path_w_sep, but with defaults for sep and prefix.
 *
 * @param world The world.
 * @param parent The entity relative to which the entity should be created.
 * @param path The path to create the entity for.
 * @return The entity.
 */
#define ecs_new_from_path(world, parent, path)\
    ecs_new_from_path_w_sep(world, parent, path, ".", NULL)

/** Find or create entity from full path.
 * Same as ecs_new_from_path, but entity will be created from the current scope,
 * or root scope if no scope is set.
 *
 * @param world The world.
 * @param path The path to create the entity for.
 * @return The entity.
 */
#define ecs_new_from_fullpath(world, path)\
    ecs_new_from_path_w_sep(world, 0, path, ".", NULL)


////////////////////////////////////////////////////////////////////////////////
//// Scope API
////////////////////////////////////////////////////////////////////////////////

/** Does entity have children.
 *
 * @param world The world
 * @param entity The entity
 * @return True if the entity has children, false if not.
 */
FLECS_EXPORT
int32_t ecs_get_child_count(
    ecs_world_t *world,
    ecs_entity_t entity);

/** Return a scope iterator.
 * A scope iterator iterates over all the child entities of the specified 
 * parent.
 *
 * @param world The world.
 * @param parent The parent entity for which to iterate the children.
 * @return The iterator.
 */
FLECS_EXPORT
ecs_iter_t ecs_scope_iter(
    ecs_world_t *world,
    ecs_entity_t parent);

/** Return a filtered scope iterator.
 * Same as ecs_scope_iter, but results will be filtered.
 *
 * @param world The world.
 * @param parent The parent entity for which to iterate the children.
 * @return The iterator.
 */
FLECS_EXPORT
ecs_iter_t ecs_scope_iter_w_filter(
    ecs_world_t *world,
    ecs_entity_t parent,
    ecs_filter_t *filter);

/** Progress the scope iterator.
 * This operation progresses the scope iterator to the next table. The iterator
 * must have been initialized with `ecs_scope_iter`. This operation must be
 * invoked at least once before interpreting the contents of the iterator.
 *
 * @param it The iterator
 * @return True if more data is available, false if not.
 */
FLECS_EXPORT
bool ecs_scope_next(
    ecs_iter_t *it);

/** Set the current scope.
 * This operation sets the scope of the current stage to the provided entity.
 * As a result new entities will be created in this scope, and lookups will be
 * relative to the provided scope.
 *
 * It is considered good practice to restore the scope to the old value.
 *
 * @param world The world.
 * @param scope The entity to use as scope.
 * @return The previous scope.
 */
FLECS_EXPORT
ecs_entity_t ecs_set_scope(
    ecs_world_t *world,
    ecs_entity_t scope);

/** Get the current scope.
 * Get the scope set by ecs_set_scope. If no scope is set, this operation will
 * return 0.
 *
 * @param world The world.
 * @return The current scope.
 */
FLECS_EXPORT
ecs_entity_t ecs_get_scope(
    ecs_world_t *world);

/** Set a name prefix for newly created entities.
 * This is a utility that lets C modules use prefixed names for C types and
 * C functions, while using names for the entity names that do not have the 
 * prefix. The name prefix is currently only used by ECS_COMPONENT.
 *
 * @param world The world.
 * @param prefix The name prefix to use.
 * @return The previous prefix.
 */
FLECS_EXPORT
const char* ecs_set_name_prefix(
    ecs_world_t *world,
    const char *prefix);


////////////////////////////////////////////////////////////////////////////////
//// Iter API
////////////////////////////////////////////////////////////////////////////////

/** Obtain column data. 
 * This operation is to be used to obtain a component array for a specific 
 * column in the system or query signature. The column is identified by the 
 * provided index. For example, if this is the provided signature:
 * 
 * Position, Velocity
 * 
 * Position is at index 1, and Velocity is at index 2.
 *
 * This operation may return NULL if the column is optional, and the current
 * table does not have the data. Additionally, if the column points to a shared
 * component or a reference, the returned value should be interpreted as a 
 * pointer instead of an array.
 *
 * The provided size must match the size of the component, otherwise the 
 * function may fail.
 * 
 * @param it The iterator.
 * @param size The size of the component.
 * @param column The index identifying the column in a signature.
 * @return A pointer to the column data.
 */
FLECS_EXPORT
void* ecs_column_w_size(
    const ecs_iter_t *it,
    size_t size,
    int32_t column);

/** Obtain column data. 
 * This operation is similar to ecs_column_w_size, except that it accepts the
 * component typename.
 * 
 * @param it The iterator.
 * @param type The typename of the component for which to obtain the data.
 * @param column The index identifying the column in a signature.
 * @return A pointer to the column data.
 */
#define ecs_column(it, type, column)\
    ((type*)ecs_column_w_size(it, sizeof(type), column))

/** Test if column is owned or not.
 * The following signature shows an example of one owned components and two
 * components that are not owned by the current entity:
 * 
 * Position, PARENT:Velocity, MyEntity:Mass
 * 
 * Position is an owned component. Velocity and Mass both belong to a different
 * entity. This operation will return false for Position, and true for Velocity
 * and Mass. If a component is matched from a prefab, this operation will also
 * return false.
 * 
 * @param it The it parameter passed into the system.
 * @param index The index identifying the column in a system signature.
 * @return True if column is owned, false if column is not.
 */
FLECS_EXPORT
bool ecs_is_owned(
    const ecs_iter_t *it,
    int32_t column);

/** Obtain a single element. 
 * This operation is similar to ecs_column, but instead of an array it obtains
 * a single element from a component array. The advantage of using ecs_element
 * is that a system can be agnostic towards whether a component is owned or not,
 * at the cost of some additional performance overhead.
 *
 * @param it The iterator.
 * @param size The component size.
 * @param column The index identifying the column in a signature.
 * @param row The current row in the table.
 * @return A pointer to the current element.
 */
FLECS_EXPORT
void *ecs_element_w_size(
    const ecs_iter_t *it,
    size_t size,
    int32_t column,
    int32_t row);

/** Obtain a single element. 
 * Same as ecs_element_w_size, but allows specifying a typename instead of a
 * size.
 *
 * @param it The iterator.
 * @param type The column type.
 * @param column The index identifying the column in a signature.
 * @param row The current row in the table.
 * @return A pointer to the current element.
 */
#define ecs_element(it, type, column, row)\
    ((type*)ecs_element_w_size(it, sizeof(type), column, row))

/** Obtain the source of a signature column.
 * This operation returns the source of a signature column. By default this will
 * return 0 for regular columns, but for columns where the components are
 * provided by entities other than the entity being iterated over, this will
 * return the source of the component.
 * 
 * @param it Pointer to the it object passed into the system callback.
 * @param column The index identifying the column in a signature.
 * @return The source entity for the column. 
 */
FLECS_EXPORT
ecs_entity_t ecs_column_source(
    const ecs_iter_t *it,
    int32_t column);

/** Obtain the entity id of the signature column.
 * This operation returns the entity id of the component or tag used in the
 * system signature. For example, when provided this signature:
 *
 * Position, Velocity
 *
 * ecs_column_entity(world, 1) will return the component handle for Position and
 * ecs_column_entity(world, 2) will return the componnet handle for Velocity.
 * 
 * @param it The iterator.
 * @param column The index identifying the column in a signature.
 * @return The entity id of the signature column.
 */
FLECS_EXPORT
ecs_entity_t ecs_column_entity(
    const ecs_iter_t *it,
    int32_t column);

/** Obtain the type of a column from inside a system. 
 * This operation is equivalent to ecs_column_entity, except that it returns
 * a type, instead of an entity handle. Invoking this function is the same as
 * doing:
 * 
 * ecs_type_from_entity( ecs_column_entity(it, index));
 * 
 * @param it The iterator.
 * @param column The index identifying the column in a signature.
 * @return The type for the specified column, or NULL if failed.
 */ 
FLECS_EXPORT
ecs_type_t ecs_column_type(
    const ecs_iter_t *it,
    int32_t column);

/** Is the column readonly.
 * This operation returns if the column is a readonly column. Readonly columns
 * are marked in the system signature with the [in] modifier. 
 * 
 * @param it Pointer to the it object passed into the system callback.
 * @param column An index identifying the column.
 * @return True if the column is readonly, false otherwise. */
FLECS_EXPORT
bool ecs_is_readonly(
    const ecs_iter_t *it,
    int32_t column);

/** Get type of table that system is currently iterating over. 
 * This will return the type for all entities that are currently being iterated
 * over, until ecs_iter_next is invoked.
 *
 * @param it The iterator.
 * @return The type of the current table.
 */
FLECS_EXPORT
ecs_type_t ecs_iter_type(
    const ecs_iter_t *it);

/** Get component array from table.
 * In some cases an application may require access to the table component arrays
 * directly instead of going through the signature to table mapping. A typical
 * scenario where this would be used is when using a filter iterator, where
 * there is no signature, and thus ecs_column cannot be used.
 *
 * @param it The iterator.
 * @param column The index identifying the column in a table.
 * @return The component array corresponding to the column index.
 */
FLECS_EXPORT
void* ecs_table_column(
    const ecs_iter_t *it,
    int32_t column);

/** Get the size of a table column.
 *
 * @param it The iterator.
 * @param component The component for which to obtain the index. 
 */
FLECS_EXPORT
size_t ecs_table_column_size(
    const ecs_iter_t *it,
    int32_t column_index);

/** Get the index of the table column for a component.
 * 
 * @param it The iterator.
 * @param component The component for which to obtain the index.
 */
int32_t ecs_table_component_index(
    const ecs_iter_t *it,
    ecs_entity_t component);

/** Get a strongly typed pointer to a column (owned or shared). */
#define ECS_COLUMN(it, type, id, column)\
    ECS_ENTITY_VAR(type) = ecs_column_entity(it, column);\
    ECS_TYPE_VAR(type) = ecs_column_type(it, column);\
    type *id = ecs_column(it, type, column);\
    (void)ecs_entity(type);\
    (void)ecs_type(type);\
    (void)id

/** Get a strongly typed pointer to a column (owned or shared). */
#define ECS_CONST_COLUMN(it, type, id, column)\
    const type *id = ecs_const_column(it, type, column)

/** Obtain a handle to the component of a column */
#define ECS_COLUMN_COMPONENT(it, id, column)\
    ECS_ENTITY_VAR(id) = ecs_column_entity(it, column);\
    ECS_TYPE_VAR(id) = ecs_column_type(it, column);\
    (void)ecs_entity(id);\
    (void)ecs_type(id)

/** Obtain a handle to the entity of a column */
#define ECS_COLUMN_ENTITY(it, id, column)\
    ecs_entity_t id = ecs_column_entity(it, column);\
    ECS_TYPE_VAR(id) = ecs_column_type(it, column);\
    (void)id;\
    (void)ecs_type(id)

/** Utility macro for importing all handles for a module from a system column */
#define ECS_IMPORT_COLUMN(it, module, column) \
    module *ecs_module_ptr(module) = ecs_column(it, module, column);\
    ecs_assert(ecs_module_ptr(module) != NULL, ECS_MODULE_UNDEFINED, #module);\
    ecs_assert(!ecs_is_owned(it, column), ECS_COLUMN_IS_NOT_SHARED, NULL);\
    module ecs_module(module) = *ecs_module_ptr(module);\
    module##ImportHandles(ecs_module(module))


////////////////////////////////////////////////////////////////////////////////
//// Module API
////////////////////////////////////////////////////////////////////////////////

/** Import a module.
 * This operation will load a modules and store the public module handles in the
 * handles_out out parameter. The module name will be used to verify if the
 * module was already loaded, in which case it won't be reimported. The name
 * will be translated from PascalCase to an entity path (pascal.case) before the
 * lookup occurs.
 *
 * Module contents will be stored as children of the module entity. This 
 * prevents modules from accidentally defining conflicting identifiers. This is
 * enforced by setting the scope before and after loading the module to the 
 * module entity id.
 *
 * A more convenient way to import a module is by using the ECS_IMPORT macro.
 *
 * @param world The world.
 * @param module The module to load.
 * @param module_name The name of the module to load.
 * @param flags An integer that will be passed into the module import action.
 * @param handles_out A struct with handles to the module components/systems.
 * @param handles_size Size of the handles_out parameter.
 * @return The module entity.
 */
FLECS_EXPORT
ecs_entity_t ecs_import(
    ecs_world_t *world,
    ecs_module_action_t module,
    const char *module_name,
    void *handles_out,
    size_t handles_size);

/* Import a module from a library.
 * Similar to ecs_import, except that this operation will attempt to load the 
 * module from a dynamic library.
 *
 * A library may contain multiple modules, which is why both a library name and
 * a module name need to be provided. If only a library name is provided, the
 * library name will be reused for the module name.
 *
 * The library will be looked up using a canonical name, which is in the same
 * form as a module, like `flecs.components.transform`. To transform this
 * identifier to a platform specific library name, the operation relies on the
 * module_to_dl callback of the os_api which the application has to override if
 * the default does not yield the correct library name.
 *
 * @param world The world.
 * @param library_name The name of the library to load.
 * @param module_name The name of the module to load.
 * @param flags The flags to pass to the module.
 */
FLECS_EXPORT
ecs_entity_t ecs_import_from_library(
    ecs_world_t *world,
    const char *library_name,
    const char *module_name);

/** Define module
 */
#define ECS_MODULE(world, id)\
    ECS_ENTITY_VAR(id) = ecs_new_module(world, 0, #id, sizeof(id), ECS_ALIGNOF(id));\
    ECS_VECTOR_STACK(FLECS__T##id, ecs_entity_t, &FLECS__E##id, 1);\
    id *handles = (id*)ecs_get_mut(world, ecs_entity(id), id, NULL);\
    (void)ecs_entity(id);\
    (void)ecs_type(id);\
    (void)handles;

/** Wrapper around ecs_import.
 * This macro provides a convenient way to load a module with the world. It can
 * be used like this:
 *
 * ECS_IMPORT(world, FlecsSystemsPhysics, 0);
 * 
 * This macro will define entity and type handles for the component associated
 * with the module. An application can retrieve the module component like this:
 * 
 * FlecsSystemsPhysics m = ecs_get(world, EcsSingleton, FlecsSystemsPhysics);
 * 
 * The contents of a module component are module specific, although they
 * typically contain handles to the content of the module.
 */
#define ECS_IMPORT(world, id) \
    id ecs_module(id);\
    char *id##__name = ecs_module_path_from_c(#id);\
    ECS_ENTITY_VAR(id) = ecs_import(\
        world, id##Import, id##__name, &ecs_module(id), sizeof(id));\
    ecs_os_free(id##__name);\
    ECS_VECTOR_STACK(FLECS__T##id, ecs_entity_t, &FLECS__E##id, 1);\
    id##ImportHandles(ecs_module(id));\
    (void)ecs_entity(id);\
    (void)ecs_type(id);\

/** Utility macro for declaring a component inside a handles type */
#define ECS_DECLARE_COMPONENT(type)\
    ECS_ENTITY_VAR(type);\
    ECS_TYPE_VAR(type)

/** Utility macro for declaring a system inside a handles type */
#define ECS_DECLARE_ENTITY(entity)\
    ecs_entity_t entity;\
    ECS_TYPE_VAR(entity)

#define ECS_EXPORT_COMPONENT(type)\
    ECS_SET_COMPONENT(type)

#define ECS_EXPORT_ENTITY(type)\
    ECS_SET_ENTITY(type)

/** Utility macro for declaring handles by modules */
#define ECS_IMPORT_COMPONENT(handles, id)\
    ECS_ENTITY_VAR(id) = (handles).ecs_entity(id); (void)ecs_entity(id);\
    ECS_VECTOR_STACK(FLECS__T##id, ecs_entity_t, &FLECS__E##id, 1);\
    (void)ecs_entity(id);\
    (void)ecs_type(id)

/** Utility macro for declaring handles by modules */
#define ECS_IMPORT_ENTITY(handles, id)\
    ecs_entity_t id = (handles).id;\
    ECS_VECTOR_STACK(FLECS__T##id, ecs_entity_t, &id, 1);\
    (void)id;\
    (void)ecs_type(id)


////////////////////////////////////////////////////////////////////////////////
//// Staging API
////////////////////////////////////////////////////////////////////////////////

/** Begin staging.
 * When staging is enabled, modifications to entities are stored to a stage.
 * This ensures that arrays are not modified while iterating. Modifications are
 * merged back to the "main stage" when ecs_staging_end is invoked.
 *
 * @param world The world
 * @return Whether world is currently staged.
 */
FLECS_EXPORT
bool ecs_staging_begin(
    ecs_world_t *world);

/** End staging.
 * If any data was staged, this operation will merge that data back to the main
 * stage.
 *
 * @param world The world
 * @return Whether world was staged.
 */
FLECS_EXPORT
bool ecs_staging_end(
    ecs_world_t *world,
    bool is_staged);

/** Manually merge.
 * When automerging is set to false, an application can invoke this operation to
 * force merging all stages.
 *
 * @param world The world.
 */
FLECS_EXPORT
void ecs_merge(
    ecs_world_t *world);

/** Enable / disable automerging.
 * When automerging is enabled, running a pipeline will automatically merge when
 * necessary. With automerging disabled, merging will not happen unless the
 * application manually invokes ecs_merge.
 *
 * @param world The world.
 */
FLECS_EXPORT
void ecs_set_automerge(
    ecs_world_t *world,
    bool auto_merge);


////////////////////////////////////////////////////////////////////////////////
//// Utilities
////////////////////////////////////////////////////////////////////////////////

/** Enables admin web server
 * This operation allows an profile and enable/disable registered systems. If
 * the flecs.systems.civetweb or flecs.systems.admin modules cannot be found,
 * the operation will fail.
 *
 * @param world The world.
 * @param port A port number for server.
 * 
 * @return The error code
 *          0 - success
 *          1 - failed to dynamically load `flecs.systems.civetweb` module
 *          2 - failed to dynamically load `flecs.systems.admin` module
 */
FLECS_EXPORT
int ecs_enable_admin(
	ecs_world_t* world,
	uint16_t port);

/** Enable command line console for inspecting Flecs internals.
 * If the flecs.systems.console module cannot be found, the operation will fail.
 *
 * @param world The world.
 * @return 0 if success, nonzero if failed.  
 */
FLECS_EXPORT
int ecs_enable_console(
	ecs_world_t* world);

/* Optional modules */
#ifndef FLECS_NO_MODULES

#ifndef FLECS_SYSTEMS_H
#define FLECS_SYSTEMS_H


#ifdef __cplusplus
extern "C" {
#endif


////////////////////////////////////////////////////////////////////////////////
//// Components
////////////////////////////////////////////////////////////////////////////////

FLECS_EXPORT
extern ecs_type_t
    ecs_type(EcsTrigger),
    ecs_type(EcsSystem),
    ecs_type(EcsTickSource),
    ecs_type(EcsSignatureExpr),
    ecs_type(EcsSignature),
    ecs_type(EcsQuery),
    ecs_type(EcsIterAction),
    ecs_type(EcsContext);

/* Component used to provide a tick source to systems */
typedef struct EcsTickSource {
    bool tick;           /* True if providing tick */
    float time_elapsed;  /* Time elapsed since last tick */
} EcsTickSource;

/* Signature expression */
typedef struct EcsSignatureExpr {
    const char *expr;
} EcsSignatureExpr;

/* Parsed signature */
typedef struct EcsSignature {
    ecs_sig_t signature;
} EcsSignature;

/* Query component */
typedef struct EcsQuery {
    ecs_query_t *query;
} EcsQuery;

/* System action */
typedef struct EcsIterAction {
    ecs_iter_action_t action;
} EcsIterAction;

/* System context */
typedef struct EcsContext {
    const void *ctx;
} EcsContext;


////////////////////////////////////////////////////////////////////////////////
//// Systems API
////////////////////////////////////////////////////////////////////////////////

/** Declare a systen.
 * This macro declares a system with the specified function, kind and signature. 
 * Systems are matched with entities that match the system signature. The system
 * signature is specified as a comma-separated list of column expressions, where
 * a column expression can be any of the following: 
 *
 * - A simple component identifier ('Position')
 * - An OR expression ('Position | Velocity')
 * - An optional expression ('?Position')
 * - A NOT expression ('!Position')
 * - An OWNED expression ('OWNED:Position')
 * - A SHARED expression ('SHARED:Position')
 * - A PARENT expression ('PARENT:Position')
 * - A CASCADE expression ('CASCADE:Position')
 * - An entity expression ('MyEntity:Position')
 * - An empty expression (':Position')
 * 
 * The systen kind specifies the phase in which the system is ran.
 *
 * Examples:
 * ECS_SYSTEM(world, Move, EcsOnUpdate, Position, Velocity, !AngularVelocity);
 * ECS_SYSTEM(world, Transform, EcsPostUpdate, PARENT:Transform, Transform);
 *
 * In these examples, 'Move' and 'Transform' must be valid identifiers to a C
 * function of the following signature:
 *
 * void Move(ecs_iter_t *it) { ... }
 *
 * Inside this function the system can access the data from the signature with
 * the ECS_COLUMN macro:
 *
 * ECS_COLUMN(it, Position, p, 1);
 * ECS_COLUMN(it, Velocity, v, 2);
 *
 * For more details on system signatures and phases see the Flecs manual.
 */

#ifndef FLECS_LEGACY
#define ECS_SYSTEM(world, name, kind, ...) \
    ecs_iter_action_t ecs_iter_action(name) = name;\
    ecs_entity_t name = ecs_new_system(world, 0, #name, kind, #__VA_ARGS__, ecs_iter_action(name));\
    (void)ecs_iter_action(name);\
    (void)name;
#endif

#define ECS_TRIGGER(world, name, kind, component) \
    ecs_entity_t __F##name = ecs_new_trigger(world, 0, #name, kind, #component, name);\
    ecs_entity_t name = __F##name;\
    (void)__F##name;\
    (void)name;

/** Run a specific system manually.
 * This operation runs a single system manually. It is an efficient way to
 * invoke logic on a set of entities, as manual systems are only matched to
 * tables at creation time or after creation time, when a new table is created.
 *
 * Manual systems are useful to evaluate lists of prematched entities at
 * application defined times. Because none of the matching logic is evaluated
 * before the system is invoked, manual systems are much more efficient than
 * manually obtaining a list of entities and retrieving their components.
 *
 * An application may pass custom data to a system through the param parameter.
 * This data can be accessed by the system through the param member in the
 * ecs_iter_t value that is passed to the system callback.
 *
 * Any system may interrupt execution by setting the interrupted_by member in
 * the ecs_iter_t value. This is particularly useful for manual systems, where
 * the value of interrupted_by is returned by this operation. This, in
 * cominbation with the param argument lets applications use manual systems
 * to lookup entities: once the entity has been found its handle is passed to
 * interrupted_by, which is then subsequently returned.
 *
 * @param world The world.
 * @param system The system to run.
 * @param delta_time: The time passed since the last system invocation.
 * @param param A user-defined parameter to pass to the system.
 * @return handle to last evaluated entity if system was interrupted.
 */
FLECS_EXPORT
ecs_entity_t ecs_run(
    ecs_world_t *world,
    ecs_entity_t system,
    float delta_time,
    void *param);

/** Run system with offset/limit and type filter.
 * This operation is the same as ecs_run, but filters the entities that will be
 * iterated by the system.
 * 
 * Entities can be filtered in two ways. Offset and limit control the range of
 * entities that is iterated over. The range is applied to all entities matched
 * with the system, thus may cover multiple archetypes.
 * 
 * The type filter controls which entity types the system will evaluate. Only
 * types that contain all components in the type filter will be iterated over. A
 * type filter is only evaluated once per table, which makes filtering cheap if
 * the number of entities is large and the number of tables is small, but not as
 * cheap as filtering in the system signature.
 * 
 * @param world The world.
 * @param system The system to invoke.
 * @param delta_time: The time passed since the last system invocation.
 * @param filter A component or type to filter matched entities.
 * @param param A user-defined parameter to pass to the system.
 * @return handle to last evaluated entity if system was interrupted.
 */
FLECS_EXPORT
ecs_entity_t ecs_run_w_filter(
    ecs_world_t *world,
    ecs_entity_t system,
    float delta_time,
    int32_t offset,
    int32_t limit,
    const ecs_filter_t *filter,
    void *param);

/** System status change callback */
typedef enum ecs_system_status_t {
    EcsSystemStatusNone = 0,
    EcsSystemEnabled,
    EcsSystemDisabled,
    EcsSystemActivated,
    EcsSystemDeactivated
} ecs_system_status_t;

typedef void (*ecs_system_status_action_t)(
    ecs_world_t *world,
    ecs_entity_t system,
    ecs_system_status_t status,
    void *ctx);

/** Set system status action.
 * The status action is invoked whenever a system is enabled or disabled. Note
 * that a system may be enabled but may not actually match any entities. In this
 * case the system is enabled but not _active_.
 *
 * In addition to communicating the enabled / disabled status, the action also
 * communicates changes in the activation status of the system. A system becomes
 * active when it has one or more matching entities, and becomes inactive when
 * it no longer matches any entities.
 * 
 * A system switches between enabled and disabled when an application invokes the
 * ecs_enable operation with a state different from the state of the system, for
 * example the system is disabled, and ecs_enable is invoked with enabled: true.
 *
 * Additionally a system may switch between enabled and disabled when it is an
 * EcsOnDemand system, and interest is generated or lost for one of its [out]
 * columns.
 *
 * @param world The world.
 * @param system The system for which to set the action.
 * @param action The action.
 * @param ctx Context that will be passed to the action when invoked.
 */
FLECS_EXPORT
void ecs_set_system_status_action(
    ecs_world_t *world,
    ecs_entity_t system,
    ecs_system_status_action_t action,
    const void *ctx);


////////////////////////////////////////////////////////////////////////////////
//// Module
////////////////////////////////////////////////////////////////////////////////

/* Pipeline component is empty: components and tags in module are static */
typedef struct FlecsSystem {
    int32_t dummy; 
} FlecsSystem;

FLECS_EXPORT
void FlecsSystemImport(
    ecs_world_t *world);

#define FlecsSystemImportHandles(handles)

#ifdef __cplusplus
}
#endif

#endif

#ifndef FLECS_PIPELINE_H
#define FLECS_PIPELINE_H


#ifdef __cplusplus
extern "C" {
#endif


////////////////////////////////////////////////////////////////////////////////
//// Pipeline API
////////////////////////////////////////////////////////////////////////////////

#ifndef FLECS_LEGACY
#define ECS_PIPELINE(world, name, ...) \
    ecs_entity_t name = ecs_new_pipeline(world, 0, #name, #__VA_ARGS__);
#endif

/** Set a custom pipeline.
 * This operation sets the pipeline to run when ecs_progress is invoked.
 *
 * @param world The world.
 * @param pipeline The pipeline to set.
 */
FLECS_EXPORT
void ecs_set_pipeline(
    ecs_world_t *world,
    ecs_entity_t pipeline);       

/** Get the current pipeline.
 * This operation gets the current pipeline.
 *
 * @param world The world.
 * @param pipeline The pipeline to set.
 */
FLECS_EXPORT
ecs_entity_t ecs_get_pipeline(
    ecs_world_t *world);  

/** Progress a world.
 * This operation progresses the world by running all systems that are both
 * enabled and periodic on their matching entities.
 *
 * An application can pass a delta_time into the function, which is the time
 * passed since the last frame. This value is passed to systems so they can
 * update entity values proportional to the elapsed time since their last
 * invocation.
 *
 * When an application passes 0 to delta_time, ecs_progress will automatically
 * measure the time passed since the last frame. If an application does not uses
 * time management, it should pass a non-zero value for delta_time (1.0 is
 * recommended). That way, no time will be wasted measuring the time.
 *
 * @param world The world to progress.
 * @param delta_time The time passed since the last frame.
 * @return false if ecs_quit has been called, true otherwise.
 */
FLECS_EXPORT
bool ecs_progress(
    ecs_world_t *world,
    float delta_time);   

/** Set target frames per second (FPS) for application.
 * Setting the target FPS ensures that ecs_progress is not invoked faster than
 * the specified FPS. When enabled, ecs_progress tracks the time passed since
 * the last invocation, and sleeps the remaining time of the frame (if any).
 *
 * This feature ensures systems are ran at a consistent interval, as well as
 * conserving CPU time by not running systems more often than required.
 *
 * Note that ecs_progress only sleeps if there is time left in the frame. Both
 * time spent in flecs as time spent outside of flecs are taken into
 * account.
 *
 * @param world The world.
 * @param fps The target FPS.
 */
FLECS_EXPORT
void ecs_set_target_fps(
    ecs_world_t *world,
    float fps);

/** Set time scale.
 * Increase or decrease simulation speed by the provided multiplier.
 *
 * @param world The world.
 * @param scale The scale to apply (default = 1).
 */
FLECS_EXPORT 
void ecs_set_time_scale(
    ecs_world_t *world,
    float scale);

/** Reset world clock.
 * Reset the clock that keeps track of the total time passed in the simulation.
 *
 * @param world The world.
 */
FLECS_EXPORT
void ecs_reset_clock(
    ecs_world_t *world);

/** Signal exit
 * This operation signals that the application should quit. It will cause
 * ecs_progress to return false.
 *
 * @param world The world to quit.
 */
FLECS_EXPORT
void ecs_quit(
    ecs_world_t *world);

/** Deactivate systems that are not matched with tables.
 * By default Flecs deactivates systems that are not matched with any tables.
 * However, once a system has been matched with a table it remains activated, to
 * prevent systems from continuously becoming active and inactive.
 *
 * To re-deactivate systems, an application can invoke this function, which will
 * deactivate all systems that are not matched with any tables.
 *
 * @param world The world.
 */
FLECS_EXPORT
void ecs_deactivate_systems(
    ecs_world_t *world);


////////////////////////////////////////////////////////////////////////////////
//// Threading
////////////////////////////////////////////////////////////////////////////////

/** Set number of worker threads.
 * Setting this value to a value higher than 1 will start as many threads and
 * will cause systems to evenly distribute matched entities across threads. The
 * operation may be called multiple times to reconfigure the number of threads
 * used, but never while running a system / pipeline. */
FLECS_EXPORT
void ecs_set_threads(
    ecs_world_t *world,
    int32_t threads);

/** Get current number of threads. */
FLECS_EXPORT
int32_t ecs_get_threads(
    ecs_world_t *world);

/** Get current thread index */
FLECS_EXPORT
int32_t ecs_get_thread_index(
    ecs_world_t *world);


////////////////////////////////////////////////////////////////////////////////
//// Module
////////////////////////////////////////////////////////////////////////////////

/* Pipeline component is empty: components and tags in module are static */
typedef struct FlecsPipeline {
    int32_t dummy; 
} FlecsPipeline;

FLECS_EXPORT
void FlecsPipelineImport(
    ecs_world_t *world);

#define FlecsPipelineImportHandles(handles)

#ifdef __cplusplus
}
#endif

#endif

#ifndef FLECS_TIMERS_H
#define FLECS_TIMERS_H


#ifdef __cplusplus
extern "C" {
#endif


////////////////////////////////////////////////////////////////////////////////
//// Components
////////////////////////////////////////////////////////////////////////////////

FLECS_EXPORT
extern ecs_type_t 
    ecs_type(EcsTimer),
    ecs_type(EcsRateFilter);

/** Component used for timer functionality */
typedef struct EcsTimer {
    float timeout;         /* Timer timeout period */
    float time;            /* Incrementing time value */
    int32_t fired_count;   /* Number of times ticked */
    bool active;           /* Is the timer active or not */
    bool single_shot;      /* Is this a single shot timer */
} EcsTimer;

/* Apply a rate filter to a tick source */
typedef struct EcsRateFilter {
    ecs_entity_t src;
    int32_t rate;
    int32_t tick_count;
    float time_elapsed;   /* Time elapsed since last tick */
} EcsRateFilter;


////////////////////////////////////////////////////////////////////////////////
//// Timer API
////////////////////////////////////////////////////////////////////////////////

/** Set timer timeout.
 * This operation executes any systems associated with the timer after the
 * specified timeout value. If the entity contains an existing timer, the 
 * timeout value will be reset.
 *
 * Any entity can be used as a timer (including systems). If a timeout value is
 * set on a system entity, it will be automatically applied to that system.
 *
 * The timer is synchronous, and is incremented each frame by delta_time.
 *
 * @param world The world.
 * @param timer The timer for which to set the timeout (0 to create one).
 * @param timeout The timeout value.
 * @return The timer entity.
 */
FLECS_EXPORT
ecs_entity_t ecs_set_timeout(
    ecs_world_t *world,
    ecs_entity_t timer,
    float timeout);

/** Get current timeout value for the specified timer.
 * This operation returns the value set by ecs_set_timeout. If no timer is
 * active for this entity, the operation returns 0.
 *
 * After the timeout expires the timer component is removed from the entity.
 * This means that if ecs_get_timeout is invoked after the timer is expired, the
 * operation will return 0.
 *
 * @param world The world.
 * @param timer The timer.
 * @return The current timeout value, or 0 if no timer is active.
 */
FLECS_EXPORT
float ecs_get_timeout(
    ecs_world_t *world,
    ecs_entity_t timer);

/** Set timer interval.
 * This operation will continously invoke systems associated with the timer 
 * after the interval period expires. If the entity contains an existing timer,
 * the interval value will be reset.
 *
 * Any entity can be used as a timer (including systems). If an interval value
 * is set on a system entity, it will be automatically applied to that system.
 *
 * The timer is synchronous, and is incremented each frame by delta_time.
 *
 * @param world The world.
 * @param timer The timer for which to set the interval (0 to create one).
 * @param interval The interval value.
 * @return The timer entity.
 */
FLECS_EXPORT
ecs_entity_t ecs_set_interval(
    ecs_world_t *world,
    ecs_entity_t timer,
    float interval);   

/** Get current interval value for the specified timer.
 * This operation returns the value set by ecs_set_interval. If no timer is
 * active for this entity, the operation returns 0.
 *
 * @param world The world.
 * @param timer The timer for which to set the interval. If 0, an entity will be created.
 * @return The current interval value, or 0 if no timer is active.
 */
FLECS_EXPORT
float ecs_get_interval(
    ecs_world_t *world,
    ecs_entity_t timer);

/** Start timer.
 * This operation resets the timer and starts it with the specified timeout. The
 * entity must have the EcsTimer component (added by ecs_set_timeout and 
 * ecs_set_interval). If the entity does not have the EcsTimer component this
 * operation will assert.
 *
 * @param world The world.
 * @param timer The timer to start.
 */
FLECS_EXPORT
void ecs_start_timer(
    ecs_world_t *world,
    ecs_entity_t timer);

/** Stop timer
 * This operation stops a timer from triggering. The entity must have the 
 * EcsTimer component or this operation will assert.
 *
 * @param world The world.
 * @param timer The timer to stop.
 */
FLECS_EXPORT
void ecs_stop_timer(
    ecs_world_t *world,
    ecs_entity_t timer);

/** Set rate filter.
 * This operation sets the source and rate for a rate filter. A rate filter
 * samples another tick source (or frames, if none provided) and ticks when the
 * number of sampled ticks equals the rate.
 *
 * @param world The world.
 * @param filter The filter entity (0 to create one).
 * @param rate The rate to apply.
 * @param source The tick source (0 to use frames)
 * @return The filter entity.
 */
FLECS_EXPORT
ecs_entity_t ecs_set_rate_filter(
    ecs_world_t *world,
    ecs_entity_t filter,
    int32_t rate,
    ecs_entity_t source);

/** Assign tick source to system.
 * This operation associates a system with a tick source. If the system is both 
 * active and enabled at the moment the tick source fires, it will be executed.
 * If no tick source is associated with a system, it will be invoked every 
 * frame.
 *
 * To disassociate a tick source from a system, use 0 for the tick_source 
 * parameter.
 *
 * Timer and rate filter entities are valid tick sources. An application can
 * also create its own tick source by setting the EcsTickSource component on an
 * entity.
 *
 * If an entity without the EcsTickSource component is provided as tick source,
 * the system will not be executed.
 *
 * @param world The world.
 * @param system The system to associate with the timer.
 * @param timer The timer to associate with the system.
 */ 
FLECS_EXPORT
void ecs_set_tick_source(
    ecs_world_t *world,
    ecs_entity_t system,
    ecs_entity_t tick_source);


////////////////////////////////////////////////////////////////////////////////
//// Module
////////////////////////////////////////////////////////////////////////////////

/* Timers module component */
typedef struct FlecsTimer {
    int32_t dummy;
} FlecsTimer;

FLECS_EXPORT
void FlecsTimerImport(
    ecs_world_t *world);

#define FlecsTimerImportHandles(handles)

#ifdef __cplusplus
}
#endif

#endif
#endif

/* Optional utilities */
#ifndef FLECS_NO_ADDONS
/**
 * @file snapshot.h
 * @brief Snapshot API.
 */

#ifndef FLECS_SNAPSHOT_H
#define FLECS_SNAPSHOT_H

#ifdef __cplusplus
extern "C" {
#endif

/** Create a snapshot.
 * This operation makes a copy of all component in the world that matches the 
 * specified filter.
 *
 * @param world The world to snapshot.
 * @param return The snapshot.
 */
FLECS_EXPORT
ecs_snapshot_t* ecs_snapshot_take(
    ecs_world_t *world);

/** Create a filtered snapshot.
 * This operation is the same as ecs_snapshot_take, but accepts an iterator so
 * an application can control what is stored by the snapshot. 
 *
 * @param iter An iterator to the data to be stored by the snapshot.
 * @param next A function pointer to the next operation for the iterator.
 * @param return The snapshot.
 */
FLECS_EXPORT
ecs_snapshot_t* ecs_snapshot_take_w_iter(
    ecs_iter_t *iter,
    ecs_iter_next_action_t action);

/** Restore a snapshot.
 * This operation restores the world to the state it was in when the specified
 * snapshot was taken. A snapshot can only be used once for restoring, as its
 * data replaces the data that is currently in the world.
 * This operation also resets the last issued entity handle, so any calls to
 * ecs_new may return entity ids that have been issued before restoring the 
 * snapshot.
 *
 * The world in which the snapshot is restored must be the same as the world in
 * which the snapshot is taken.
 *
 * @param world The world to restore the snapshot to.
 * @param snapshot The snapshot to restore. 
 */
FLECS_EXPORT
void ecs_snapshot_restore(
    ecs_world_t *world,
    ecs_snapshot_t *snapshot);

/** Obtain iterator to snapshot data.
 *
 * @param snapshot The snapshot to iterate over.
 * @return Iterator to snapshot data. */
FLECS_EXPORT
ecs_iter_t ecs_snapshot_iter(
    ecs_snapshot_t *snapshot,
    const ecs_filter_t *filter);

/** Progress snapshot iterator.
 * 
 * @param iter The snapshot iterator.
 * @return True if more data is available, otherwise false.
 */
FLECS_EXPORT
bool ecs_snapshot_next(
    ecs_iter_t *iter);


/** Free snapshot resources.
 * This frees resources associated with a snapshot without restoring it.
 *
 * @param world The world.
 * @param snapshot The snapshot to free. 
 */
FLECS_EXPORT
void ecs_snapshot_free(
    ecs_snapshot_t *snapshot);
    
#ifdef __cplusplus
}
#endif

#endif
/**
 * @file serializer.h
 * @brief Blob serializer API.
 */

#ifndef FLECS_READER_WRITER_H
#define FLECS_READER_WRITER_H

#ifdef __cplusplus
extern "C" {
#endif 

typedef enum ecs_blob_header_kind_t {
    EcsStreamHeader,

    /* Stream states */
    EcsTableSegment,
    EcsFooterSegment,

    /* Table segment */
    EcsTableHeader,
    EcsTableTypeSize,
    EcsTableType,
    EcsTableSize,
    EcsTableColumn,
    EcsTableColumnHeader,
    EcsTableColumnSize,
    EcsTableColumnData,

    /* Name column (EcsName) */
    EcsTableColumnNameHeader,
    EcsTableColumnNameLength,
    EcsTableColumnName,

    EcsStreamFooter  
} ecs_blob_header_kind_t;

typedef struct ecs_table_reader_t {
    ecs_blob_header_kind_t state;

    int32_t table_index;
    ecs_table_t *table;
    ecs_data_t *data;

    /* Current index in type */
    ecs_size_t type_written;
    ecs_type_t type;

    /* Current column */
    ecs_vector_t *column_vector;
    int32_t column_index;
    int32_t total_columns;

    /* Keep track of how much of the component column has been written */
    void *column_data;
    int16_t column_size;
    int16_t column_alignment;
    ecs_size_t column_written;

    /* Keep track of row when writing non-blittable data */
    int32_t row_index;
    int32_t row_count;

    /* Keep track of how much of an entity name has been written */
    const char *name;
    ecs_size_t name_len;
    ecs_size_t name_written;

    bool has_next_table;
} ecs_table_reader_t;

typedef struct ecs_reader_t {
    ecs_world_t *world;
    ecs_blob_header_kind_t state;
    ecs_iter_t data_iter;
    ecs_iter_next_action_t data_next;
    ecs_iter_t component_iter;
    ecs_iter_next_action_t component_next;
    ecs_table_reader_t table;
} ecs_reader_t;

typedef struct ecs_name_writer_t {
    char *name;
    int32_t written;
    int32_t len;
    int32_t max_len;
} ecs_name_writer_t;

typedef struct ecs_table_writer_t {
    ecs_blob_header_kind_t state;

    ecs_table_t *table;
    ecs_vector_t *column_vector;

    /* Keep state for parsing type */
    int32_t type_count;
    int32_t type_max_count;
    ecs_size_t type_written;
    ecs_entity_t *type_array;
    
    int32_t column_index;
    int16_t column_size;
    int16_t column_alignment;
    ecs_size_t column_written;
    void *column_data;

    int32_t row_count;
    int32_t row_index;
    ecs_name_writer_t name; 
} ecs_table_writer_t;

typedef struct ecs_writer_t {
    ecs_world_t *world;
    ecs_blob_header_kind_t state;
    ecs_table_writer_t table;
    int error;
} ecs_writer_t;

/** Initialize a reader.
 * A reader serializes data in a world to a sequence of bytes that can be stored
 * in a file or sent across a network. 
 *
 * @param world The world to serialize.
 * @return The reader.
 */
FLECS_EXPORT
ecs_reader_t ecs_reader_init(
    ecs_world_t *world);

/** Initialize a snapshot reader.
 * A snapshot reader serializes data in a snapshot to a sequence of bytes that 
 * can be stored in a file or sent across a network. A snapshot reader has as
 * advantage that serialization can take place asynchronously while the world
 * is progressing.
 *
 * @param world The world in which the snapshot is taken.
 * @param iter Iterator to the data to be serialized.
 * @return The reader.
 */
FLECS_EXPORT
ecs_reader_t ecs_reader_init_w_iter(
    ecs_iter_t *iter,
    ecs_iter_next_action_t next);

/** Read from a reader.
 * This operation reads a specified number of bytes from a reader and stores it
 * in the specified buffer. When there are no more bytes to read from the reader
 * the operation will return 0, otherwise it will return the number of bytes
 * read.
 *
 * The specified buffer must be at least as big as the specified size, and the
 * specified size must be a multiple of 4.
 *
 * @param buffer The buffer in which to store the read bytes.
 * @param size The maximum number of bytes to read.
 * @param reader The reader from which to read the bytes.
 * @return The number of bytes read.
 */ 
FLECS_EXPORT
ecs_size_t ecs_reader_read(
    char *buffer,
    ecs_size_t size,
    ecs_reader_t *reader);

/** Initialize a writer.
 * A writer deserializes data from a sequence of bytes into a world. This 
 * enables applications to restore data from disk or the network.
 *
 * The provided world must be either empty or compatible with the data to
 * deserialize, where compatible means that the serialized component ids and 
 * sizes must match exactly with those in the world. Errors can occur if a world
 * is provided in which components have been declared in a different order, or
 * when components have different type definitions.
 *
 * @param world The world in which to deserialize the data.
 * @return The writer. 
 */
FLECS_EXPORT
ecs_writer_t ecs_writer_init(
    ecs_world_t *world);

/** Write to a writer.
 * This operation writes a specified number of bytes from a specified buffer
 * into the writer. The writer will restore the deserialized data into the 
 * original serialized entities. The write operation may be invoked multiple
 * times with partial buffers, which allows applications to use static buffers
 * when reading from, for example, a file or the network.
 *
 * The data contained in the buffers must have been serialized with the
 * ecs_reader_read operation. If the data does not match the expected format, or
 * the data contains conflicts with the world, the operation will fail. The
 * data must be provided in the same order as produced by ecs_reader_read,
 * but the used buffer size does not have to be the same as the one used by
 * ecs_reader_read. The buffer size must be a multiple of 4.
 * 
 * @param buffer The buffer to deserialize.
 * @param size The maximum number of bytes.
 * @param writer The writer to write to.
 * @return Zero if success, non-zero if failed to deserialize.
 */
FLECS_EXPORT
int ecs_writer_write(
    const char *buffer,
    ecs_size_t size,
    ecs_writer_t *writer);

#ifdef __cplusplus
}
#endif     

#endif

#ifndef FLECS_QUEUE_H_
#define FLECS_QUEUE_H_

#ifdef __cplusplus
extern "C" {
#endif

typedef struct ecs_queue_t ecs_queue_t;

FLECS_EXPORT
ecs_queue_t* _ecs_queue_new(
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count);

#define ecs_queue_new(T, elem_count)\
    _ecs_queue_new(ECS_VECTOR_T(T), elem_count)

FLECS_EXPORT
ecs_queue_t* _ecs_queue_from_array(
    ecs_size_t elem_size,
    int16_t offset,
    int32_t elem_count,
    void *array);

#define ecs_queue_from_array(T, elem_count, array)\
    _ecs_queue_from_array(ECS_VECTOR_T(T), elem_count, array)

FLECS_EXPORT
void* _ecs_queue_push(
    ecs_queue_t *queue,
    ecs_size_t elem_size,
    int16_t offset);

#define ecs_queue_push(queue, T)\
    (T*)_ecs_queue_push(queue, ECS_VECTOR_T(T))

FLECS_EXPORT
void* _ecs_queue_get(
    ecs_queue_t *queue,
    ecs_size_t elem_size,
    int16_t offset,
    int32_t index);

#define ecs_queue_get(queue, T, index)\
    (T*)_ecs_queue_get(queue, ECS_VECTOR_T(T), index)

#define ecs_queue_get_t(vector, size, alignment, index) \
    _ecs_queue_get(vector, ECS_VECTOR_U(size, alignment), index)

FLECS_EXPORT
void* _ecs_queue_last(
    ecs_queue_t *queue,
    ecs_size_t elem_size,
    int16_t offset);

#define ecs_queue_last(queue, T)\
    (T*)_ecs_queue_last(queue, ECS_VECTOR_T(T))

FLECS_EXPORT
int32_t ecs_queue_index(
    ecs_queue_t *queue);

FLECS_EXPORT
int32_t ecs_queue_count(
    ecs_queue_t *queue);

FLECS_EXPORT
void ecs_queue_free(
    ecs_queue_t *queue);

#ifdef __cplusplus
}
#endif

#endif
#endif

#ifdef __cplusplus
}

#ifndef FLECS_NO_CPP
#ifndef FLECS_LEGACY
#pragma once

/* Unstable API */

#include <string>
#include <sstream>
#include <array>
#include <functional>

namespace flecs {

////////////////////////////////////////////////////////////////////////////////
//// Forward declarations and types
////////////////////////////////////////////////////////////////////////////////

using world_t = ecs_world_t;
using entity_t = ecs_entity_t;
using type_t = ecs_type_t;
using snapshot_t = ecs_snapshot_t;
using filter_t = ecs_filter_t;
using query_t = ecs_query_t;

class world;
class snapshot;
class entity;
class type;
class iter;
class filter;
class filter_iterator;
class child_iterator;
class world_filter;
class snapshot_filter;

template<typename ... Components>
class query_iterator;

template<typename ... Components>
class query;

template <typename T>
class component_info;

enum match_kind {
    MatchAll = EcsMatchAll,
    MatchAny = EcsMatchAny,
    MatchExact = EcsMatchExact
};

template <typename ...Components>
bool pack_args_to_string(std::stringstream& str, bool is_each = false);


////////////////////////////////////////////////////////////////////////////////
//// Builtin components and tags 
////////////////////////////////////////////////////////////////////////////////

/* Builtin components */
using Component = EcsComponent;
using ComponentLifecycle = EcsComponentLifecycle;
using Trigger = EcsTrigger;
using Type = EcsType;
using Name = EcsName;
using Timer = EcsTimer;
using RateFilter = EcsRateFilter;
using TickSource = EcsTickSource;
using SignatureExpr = EcsSignatureExpr;
using Signature = EcsSignature;
using Query = EcsQuery;
using ViewAction = EcsIterAction;
using Context = EcsContext;

/* Builtin tag ids */
static const ecs_entity_t Module = EcsModule;
static const ecs_entity_t Prefab = EcsPrefab;
static const ecs_entity_t Hidden = EcsHidden;
static const ecs_entity_t Disabled = EcsDisabled;
static const ecs_entity_t DisabledIntern = EcsDisabledIntern;
static const ecs_entity_t Inactive = EcsInactive;
static const ecs_entity_t OnDemand = EcsOnDemand;
static const ecs_entity_t Monitor = EcsMonitor;
static const ecs_entity_t Pipeline = EcsPipeline;

/* Trigger tags */
static const ecs_entity_t OnAdd = EcsOnAdd;
static const ecs_entity_t OnRemove = EcsOnRemove;
static const ecs_entity_t OnSet = EcsOnSet;

/* Builtin pipeline tags */
static const ecs_entity_t PreFrame = EcsPreFrame;
static const ecs_entity_t OnLoad = EcsOnLoad;
static const ecs_entity_t PostLoad = EcsPostLoad;
static const ecs_entity_t PreUpdate = EcsPreUpdate;
static const ecs_entity_t OnUpdate = EcsOnUpdate;
static const ecs_entity_t OnValidate = EcsOnValidate;
static const ecs_entity_t PostUpdate = EcsPostUpdate;
static const ecs_entity_t PreStore = EcsPreStore;
static const ecs_entity_t OnStore = EcsOnStore;
static const ecs_entity_t PostFrame = EcsPostFrame;

/** Builtin entity ids */
static const ecs_entity_t World = EcsWorld;
static const ecs_entity_t Singleton = EcsSingleton;

/** Builtin roles */
static const ecs_entity_t Childof = ECS_CHILDOF;
static const ecs_entity_t Instanceof = ECS_INSTANCEOF;


////////////////////////////////////////////////////////////////////////////////
//// Wrapper class around a table column
////////////////////////////////////////////////////////////////////////////////

template <typename T>
class column {
public:
    column(T* array, std::size_t count, bool is_shared = false)
        : m_array(array)
        , m_count(count) 
        , m_is_shared(is_shared) {}

    column(iter &iter, int column);

    T& operator[](size_t index) {
        ecs_assert(index < m_count, ECS_COLUMN_INDEX_OUT_OF_RANGE, NULL);
        ecs_assert(!m_is_shared, ECS_INVALID_PARAMETER, NULL);
        return m_array[index];
    }

    T* operator->() {
        ecs_assert(m_array != nullptr, ECS_COLUMN_INDEX_OUT_OF_RANGE, NULL);
        return m_array;
    }

    bool is_set() const {
        return m_array != nullptr;
    }

    bool is_shared() const {
        return m_is_shared;
    }

protected:
    T* m_array;
    size_t m_count;
    bool m_is_shared;
};


////////////////////////////////////////////////////////////////////////////////
//// Like flecs::column, but abstracts away from shared vs. owned columns
////////////////////////////////////////////////////////////////////////////////

template <typename T, typename = void>
class any_column { };

template <typename T>
class any_column<T, typename std::enable_if<std::is_pointer<T>::value == true>::type > final : public column<typename std::remove_pointer<T>::type> {
public:
    any_column(T array, std::size_t count, bool is_shared = false)
        : column<typename std::remove_pointer<T>::type>(array, count, is_shared) { }

    T operator[](size_t index) {
        if (!this->m_is_shared) {
            ecs_assert(index < this->m_count, ECS_COLUMN_INDEX_OUT_OF_RANGE, NULL);
            if (this->m_array) {
                return &this->m_array[index];
            } else {
                return nullptr;
            }
        } else {
            return &this->m_array[0];
        }
    }   
};

template <typename T>
class any_column<T, typename std::enable_if<std::is_pointer<T>::value == false>::type> final : public column<T> {
public:
    any_column(T* array, std::size_t count, bool is_shared = false)
        : column<T>(array, count, is_shared) { }

    T& operator[](size_t index) {
        if (!this->m_is_shared) {
            ecs_assert(index < this->m_count, ECS_COLUMN_INDEX_OUT_OF_RANGE, NULL);
            return this->m_array[index];
        } else {
            return this->m_array[0];
        }
    }   
};


////////////////////////////////////////////////////////////////////////////////
//// Iterate over an integer range (used to iterate over entities in systems)
////////////////////////////////////////////////////////////////////////////////

template <typename T>
class range_iterator
{
public:
    explicit range_iterator(T value)
        : m_value(value){}

    bool operator!=(range_iterator const& other) const
    {
        return m_value != other.m_value;
    }

    T const& operator*() const
    {
        return m_value;
    }

    range_iterator& operator++()
    {
        ++m_value;
        return *this;
    }

private:
    T m_value;
};


////////////////////////////////////////////////////////////////////////////////
//// Type that enables iterating over table columns
////////////////////////////////////////////////////////////////////////////////

class iter final {
    using row_iterator = range_iterator<int>;
public:    
    iter(const ecs_iter_t *it) : m_iter(it) { 
        m_begin = 0;
        m_end = it->count;
    }

    row_iterator begin() const {
        return row_iterator(m_begin);
    }

    row_iterator end() const {
        return row_iterator(m_end);
    }

    /* Obtain handle to current system */
    flecs::entity system() const;

    flecs::world world() const;

    /* Number of entities to iterate over */
    int32_t count() const {
        return m_iter->count;
    }

    /* Return delta_time of current frame */
    float delta_time() const {
        return m_iter->delta_time;
    }

    /* Return time elapsed since last time system was invoked */
    float delta_system_time() const {
        return m_iter->delta_system_time;
    }

    /* Is column shared */
    bool is_shared(int32_t col) const {
        return !ecs_is_owned(m_iter, col);
    }
    
    /* Access param field */
    void *param() {
        return m_iter->param;
    }

    /* Is column readonly */
    bool is_readonly(int32_t col) const {
        return ecs_is_readonly(m_iter, col);
    }

    /* Obtain entity being iterated over for row */
    flecs::entity entity(int32_t row) const;

    /* Obtain column source (0 if self) */
    flecs::entity column_source(int32_t col) const;

    /* Obtain component/tag entity of column */
    flecs::entity column_entity(int32_t col) const;

    /* Obtain type of column */
    type column_type(int32_t col) const;

    /* Obtain type of table being iterated over */
    type table_type() const;

    int32_t table_count() const {
        return m_iter->table_count;
    }

    int32_t inactive_table_count() const {
        return m_iter->inactive_table_count;
    }

    /* Obtain untyped pointer to table column */
    void* table_column(int32_t col) const {
        return ecs_table_column(m_iter, col);
    }

    /* Obtain typed pointer to table column */
    template <typename T>
    flecs::column<T> table_column() const {
        auto type = ecs_iter_type(m_iter);
        auto col = ecs_type_index_of(type, component_info<T>::s_entity);
        ecs_assert(col != -1, ECS_INVALID_PARAMETER, NULL);
        return flecs::column<T>(static_cast<T*>(ecs_table_column(m_iter, col)), m_iter->count, false);
    }

    /* Obtain column with a const type */
    template <typename T,
        typename std::enable_if<std::is_const<T>::value, void>::type* = nullptr>
    flecs::column<T> column(unsigned int col) const {
        return get_column<T>(col);
    }

    /* Obtain column with non-const type. Ensure that column is not readonly */
    template <typename T,
        typename std::enable_if<std::is_const<T>::value == false, void>::type* = nullptr>
    flecs::column<T> column(int32_t col) const {
        ecs_assert(!ecs_is_readonly(m_iter, col), ECS_COLUMN_ACCESS_VIOLATION, NULL);
        return get_column<T>(col);
    }  

    /* Get owned */
    template <typename T>
    flecs::column<T> owned(int32_t col) const {
        ecs_assert(!!ecs_is_owned(m_iter, col), ECS_COLUMN_IS_SHARED, NULL);
        return this->column<T>(col);
    }

    /* Get shared */
    template <typename T>
    const T& shared(int32_t col) const {
        ecs_assert(ecs_column_entity(m_iter, col) == component_info<T>::s_entity, ECS_COLUMN_TYPE_MISMATCH, NULL);
        ecs_assert(!ecs_is_owned(m_iter, col), ECS_COLUMN_IS_NOT_SHARED, NULL);
        return *static_cast<T*>(ecs_column_w_size(m_iter, sizeof(T), col));
    }

    /* Get single field of a const type */
    template <typename T,
        typename std::enable_if<std::is_const<T>::value, void>::type* = nullptr>    
    T& field(int32_t col, int32_t row) const {
        return get_field<T>(col, row);
    }

    /* Get single field of a non-const type. Ensure that column is not readonly */
    template <typename T,
        typename std::enable_if<std::is_const<T>::value == false, void>::type* = nullptr>
    T& field(int32_t col, int32_t row) const {
        ecs_assert(!ecs_is_readonly(m_iter, col), ECS_COLUMN_ACCESS_VIOLATION, NULL);
        return get_field<T>(col, row);
    }

private:
    /* Get column, check if correct type is used */
    template <typename T>
    flecs::column<T> get_column(int32_t column_id) const {
        ecs_assert(ecs_column_entity(m_iter, column_id) == component_info<T>::s_entity, ECS_COLUMN_TYPE_MISMATCH, NULL);
        int32_t count;
        bool is_shared = !ecs_is_owned(m_iter, column_id);

        /* If a shared column is retrieved with 'column', there will only be a
         * single value. Ensure that the application does not accidentally read
         * out of bounds. */
        if (is_shared) {
            count = 1;
        } else {
            /* If column is owned, there will be as many values as there are
             * entities. */
            count = m_iter->count;
        }

        return flecs::column<T>(static_cast<T*>(ecs_column_w_size(m_iter, sizeof(T), column_id)), count, is_shared);
    }   

    /* Get single field, check if correct type is used */
    template <typename T>
    T& get_field(int32_t col, int32_t row) const {
        ecs_assert(ecs_column_entity(m_iter, col) == component_info<T>::s_entity, ECS_COLUMN_TYPE_MISMATCH, NULL);
        return *static_cast<T*>(ecs_element_w_size(m_iter, sizeof(T), col, row));
    }       

    const ecs_iter_t *m_iter;
    int32_t m_begin;
    int32_t m_end;
};

template <typename T>
inline column<T>::column(iter &iter, int col) {
    *this = iter.column<T>(col);
}


////////////////////////////////////////////////////////////////////////////////
//// The ECS world
////////////////////////////////////////////////////////////////////////////////

class world final {
public:
    world() 
        : m_world( ecs_init() )
        , m_owned( true ) { init_builtin_components(); }

    world(int argc, char *argv[])
        : m_world( ecs_init_w_args(argc, argv) )
        , m_owned( true ) { init_builtin_components(); }

    explicit world(world_t *w) 
        : m_world( w ) 
        , m_owned( false ) { }

    /* Not allowed to copy a world. May only take a reference */
    world(const world& obj) = delete;

    world(world&& obj) {
        m_world = obj.m_world;
    }

    /* Not allowed to copy a world. May only take a reference */
    world& operator=(const world& obj) = delete;

    world& operator=(world&& obj) {
        m_world = obj.m_world;
        return *this;
    }
    
    ~world() { 
        if (m_owned) {
            ecs_fini(m_world); 
        }
    }

    world_t* c_ptr() const {
        return m_world;
    }

    bool progress(float delta_time = 0.0) const {
        return ecs_progress(m_world, delta_time);
    }

    /* Threading */
    void set_threads(std::int32_t threads) const {
        ecs_set_threads(m_world, threads);
    }

    std::int32_t get_threads() const {
        return ecs_get_threads(m_world);
    }

    std::int32_t get_thread_index() const {
        return ecs_get_thread_index(m_world);
    }

    /* Time management */
    void set_target_fps(float target_fps) const {
        ecs_set_target_fps(m_world, target_fps);
    }

    float get_target_fps() const {
        const ecs_world_info_t *stats = ecs_get_world_info(m_world);
        return stats->target_fps;
    }

    std::int32_t get_tick() const {
        const ecs_world_info_t *stats = ecs_get_world_info(m_world);
        return stats->frame_count_total;

    }

    /* Get/set user-context */
    void set_context(void* ctx) const {
        ecs_set_context(m_world, ctx);
    }

    void* get_context() const {
        return ecs_get_context(m_world);
    }

    /* Preallocating memory */
    void dim(std::int32_t entity_count) const {
        ecs_dim(m_world, entity_count);
    }

    void dim_type(type_t type, std::int32_t entity_count) const {
        ecs_dim_type(m_world, type, entity_count);
    }

    /* Entity ranges */
    void set_entity_range(entity_t min, entity_t max) const {
        ecs_set_entity_range(m_world, min, max);
    }

    void enable_range_check(bool enabled) const {
        ecs_enable_range_check(m_world, enabled);
    }

    /* Lookup by name */
    entity lookup(const char *name) const;
    entity lookup(std::string& name) const;

    /* Bulk operations */
    void delete_entities(flecs::filter filter) const;

    template <typename T>
    void add() const;
    template <typename T>
    void add(flecs::filter filter) const;

    void add(type type) const;
    void add(type type, flecs::filter filter) const;

    void add(entity entity) const;
    void add(entity entity, flecs::filter filter) const;

    template <typename T>
    void remove() const;
    template <typename T>
    void remove(flecs::filter filter) const;

    void remove(type type) const;
    void remove(type type, flecs::filter filter) const;

    void remove(entity entity) const;
    void remove(entity entity, flecs::filter filter) const;

    /* Iterate world tables */
    world_filter filter(const flecs::filter& filter) const;
    filter_iterator begin() const;
    filter_iterator end() const;

    /* Count entities */
    template <typename T>
    int count() const {
        return ecs_count_type(m_world, component_info<T>::s_type);
    }

    int count(flecs::filter filter) const;

    /* Enable locking */
    bool enable_locking(bool enabled) {
        return ecs_enable_locking(m_world, enabled);
    }

    /* Lock world */
    void lock() {
        ecs_lock(m_world);
    }

    /* Unlock world */
    void unlock() {
        ecs_unlock(m_world);
    }
    
private:
    void init_builtin_components();

    world_t *m_world;
    bool m_owned;
};


////////////////////////////////////////////////////////////////////////////////
//// Fluent API for chaining entity operations
////////////////////////////////////////////////////////////////////////////////

template <typename base>
class entity_fluent {
    using base_type = const base;
public:

    /* -- adopt -- */

    base_type& add(entity_t entity) const {
        static_cast<base_type*>(this)->invoke(
        [entity](world_t *world, entity_t id) {
            ecs_add_entity(world, id, entity);
        });
        return *static_cast<base_type*>(this);         
    }

    template <typename T>
    base_type& add() const {
        return add(component_info<T>::s_entity);
    }

    base_type& add(const entity& entity) const;

    base_type& add(type_t type) const {
        static_cast<base_type*>(this)->invoke(
        [type](world_t *world, entity_t id) {
            ecs_add_type(world, id, type);
        });
        return *static_cast<base_type*>(this); 
    }

    base_type& add(type type) const;

    /* -- remove -- */

    base_type& remove(entity_t entity) const {
        static_cast<base_type*>(this)->invoke(
        [entity](world_t *world, entity_t id) {
            ecs_remove_entity(world, id, entity);
        });
        return *static_cast<base_type*>(this);         
    }    

    template <typename T>
    base_type& remove() const {
        return remove(component_info<T>::s_entity);
    }

    base_type& remove(const entity& entity) const;

    base_type& remove(type_t type) const {
        static_cast<base_type*>(this)->invoke(
        [type](world_t *world, entity_t id) {
            ecs_remove_type(world, id, type);
        });
        return *static_cast<base_type*>(this);         
    }

    base_type& remove(type type) const;

    /* -- add_childof -- */

    base_type& add_childof(entity_t parent) const {
        static_cast<base_type*>(this)->invoke(
        [parent](world_t *world, entity_t id) {
            ecs_add_entity(world, id, ECS_CHILDOF | parent);
        });
        return *static_cast<base_type*>(this);  
    }

    base_type& add_childof(const entity& parent) const;

    /* -- remove_childof -- */

    base_type& remove_childof(entity_t parent) const {
        static_cast<base_type*>(this)->invoke(
        [parent](world_t *world, entity_t id) {
            ecs_remove_entity(world, id, ECS_CHILDOF | parent);
        });
        return *static_cast<base_type*>(this);  
    }

    base_type& remove_childof(const entity& parent) const;

    /* -- add_instanceof -- */

    base_type& add_instanceof(entity_t base_entity) const {
        static_cast<base_type*>(this)->invoke(
        [base_entity](world_t *world, entity_t id) {
            ecs_add_entity(world, id, ECS_INSTANCEOF | base_entity);
        });
        return *static_cast<base_type*>(this);  
    }

    base_type& add_instanceof(const entity& base_entity) const;  

    /* -- remove_instanceof -- */

    base_type& remove_instanceof(entity_t base_entity) const {
        static_cast<base_type*>(this)->invoke(
        [base_entity](world_t *world, entity_t id) {
            ecs_remove_entity(world, id, ECS_INSTANCEOF | base_entity);
        });
        return *static_cast<base_type*>(this);
    }

    base_type& remove_instanceof(const entity& base_entity) const;

    /* -- set -- */
    template <typename T>
    const base_type& set(const T&& value) const {
        static_cast<base_type*>(this)->invoke(
        [&value](world_t *world, entity_t id) {
            ecs_set_ptr_w_entity(world, id, component_info<T>::s_entity, sizeof(T), &value);
        });
        return *static_cast<base_type*>(this);
    }


    template <typename T>
    const base_type& set(const T& value) const {
        static_cast<base_type*>(this)->invoke(
        [&value](world_t *world, entity_t id) {
            ecs_set_ptr_w_entity(world, id, component_info<T>::s_entity, sizeof(T), &value);
        });
        return *static_cast<base_type*>(this);
    }

    template <typename T>
    const base_type& patch(std::function<void(T&, bool)> func) const {
        static_cast<base_type*>(this)->invoke(
        [&func](world_t *world, entity_t id) {
            bool is_added;

            T *ptr = static_cast<T*>(ecs_get_mut_w_entity(
                world, id, component_info<T>::s_entity, &is_added));

            if (ptr) {
                func(*ptr, !is_added);
                ecs_modified_w_entity(world, id, component_info<T>::s_entity);
            }
        });
        return *static_cast<base_type*>(this);
    }      

    template <typename T>
    const base_type& patch(std::function<void(T&)> func) const {
        static_cast<base_type*>(this)->invoke(
        [&func](world_t *world, entity_t id) {
            bool is_added;

            T *ptr = static_cast<T*>(ecs_get_mut_w_entity(
                world, id, component_info<T>::s_entity, &is_added));

            if (ptr) {
                func(*ptr);
                ecs_modified_w_entity(world, id, component_info<T>::s_entity);
            }
        });
        return *static_cast<base_type*>(this);
    }            
};

////////////////////////////////////////////////////////////////////////////////
//// Cached component pointer
////////////////////////////////////////////////////////////////////////////////

template <typename T>
class ref {
public:
    ref()
        : m_world( nullptr )
        , m_entity( 0 )
        , m_ref() { }

    ref(world_t *world, entity_t entity) 
        : m_world( world )
        , m_entity( entity )
        , m_ref() {
        ecs_get_ref_w_entity(
            m_world, &m_ref, m_entity, component_info<T>::s_entity);
    }

    const T* operator->() {
        const T* result = static_cast<const T*>(ecs_get_ref_w_entity(
            m_world, &m_ref, m_entity, component_info<T>::s_entity));

        ecs_assert(result != NULL, ECS_INVALID_PARAMETER, NULL);

        return result;
    }

    const T* get() {
        if (m_entity) {
            ecs_get_ref_w_entity(
                m_world, &m_ref, m_entity, component_info<T>::s_entity);    
        }

        return static_cast<T*>(m_ref.ptr);
    }

    flecs::entity entity() const;

private:
    world_t *m_world;
    entity_t m_entity;
    ecs_ref_t m_ref;
};


////////////////////////////////////////////////////////////////////////////////
//// Entity
////////////////////////////////////////////////////////////////////////////////

class entity : public entity_fluent<entity> {
public:
    explicit entity(const world& world) 
        : m_world( world.c_ptr() )
        , m_id( ecs_new_w_type(m_world, 0) ) { }

    explicit entity(world_t *world) 
        : m_world( world )
        , m_id( ecs_new_w_type(m_world, 0) ) { }

    entity(const world& world, const char *name) 
        : m_world( world.c_ptr() )
        , m_id( ecs_lookup_path_w_sep(m_world, 0, name, "::", "::") ) 
        { 
            if (!m_id) {
                m_id = ecs_new_from_path_w_sep(m_world, 0, name, "::", "::");
            }
        }

    entity(const world& world, std::string name) 
        : m_world( world.c_ptr() )
        , m_id( ecs_lookup_path_w_sep(m_world, 0, name.c_str(), "::", "::") ) 
        { 
            if (!m_id) {
                m_id = ecs_new_from_path_w_sep(m_world, 0, name.c_str(), "::", "::");
            }
        }         

    entity(const world& world, entity_t id) 
        : m_world( world.c_ptr() )
        , m_id(id) { }

    entity(world_t *world, entity_t id) 
        : m_world( world )
        , m_id(id) { }

    entity() 
        : m_world(nullptr)
        , m_id(0) { }

    static
    flecs::entity nil(const world& world) {
        return flecs::entity(world.c_ptr(), (ecs_entity_t)0);
    }

    entity_t id() const {
        return m_id;
    }

    std::string name() const {
        const EcsName *name = static_cast<const EcsName*>(
            ecs_get_w_entity(m_world, m_id, ecs_entity(EcsName)));
        if (name) {
            return std::string(name->value);
        } else {
            return std::string();
        }
    }

    std::string path() const {
        char *path = ecs_get_path_w_sep(m_world, 0, m_id, 0, "::", "::");
        if (path) {
            std::string result = std::string(path);
            ecs_os_free(path);
            return result;
        } else {
            return std::string();
        }
    }    

    flecs::world world() const {
        return flecs::world(m_world);
    }

    flecs::type type() const;

    flecs::type to_type() const;

    template <typename T>
    const T* get() const {
        return static_cast<const T*>(
            ecs_get_w_entity(m_world, m_id, component_info<T>::s_entity));
    }

    template <typename T>
    T* get_mut(bool *is_added = nullptr) const {
        return static_cast<T*>(
            ecs_get_mut_w_entity(
                m_world, m_id, component_info<T>::s_entity), is_added);
    }

    template <typename T>
    ref<T> get_ref() const {
        return ref<T>(m_world, m_id);
    }

    template <typename Func>
    void invoke(Func&& action) const {
        action(m_world, m_id);
    } 

    void destruct() const {
        ecs_delete(m_world, m_id);
    }

    entity lookup(const char *name) const {
        auto id = ecs_lookup_path_w_sep(m_world, m_id, name, "::", "::");
        return entity(m_world, id);
    }

    /* -- has -- */

    bool has(entity_t id) const {
        return ecs_has_entity(m_world, m_id, id);
    }

    bool has(type_t type) const {
        return ecs_has_type(m_world, m_id, type);
    }

    bool has(const entity& e) const {
        return has(e.id());
    }

    template <typename T>
    bool has() const {
        return has(component_info<T>::s_entity);
    }

    bool owns(entity_t id) const {
        return ecs_owns_entity(m_world, m_id, id, true);
    }

    bool owns(type_t type) const {
        return ecs_type_owns_type(m_world, ecs_get_type(m_world, m_id), type, true);
    }

    bool owns(const entity& e) const {
        return owns(e.id());
    }

    template <typename T>
    bool owns() const {
        return owns(component_info<T>::s_entity);
    }

    float delta_time() {
        const ecs_world_info_t *stats = ecs_get_world_info(m_world);
        return stats->delta_time;
    }

    child_iterator children() const;

    operator bool() {
        return m_id != 0;
    }

protected:
    world_t *m_world;
    entity_t m_id; 
};

/** Prefab class */
class prefab final : public entity {
public:
    prefab(const flecs::world& world, const char *name) 
        : entity(world, name)
    {
        this->add(flecs::Prefab);
    }
};


////////////////////////////////////////////////////////////////////////////////
//// Entity range, allows for operating on a range of consecutive entities
////////////////////////////////////////////////////////////////////////////////

class entity_range final : public entity_fluent<entity_range> {
    using entity_iterator = range_iterator<entity_t>;
public:
    entity_range(const world& world, std::int32_t count) 
        : m_world(world.c_ptr())
        , m_id_start( ecs_bulk_new_w_type(m_world, nullptr, count))
        , m_count(count) { }

    template <typename Func>
    void invoke(Func&& action) const {
        for (auto id : *this) {
            action(m_world, id);
        }
    }
    
    entity_iterator begin() const {
        return entity_iterator(m_id_start);
    }

    entity_iterator end() const {
        return entity_iterator(m_id_start + m_count);
    }

private:
    world_t *m_world;
    entity_t m_id_start;
    std::int32_t m_count;
};


////////////////////////////////////////////////////////////////////////////////
//// A collection of component ids used to describe the contents of a table
////////////////////////////////////////////////////////////////////////////////

class type final : entity {
public:
    type(const flecs::world& world, const char *name = nullptr, const char *expr = nullptr)
        : entity(world, ecs_new_type(world.c_ptr(), 0, name, expr))
    { 
        sync_from_flecs();
    }

    type(const flecs::world& world, type_t t)
        : entity( world )
        , m_type( t )
        , m_normalized( t ) { }

    type(world_t *world, type_t t)
        : entity( world )
        , m_type( t )
        , m_normalized( t ) { }

    type& add(const type& t) {
        m_type = ecs_type_add(m_world, m_type, t.id());
        m_normalized = ecs_type_merge(m_world, m_normalized, t.c_ptr(), nullptr);
        sync_from_me();
        return *this;
    }

    type& add(const entity& e) {
        m_type = ecs_type_add(m_world, m_type, e.id());
        m_normalized = ecs_type_add(m_world, m_normalized, e.id());
        sync_from_me();
        return *this;
    }

    type& add_instanceof(const entity& e) {
        m_type = ecs_type_add(m_world, m_type, e.id() | ECS_INSTANCEOF);
        m_normalized = ecs_type_add(m_world, m_normalized, e.id() | ECS_INSTANCEOF);
        sync_from_me();
        return *this;
    }

    type& add_childof(const entity& e) {
        m_type = ecs_type_add(m_world, m_type, e.id() | ECS_CHILDOF);
        m_normalized = ecs_type_add(m_world, m_normalized, e.id() | ECS_CHILDOF);
        sync_from_me();
        return *this;
    }

    template <typename ... Components>
    type& add() {
        std::stringstream str;
        if (!pack_args_to_string<Components...>(str)) {
            ecs_abort(ECS_INVALID_PARAMETER, NULL);
        }

        std::string expr = str.str();
        ecs_type_t t = ecs_type_from_str(m_world, expr.c_str());
        m_type = ecs_type_merge(m_world, m_type, t, nullptr);
        m_normalized = ecs_type_merge(m_world, m_normalized, t, nullptr);
        sync_from_me();

        return *this;
    }    

    std::string str() const {
        char *str = ecs_type_str(m_world, m_type);
        std::string result(str);
        ecs_os_free(str);
        return result;
    }

    type_t c_ptr() const {
        return m_type;
    }

    type_t c_normalized() const {
        return m_normalized;
    }

    void enable() {
        ecs_enable(m_world, m_id, true);
    }

    void disable() {
        ecs_enable(m_world, m_id, false);
    }

private:
    void sync_from_me() {
        EcsType *tc = ecs_get_mut(m_world, m_id, EcsType, NULL);
        if (tc) {
            tc->type = m_type;
            tc->normalized = m_normalized;
        }
    }

    void sync_from_flecs() {
        EcsType *tc = ecs_get_mut(m_world, m_id, EcsType, NULL);
        if (tc) {
            m_type = tc->type;
            m_normalized = tc->normalized;
        }
    }    

    type_t m_type;
    type_t m_normalized;
};


////////////////////////////////////////////////////////////////////////////////
//// Register component, provide global access to component handles / metadata
////////////////////////////////////////////////////////////////////////////////

template <typename T>
class component_info final {
public:
    static void init(const world& world, entity_t entity) {
        s_entity = entity;
        s_type = ecs_type_from_entity(world.c_ptr(), entity);;
        s_name = ecs_get_fullpath(world.c_ptr(), entity);
    }

    static entity_t s_entity;
    static type_t s_type;
    static const char *s_name;
};

template <typename T> entity_t component_info<T>::s_entity( 0 );
template <typename T> type_t component_info<T>::s_type( nullptr );
template <typename T> const char* component_info<T>::s_name( nullptr );


////////////////////////////////////////////////////////////////////////////////
//// Register a component with flecs
////////////////////////////////////////////////////////////////////////////////

template <typename T>
void component_ctor(
    ecs_world_t *world,
    ecs_entity_t component,
    const ecs_entity_t *entity_ptr,
    void *ptr,
    size_t size,
    int32_t count,
    void *ctx)
{
    ecs_assert(size == sizeof(T), ECS_INTERNAL_ERROR, NULL);
    T *t_ptr = static_cast<T*>(ptr);
    
    for (int i = 0; i < count; i ++) {
        new(&t_ptr[i]) T;
    }
} 

template <typename T>
void component_dtor(
    ecs_world_t *world,
    ecs_entity_t component,
    const ecs_entity_t *entity_ptr,
    void *ptr,
    size_t size,
    int32_t count,
    void *ctx)
{
    ecs_assert(size == sizeof(T), ECS_INTERNAL_ERROR, NULL);
    T *t_ptr = static_cast<T*>(ptr);
    
    for (int i = 0; i < count; i ++) {
        t_ptr[i].~T();
    }
}

template <typename T>
void component_copy(
    ecs_world_t *world,
    ecs_entity_t component,    
    const ecs_entity_t *dst_entity,
    const ecs_entity_t *src_entity,
    void *dst_ptr,
    const void *src_ptr,
    size_t size,
    int32_t count,
    void *ctx)
{
    ecs_assert(size == sizeof(T), ECS_INTERNAL_ERROR, NULL);
    T *t_dst_ptr = static_cast<T*>(dst_ptr);
    const T *t_src_ptr = static_cast<const T*>(src_ptr);
    
    for (int i = 0; i < count; i ++) {
        t_dst_ptr[i] = t_src_ptr[i];
    }
}

template <typename T>
void component_move(
    ecs_world_t *world,
    ecs_entity_t component,    
    const ecs_entity_t *dst_entity,
    const ecs_entity_t *src_entity,
    void *dst_ptr,
    void *src_ptr,
    size_t size,
    int32_t count,
    void *ctx)
{
    ecs_assert(size == sizeof(T), ECS_INTERNAL_ERROR, NULL);
    T *t_dst_ptr = static_cast<T*>(dst_ptr);
    T *t_src_ptr = static_cast<T*>(src_ptr);
    
    for (int i = 0; i < count; i ++) {
        t_dst_ptr[i] = std::move(t_src_ptr[i]);
    }
}

template <typename T>
class pod_component : public entity {
public:
    pod_component(const flecs::world& world, const char *name) : entity(world, name) {
        ecs_new_component(world.c_ptr(), this->m_id, nullptr, sizeof(T), alignof(T));
        component_info<T>::init(world, this->m_id);
        component_info<const T>::init(world, this->m_id);
        component_info<T*>::init(world, this->m_id);
        component_info<T&>::init(world, this->m_id); 
    }
};

template <typename T>
class component : public pod_component<T> {
public:
    component(const flecs::world& world, const char *name) 
        : pod_component<T>(world, name) 
    { 
        EcsComponentLifecycle cl{};
        cl.ctor = component_ctor<T>;
        cl.dtor = component_dtor<T>;
        cl.copy = component_copy<T>;
        cl.move = component_move<T>;
        
        ecs_set_component_actions_w_entity(
            world.c_ptr(), 
            component_info<T>::s_entity, 
            &cl);
    }
};


////////////////////////////////////////////////////////////////////////////////
//// Define a module
////////////////////////////////////////////////////////////////////////////////

template <typename T>
class module final : public pod_component<T> {
public:
    module(flecs::world& world, const char *name) : pod_component<T>(world, name) { 
        ecs_set_scope(this->m_world, this->m_id);
    }
};


////////////////////////////////////////////////////////////////////////////////
//// Import a module
////////////////////////////////////////////////////////////////////////////////

template <typename T>
void import(world& world) {
    if (!component_info<T>::s_name) {
        ecs_entity_t scope = ecs_get_scope(world.c_ptr());

        // Allocate module, so the this ptr will remain stable
        T *module_data = new T(world);

        ecs_set_scope(world.c_ptr(), scope);

        flecs::entity m = world.lookup(component_info<T>::s_name);

        m.set<T>(*module_data);
    }
}


////////////////////////////////////////////////////////////////////////////////
//// A filter is used to match subsets of tables
////////////////////////////////////////////////////////////////////////////////
 
class filter {
public:
    filter() 
        : m_world( nullptr )
        , m_filter{ } {}

    explicit filter(const world& world) 
        : m_world( world.c_ptr() )
        , m_filter{ } { }

    filter& include(type type) {
        m_filter.include = ecs_type_merge(m_world, m_filter.include, type.c_ptr(), nullptr);
        return *this;
    }

    filter& include(entity entity) {
        m_filter.include = ecs_type_add(m_world, m_filter.include, entity.id());
        return *this;
    }

    template <typename T>
    filter& include() {
        m_filter.include = ecs_type_add(m_world, m_filter.include, component_info<T>::s_entity);
        return *this;
    }

    filter& include_kind(match_kind kind) {
        m_filter.include_kind = static_cast<ecs_match_kind_t>(kind);
        return *this;
    }

    type include() {
        return type(m_world, m_filter.include);
    }

    filter& exclude(type type) {
        m_filter.exclude = ecs_type_merge(m_world, m_filter.exclude, type.c_ptr(), nullptr);
        return *this;
    }

    filter& exclude(entity entity) {
        m_filter.exclude = ecs_type_add(m_world, m_filter.exclude, entity.id());
        return *this;
    }

    template <typename T>
    filter& exclude() {
        m_filter.exclude = ecs_type_add(m_world, m_filter.exclude, component_info<T>::s_entity);
        return *this;
    }
 
    filter& exclude_kind(match_kind kind) {
        m_filter.exclude_kind = static_cast<ecs_match_kind_t>(kind);
        return *this;
    }

    type exclude() {
        return type(m_world, m_filter.exclude);
    }  

    const filter_t* c_ptr() const {
        if (m_world) {
            return &m_filter;
        } else {
            return nullptr;
        }
    }

private:
    world_t *m_world;
    filter_t m_filter;
};


////////////////////////////////////////////////////////////////////////////////
//// Utility to convert template argument pack to array of columns
////////////////////////////////////////////////////////////////////////////////

template <typename ... Components>
class column_args {
public:    
    struct Column {
        void *ptr;
        bool is_shared;
    };

    using Columns = std::array<Column, sizeof...(Components)>;

    column_args(ecs_iter_t* iter) {
        populate_columns(iter, 0, (typename std::remove_reference<typename std::remove_pointer<Components>::type>::type*)nullptr...);
    }

    Columns m_columns;

private:
    /* Dummy function when last component has been added */
    void populate_columns(ecs_iter_t *iter, int index) { 
        (void)iter;
        (void)index;
    }

    /* Populate columns array recursively */
    template <typename T, typename... Targs>
    void populate_columns(ecs_iter_t *iter, int index, T comp, Targs... comps) {
        void *ptr = ecs_column_w_size(iter, sizeof(*comp), index + 1);
        m_columns[index].ptr = ptr;
        m_columns[index].is_shared = !ecs_is_owned(iter, index + 1) && ptr != nullptr;
        populate_columns(iter, index + 1, comps ...);
    }
};

////////////////////////////////////////////////////////////////////////////////
//// Utility class to invoke a system each
////////////////////////////////////////////////////////////////////////////////

template <typename Func, typename ... Components>
class each_invoker {
    using Columns = typename column_args<Components ...>::Columns;

public:
    explicit each_invoker(Func func) : m_func(func) { }

    // Invoke system
    template <typename... Targs,
        typename std::enable_if<sizeof...(Targs) == sizeof...(Components), void>::type* = nullptr>
    static void call_system(ecs_iter_t *iter, Func func, int index, Columns& columns, Targs... comps) {
        flecs::iter iter_wrapper(iter);
        (void)index;
        (void)columns;

        // Use any_column so we can transparently use shared components
        for (auto row : iter_wrapper) {
            func(iter_wrapper.entity(row), (any_column<typename std::remove_reference<Components>::type>(
                 (typename std::remove_reference< typename std::remove_pointer<Components>::type >::type*)comps.ptr, iter->count, comps.is_shared))[row]...);
        }
    }

    // Add components one by one to parameter pack
    template <typename... Targs,
        typename std::enable_if<sizeof...(Targs) != sizeof...(Components), void>::type* = nullptr>
    static void call_system(ecs_iter_t *iter, Func func, int index, Columns& columns, Targs... comps) {
        call_system(iter, func, index + 1, columns, comps..., columns[index]);
    }

    // Callback provided to flecs system
    static void run(ecs_iter_t *iter) {
        const Context *ctx = ecs_get(iter->world, iter->system, EcsContext);
        each_invoker *self = (each_invoker*)ctx->ctx;
        Func func = self->m_func;        
        column_args<Components...> columns(iter);
        call_system(iter, func, 0, columns.m_columns);
    }   

private:
    Func m_func;
};


////////////////////////////////////////////////////////////////////////////////
//// Utility class to invoke a system action
////////////////////////////////////////////////////////////////////////////////

template <typename Func, typename ... Components>
class action_invoker {
    using Columns = typename column_args<Components ...>::Columns;

public:
    explicit action_invoker(Func func) 
        : m_func(func) { }

    /* Invoke system */
    template <typename... Targs,
        typename std::enable_if<sizeof...(Targs) == sizeof...(Components), void>::type* = nullptr>
    static void call_system(ecs_iter_t *iter, Func func, int index, Columns& columns, Targs... comps) {
        (void)index;
        (void)columns;

        flecs::iter iter_wrapper(iter);
        
        func(iter_wrapper, (column<typename std::remove_reference< typename std::remove_pointer<Components>::type >::type>(
            (typename std::remove_reference< typename std::remove_pointer<Components>::type >::type*)comps.ptr, iter->count, comps.is_shared))...);
    }

    /** Add components one by one to parameter pack */
    template <typename... Targs,
        typename std::enable_if<sizeof...(Targs) != sizeof...(Components), void>::type* = nullptr>
    static void call_system(ecs_iter_t *iter, Func func, int index, Columns& columns, Targs... comps) {
        call_system(iter, func, index + 1, columns, comps..., columns[index]);
    }

    /** Callback provided to flecs */
    static void run(ecs_iter_t *iter) {
        const Context *ctx = ecs_get(iter->world, iter->system, EcsContext);
        action_invoker *self = (action_invoker*)ctx->ctx;        
        Func func = self->m_func; 
        column_args<Components...> columns(iter);
        call_system(iter, func, 0, columns.m_columns);
    }   

private:
    Func m_func;
};


////////////////////////////////////////////////////////////////////////////////
//// Persistent queries
////////////////////////////////////////////////////////////////////////////////

template<typename ... Components>
class query final {
    using Columns = typename column_args<Components...>::Columns;

public:
    query() : m_query(nullptr) { }

    explicit query(world& world) {
        std::stringstream str;
        if (!pack_args_to_string<Components...>(str, true)) {
            ecs_abort(ECS_INVALID_PARAMETER, NULL);
        }

        m_query = ecs_query_new(world.c_ptr(), str.str().c_str());
    }

    explicit query(world& world, const char *expr) {
        std::stringstream str;
        if (!pack_args_to_string<Components...>(str, true)) {
            m_query = ecs_query_new(world.c_ptr(), expr);
        } else {
            str << "," << expr;
            m_query = ecs_query_new(world.c_ptr(), str.str().c_str());
        }
    }

    query_iterator<Components...> begin() const;

    query_iterator<Components...> end() const;

    template <typename Func>
    void each(Func func) const {
        ecs_iter_t iter = ecs_query_iter(m_query);

        while (ecs_query_next(&iter)) {
            column_args<Components...> columns(&iter);
            each_invoker<Func, Components...> ctx(func);
            ctx.call_system(&iter, func, 0, columns.m_columns);
        }
    }

    template <typename Func>
    void action(Func func) const {
        ecs_iter_t iter = ecs_query_iter(m_query);

        while (ecs_query_next(&iter)) {
            column_args<Components...> columns(&iter);
            action_invoker<Func, Components...> ctx(func);
            ctx.call_system(&iter, func, 0, columns.m_columns);
        }
    }    

    query_t* c_ptr() const {
        return m_query;
    }

private:
    query_t *m_query;
};


////////////////////////////////////////////////////////////////////////////////
//// Snapshots make a copy of the world state that can be restored
////////////////////////////////////////////////////////////////////////////////

class snapshot final {
public:
    explicit snapshot(const world& world)
        : m_world( world )
        , m_snapshot( nullptr ) { }

    snapshot(const snapshot& obj) 
        : m_world( obj.m_world )
    { 
        ecs_iter_t it = ecs_snapshot_iter(obj.m_snapshot, nullptr);
        m_snapshot = ecs_snapshot_take_w_iter(&it, ecs_snapshot_next);
    }

    snapshot(snapshot&& obj) 
        : m_world(obj.m_world)
        , m_snapshot(obj.m_snapshot)
    {
        obj.m_snapshot = nullptr;
    }

    snapshot& operator=(const snapshot& obj) {
        ecs_assert(m_world.c_ptr() == obj.m_world.c_ptr(), ECS_INVALID_PARAMETER, NULL);
        ecs_iter_t it = ecs_snapshot_iter(obj.m_snapshot, nullptr);
        m_snapshot = ecs_snapshot_take_w_iter(&it, ecs_snapshot_next);        
        return *this;
    }

    snapshot& operator=(snapshot&& obj) {
        ecs_assert(m_world.c_ptr() == obj.m_world.c_ptr(), ECS_INVALID_PARAMETER, NULL);
        m_snapshot = obj.m_snapshot;
        obj.m_snapshot = nullptr;
        return *this;
    }

    void take() {
        if (m_snapshot) {
            ecs_snapshot_free(m_snapshot);
        }

        m_snapshot = ecs_snapshot_take(m_world.c_ptr());
    }

    void take(flecs::filter filter) {
        if (m_snapshot) {
            ecs_snapshot_free(m_snapshot);
        }

        ecs_iter_t it = ecs_filter_iter(m_world.c_ptr(), filter.c_ptr());
        m_snapshot = ecs_snapshot_take_w_iter(
            &it, ecs_filter_next);
    }

    void restore() {
        if (m_snapshot) {
            ecs_snapshot_restore(m_world.c_ptr(), m_snapshot);
            m_snapshot = nullptr;
        }
    }

    ~snapshot() {
        if (m_snapshot) {
            ecs_snapshot_free(m_snapshot);
        }
    }

    snapshot_t* c_ptr() const {
        return m_snapshot;
    }

    snapshot_filter filter(const filter& filter);

    filter_iterator begin();

    filter_iterator end();
private:
    const world& m_world;
    snapshot_t *m_snapshot;
};


////////////////////////////////////////////////////////////////////////////////
//// Fluent interface to run a system manually
////////////////////////////////////////////////////////////////////////////////

class system_runner_fluent {
public:
    system_runner_fluent(world_t *world, entity_t id, float delta_time, void *param)
        : m_world(world)
        , m_id(id)
        , m_delta_time(delta_time)
        , m_param(param)
        , m_filter()
        , m_offset(0)
        , m_limit(0) { }

    system_runner_fluent& filter(filter filter) {
        m_filter = filter;
        return *this;
    }

    system_runner_fluent& offset(std::int32_t offset) {
        m_offset = offset;
        return *this;
    }

    system_runner_fluent& limit(std::int32_t limit) {
        m_limit = limit;
        return *this;
    }

    ~system_runner_fluent() {
        ecs_run_w_filter(
            m_world, m_id, m_delta_time, m_offset, m_limit, m_filter.c_ptr(), m_param);
    }
private:
    world_t *m_world;
    entity_t m_id;
    float m_delta_time;
    void *m_param;
    flecs::filter m_filter;
    std::int32_t m_offset;
    std::int32_t m_limit;
};


////////////////////////////////////////////////////////////////////////////////
//// Register a system with Flecs
////////////////////////////////////////////////////////////////////////////////

template<typename ... Components>
class system final : public entity {
public:
    system(const flecs::world& world, const char *name = nullptr)
        : m_kind(static_cast<ecs_entity_t>(OnUpdate))
        , m_name(name) 
        , m_period(0.0)
        , m_on_demand(false)
        , m_hidden(false)
        , m_finalized(false) { 
            m_world = world.c_ptr();
        }

    system& signature(const char *signature) {
        ecs_assert(!m_finalized, ECS_INVALID_PARAMETER, NULL);
        m_signature = signature;
        return *this;
    }

    system& kind(entity_t kind) {
        ecs_assert(!m_finalized, ECS_INVALID_PARAMETER, NULL);
        m_kind = static_cast<ecs_entity_t>(kind);
        return *this;
    }

    system& period(float period) {
        ecs_assert(!m_finalized, ECS_INVALID_PARAMETER, NULL);
        m_period = period;
        return *this;
    }

    system& on_demand() {
        ecs_assert(!m_finalized, ECS_INVALID_PARAMETER, NULL);
        m_on_demand = true;
        return *this;
    }

    system& hidden() {
        ecs_assert(!m_finalized, ECS_INVALID_PARAMETER, NULL);
        m_hidden = true;
        return *this;
    }

    void enable() {
        ecs_enable(m_world, m_id, true);
    }

    void disable() {
        ecs_enable(m_world, m_id, false);
    }

    void set_period(float period) const {
        ecs_set_interval(m_world, m_id, period);
    }

    void set_context(void *ctx) const {
        EcsContext ctx_value = { ctx };
        ecs_set_ptr(m_world, m_id, EcsContext, &ctx_value);
    }

    void* get_context() const {
        const EcsContext *ctx = ecs_get(m_world, m_id, EcsContext);
        if (ctx) {
            return (void*)ctx->ctx;
        } else {
            return NULL;
        }
    }

    system_runner_fluent run(float delta_time = 0.0f, void *param = nullptr) const {
        return system_runner_fluent(m_world, m_id, delta_time, param);
    }

    /* Action (or each) is mandatory and always the last thing that is added in 
     * the fluent method chain. Create system signature from both template 
     * parameters and anything provided by the signature method. */
    template <typename Func>
    system& action(Func func) {
        ecs_assert(!m_finalized, ECS_INVALID_PARAMETER, NULL);
        auto ctx = new action_invoker<Func, Components...>(func);

        std::string signature = build_signature(false);

        entity_t e = ecs_new_system(
            m_world, 
            0,
            m_name, 
            m_kind, 
            signature.c_str(), 
            action_invoker<Func, Components...>::run);

        EcsContext ctx_value = {ctx};
        ecs_set_ptr(m_world, e, EcsContext, &ctx_value);

        if (m_period) {
            ecs_set_interval(m_world, e, m_period);
        }

        m_id = e;

        return *this;
    }

    /* Each is similar to action, but accepts a function that operates on a
     * single entity */
    template <typename Func>
    system& each(Func func) {
        auto ctx = new each_invoker<Func, Components...>(func);

        std::string signature = build_signature(true);

        if (!signature.length()) {
            signature = "0";
        }

        entity_t e = ecs_new_system(
            m_world, 
            0,
            m_name, 
            m_kind, 
            signature.c_str(), 
            each_invoker<Func, Components...>::run);

        EcsContext ctx_value = {ctx};
        ecs_set_ptr(m_world, e, EcsContext, &ctx_value);

        if (m_period) {
            ecs_set_interval(m_world, e, m_period);
        }        

        m_id = e;

        return *this;
    }

    ~system() = default;
private:
    std::string build_signature(bool is_each) {
        bool is_set = false;

        std::stringstream str;
        if (pack_args_to_string<Components ...>(str, is_each)) {
            is_set = true;
        }

        if (m_signature) {
            if (is_set) {
                str << ",";
            }
            str << m_signature;
            is_set = true;
        }

        if (m_hidden) {
            if (is_set) {
                str << ",";
            }            
            str << "SYSTEM:Hidden";
            is_set = true;
        }    

        if (m_on_demand) {
            if (is_set) {
                str << ",";
            }            
            str << "SYSTEM:EcsOnDemand";
            is_set = true;
        } 

        return str.str();       
    }       

    ecs_entity_t m_kind;
    const char *m_name;
    const char *m_signature = nullptr;
    float m_period;
    bool m_on_demand;
    bool m_hidden;
    bool m_finalized; // After set to true, call no more fluent functions
};


////////////////////////////////////////////////////////////////////////////////
//// Persistent queries
////////////////////////////////////////////////////////////////////////////////

template<typename ... Components>
class query_iterator
{
public:
    query_iterator()
        : m_has_next(false)
        , m_iter{ } { }

    query_iterator(const query<Components...>& query) 
        : m_iter( ecs_query_iter(query.c_ptr()) )
    {
        m_has_next = ecs_query_next(&m_iter);
    }

    bool operator!=(query_iterator const& other) const {
        return m_has_next != other.m_has_next;
    }

    flecs::iter const operator*() const {
        return flecs::iter(&m_iter);
    }

    query_iterator& operator++() {
        m_has_next = ecs_query_next(&m_iter);
        return *this;
    }

private:
    bool m_has_next;
    ecs_iter_t m_iter;
};


////////////////////////////////////////////////////////////////////////////////
//// Utility for iterating over tables that match a filter
////////////////////////////////////////////////////////////////////////////////

class filter_iterator
{
public:
    filter_iterator()
        : m_world(nullptr)
        , m_has_next(false)
        , m_iter{ } { }

    filter_iterator(const world& world, const filter& filter)
        : m_world( world.c_ptr() )
        , m_iter( ecs_filter_iter(m_world, filter.c_ptr()) ) 
    { 
        m_has_next = ecs_filter_next(&m_iter);
    }

    filter_iterator(const world& world, const snapshot& snapshot, const filter& filter) 
        : m_world( world.c_ptr() )
        , m_iter( ecs_snapshot_iter(snapshot.c_ptr(), filter.c_ptr()) )
    {
        m_has_next = ecs_filter_next(&m_iter);
    }

    bool operator!=(filter_iterator const& other) const {
        return m_has_next != other.m_has_next;
    }

    flecs::iter const operator*() const {
        return flecs::iter(&m_iter);
    }

    filter_iterator& operator++() {
        m_has_next = ecs_filter_next(&m_iter);
        return *this;
    }

private:
    world_t *m_world;
    bool m_has_next;
    ecs_iter_t m_iter;
};


////////////////////////////////////////////////////////////////////////////////
//// Tree iterator
////////////////////////////////////////////////////////////////////////////////

class tree_iterator
{
public:
    tree_iterator()
        : m_has_next(false)
        , m_iter{ } { }

    tree_iterator(flecs::entity entity) 
        : m_iter( ecs_scope_iter(entity.world().c_ptr(), entity.id()) )
    {
        m_has_next = ecs_scope_next(&m_iter);
    }

    bool operator!=(tree_iterator const& other) const {
        return m_has_next != other.m_has_next;
    }

    flecs::iter const operator*() const {
        return flecs::iter(&m_iter);
    }

    tree_iterator& operator++() {
        m_has_next = ecs_scope_next(&m_iter);
        return *this;
    }

private:
    bool m_has_next;
    ecs_iter_t m_iter;
};

////////////////////////////////////////////////////////////////////////////////
//// Utility for creating a world-based filter iterator
////////////////////////////////////////////////////////////////////////////////

class world_filter {
public:
    world_filter(const world& world, const filter& filter) 
        : m_world( world )
        , m_filter( filter ) { }

    inline filter_iterator begin() const {
        return filter_iterator(m_world, m_filter);
    }

    inline filter_iterator end() const {
        return filter_iterator();
    }

private:
    const world& m_world;
    const filter& m_filter;
};


////////////////////////////////////////////////////////////////////////////////
//// Utility for creating a snapshot-based filter iterator
////////////////////////////////////////////////////////////////////////////////

class snapshot_filter {
public:
    snapshot_filter(const world& world, const snapshot& snapshot, const filter& filter) 
        : m_world( world )
        , m_snapshot( snapshot )
        , m_filter( filter ) { }

    inline filter_iterator begin() const {
        return filter_iterator(m_world, m_snapshot, m_filter);
    }

    inline filter_iterator end() const {
        return filter_iterator();
    }

private:
    const world& m_world;
    const snapshot& m_snapshot;
    const filter& m_filter;
};


////////////////////////////////////////////////////////////////////////////////
//// Utility for creating a child table iterator
////////////////////////////////////////////////////////////////////////////////

class child_iterator {
public:
    child_iterator(const entity& entity) 
        : m_parent( entity ) { }

    inline tree_iterator begin() const {
        return tree_iterator(m_parent);
    }

    inline tree_iterator end() const {
        return tree_iterator();
    }

private:
    const entity& m_parent;
};


////////////////////////////////////////////////////////////////////////////////
//// Reader for world/snapshot serialization
////////////////////////////////////////////////////////////////////////////////

class reader final {
public:
    reader(world& world) {
        m_reader = ecs_reader_init(world.c_ptr());
    }

    reader(world& world, snapshot& snapshot) {
        (void)world;
        ecs_iter_t it = ecs_snapshot_iter(snapshot.c_ptr(), nullptr);
        m_reader = ecs_reader_init_w_iter(&it, ecs_snapshot_next);
    }

    std::size_t read(char *buffer, std::size_t size) {
        return ecs_reader_read(buffer, size, &m_reader);
    }

private:
    ecs_reader_t m_reader;
};


////////////////////////////////////////////////////////////////////////////////
//// Writer for world deserialization
////////////////////////////////////////////////////////////////////////////////

class writer final {
public:
    writer(world& world) {
        m_writer = ecs_writer_init(world.c_ptr());
    }

    int write(const char *buffer, std::size_t size) {
        return ecs_writer_write(buffer, size, &m_writer);
    }

private:
    ecs_writer_t m_writer;
};


////////////////////////////////////////////////////////////////////////////////
//// Filter fwd declared functions
////////////////////////////////////////////////////////////////////////////////

inline snapshot_filter snapshot::filter(const flecs::filter& filter) {
    return snapshot_filter(m_world, *this, filter);
}

inline filter_iterator snapshot::begin() {
    return filter_iterator(m_world, *this, flecs::filter(m_world));
}

inline filter_iterator snapshot::end() {
    return filter_iterator();
}


////////////////////////////////////////////////////////////////////////////////
//// Query fwd declared functions
////////////////////////////////////////////////////////////////////////////////

template<typename ... Components>
inline query_iterator<Components...> query<Components...>::begin() const {
    return query_iterator<Components...>(*this);
}

template<typename ... Components>
inline query_iterator<Components...> query<Components...>::end() const {
    return query_iterator<Components...>();
}


////////////////////////////////////////////////////////////////////////////////
//// Cached ptr fwd declared functions
////////////////////////////////////////////////////////////////////////////////

template <typename T>
flecs::entity ref<T>::entity() const {
    return flecs::entity(m_world, m_entity);
}


////////////////////////////////////////////////////////////////////////////////
//// Entity fwd declared functions
////////////////////////////////////////////////////////////////////////////////

inline flecs::type entity::type() const {
    return flecs::type(m_world, ecs_get_type(m_world, m_id));
}

inline flecs::type entity::to_type() const {
    ecs_type_t type = ecs_type_from_entity(m_world, m_id);
    return flecs::type(m_world, type);
}

inline child_iterator entity::children() const {
    return flecs::child_iterator(*this);
}

////////////////////////////////////////////////////////////////////////////////
//// Entity fluent fwd declared functions
////////////////////////////////////////////////////////////////////////////////

template <typename base>
inline typename entity_fluent<base>::base_type& entity_fluent<base>::add(const entity& entity) const {
    return add(entity.id());
}

template <typename base>
inline typename entity_fluent<base>::base_type& entity_fluent<base>::add(type type) const {
    return add(type.c_ptr());
}

template <typename base>
inline typename entity_fluent<base>::base_type& entity_fluent<base>::remove(const entity& entity) const {
    return remove(entity.id());
}

template <typename base>
inline typename entity_fluent<base>::base_type& entity_fluent<base>::remove(type type) const {
    return remove(type.c_ptr());
}

template <typename base>
inline typename entity_fluent<base>::base_type& entity_fluent<base>::add_childof(const entity& entity) const {
    return add_childof(entity.id());
}

template <typename base>
inline typename entity_fluent<base>::base_type& entity_fluent<base>::remove_childof(const entity& entity) const {
    return remove_childof(entity.id());
}

template <typename base>
inline typename entity_fluent<base>::base_type& entity_fluent<base>::add_instanceof(const entity& entity) const {
    return add_instanceof(entity.id());
}

template <typename base>
inline typename entity_fluent<base>::base_type& entity_fluent<base>::remove_instanceof(const entity& entity) const {
    return remove_instanceof(entity.id());
}

inline entity world::lookup(const char *name) const {
    auto id = ecs_lookup_path_w_sep(m_world, 0, name, "::", "::");
    return entity(*this, id);
}

inline entity world::lookup(std::string& name) const {
    auto id = ecs_lookup_path_w_sep(m_world, 0, name.c_str(), "::", "::");
    return entity(*this, id);
}


////////////////////////////////////////////////////////////////////////////////
//// Iter fwd declared functions
////////////////////////////////////////////////////////////////////////////////

inline flecs::entity iter::system() const {
    return flecs::entity(m_iter->world, m_iter->system);
}

inline flecs::world iter::world() const {
    return flecs::world(m_iter->world);
}

inline flecs::entity iter::entity(int32_t row) const {
    ecs_assert(row < m_iter->count, ECS_COLUMN_INDEX_OUT_OF_RANGE, NULL);
    return flecs::entity(m_iter->world, m_iter->entities[row]);
}

/* Obtain column source (0 if self) */
inline flecs::entity iter::column_source(int32_t col) const {
    return flecs::entity(m_iter->world, ecs_column_source(m_iter, col));
}

/* Obtain component/tag entity of column */
inline flecs::entity iter::column_entity(int32_t col) const {
    return flecs::entity(m_iter->world, ecs_column_entity(m_iter, col));
}

/* Obtain type of column */
inline type iter::column_type(int32_t col) const {
    return flecs::type(m_iter->world, ecs_column_type(m_iter, col));
}

/* Obtain type of table being iterated over */
inline type iter::table_type() const {
    return flecs::type(m_iter->world, ecs_iter_type(m_iter));
}


////////////////////////////////////////////////////////////////////////////////
//// World fwd declared functions
////////////////////////////////////////////////////////////////////////////////

inline void world::delete_entities(flecs::filter filter) const {
    ecs_bulk_delete(m_world, filter.c_ptr());
}

template <typename T>
inline void world::add() const {
    ecs_bulk_add_remove_type(m_world, component_info<T>::s_type, nullptr, nullptr);
}

template <typename T>
inline void world::add(flecs::filter filter) const {
    ecs_bulk_add_remove_type(m_world, component_info<T>::s_type, nullptr, filter.c_ptr());
}

inline void world::add(type type) const {
    ecs_bulk_add_remove_type(m_world, type.c_ptr(), nullptr, nullptr);
}

inline void world::add(type type, flecs::filter filter) const {
    ecs_bulk_add_remove_type(m_world, type.c_ptr(), nullptr, filter.c_ptr());
}

inline void world::add(entity entity) const {
    ecs_bulk_add_remove_type(m_world, entity.to_type().c_ptr(), nullptr, nullptr);
}

inline void world::add(entity entity, flecs::filter filter) const {
    ecs_bulk_add_remove_type(m_world, entity.to_type().c_ptr(), nullptr, filter.c_ptr());
}

template <typename T>
inline void world::remove() const {
    ecs_bulk_add_remove_type(m_world, nullptr, component_info<T>::s_type, nullptr);
}

template <typename T>
inline void world::remove(flecs::filter filter) const {
    ecs_bulk_add_remove_type(m_world, nullptr, component_info<T>::s_type, filter.c_ptr());
}

inline void world::remove(type type) const {
    ecs_bulk_add_remove_type(m_world, nullptr, type.c_ptr(), nullptr);
}

inline void world::remove(type type, flecs::filter filter) const {
    ecs_bulk_add_remove_type(m_world, nullptr, type.c_ptr(), filter.c_ptr());
}

inline void world::remove(entity entity) const {
    ecs_bulk_add_remove_type(m_world, nullptr, entity.to_type().c_ptr(), nullptr);
}

inline void world::remove(entity entity, flecs::filter filter) const {
    ecs_bulk_add_remove_type(m_world, nullptr, entity.to_type().c_ptr(), filter.c_ptr());
}

inline flecs::world_filter world::filter(const flecs::filter& filter) const {
    return flecs::world_filter(*this, filter);
}

inline filter_iterator world::begin() const {
    return filter_iterator(*this, flecs::filter(*this));
}

inline filter_iterator world::end() const {
    return filter_iterator();
}

inline int world::count(flecs::filter filter) const {
    return ecs_count_w_filter(m_world, filter.c_ptr());
}

inline void world::init_builtin_components() {
    pod_component<Component>(*this, "EcsComponent");
    pod_component<Type>(*this, "EcsType");
    pod_component<Name>(*this, "EcsName");
}

/** Utilities to convert type trait to flecs signature syntax */
template <typename T,
    typename std::enable_if< std::is_const<T>::value == true, void>::type* = nullptr>
constexpr const char *inout_modifier() {
    return "[in] ";
}

template <typename T,
    typename std::enable_if< std::is_reference<T>::value == true, void>::type* = nullptr>
constexpr const char *inout_modifier() {
    return "[out] ";
}

template <typename T,
    typename std::enable_if<std::is_const<T>::value == false && std::is_reference<T>::value == false, void>::type* = nullptr>
constexpr const char *inout_modifier() {
    return "";
}

template <typename T,
    typename std::enable_if< std::is_pointer<T>::value == true, void>::type* = nullptr>
constexpr const char *optional_modifier() {
    return "?";
}

template <typename T,
    typename std::enable_if< std::is_pointer<T>::value == false, void>::type* = nullptr>
constexpr const char *optional_modifier() {
    return "";
} 

/** Convert template arguments to string */
template <typename ...Components>
bool pack_args_to_string(std::stringstream& str, bool is_each) {
    std::array<const char*, sizeof...(Components)> ids = {
        component_info<Components>::s_name...
    };

    std::array<const char*, sizeof...(Components)> inout_modifiers = {
        inout_modifier<Components>()...
    }; 

    std::array<const char*, sizeof...(Components)> optional_modifiers = {
        optional_modifier<Components>()...
    };        

    int i = 0;
    for (auto id : ids) {
        if (i) {
            str << ",";
        }
        
        str << inout_modifiers[i];
        str << optional_modifiers[i];

        if (is_each) {
            str << "ANY:";
        }
        str << id;
        i ++;
    }  

    return i != 0;
}

}
#endif
#endif

#endif

#endif
