
#ifndef FLECS_H
#define FLECS_H

#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#ifndef __BAKE__
#include <stdint.h>
#endif

/* This file is generated by bake and contains macro's for 
 * importing/exporting symbols */
#include "flecs/bake_config.h"

/* The API uses the native bool type in C++, or a custom one in C */
#ifndef __cplusplus
#undef bool
#undef true
#undef false
typedef char bool;
#define false 0
#define true !false
#endif

#ifdef __cplusplus
#define ECS_ALIGNOF(T) alignof(T)
#else
#define ECS_ALIGNOF(T) ((size_t)&((struct { char c; T d; } *)0)->d)
#endif
#define ECS_MAX(a, b) ((a > b) ? a : b)


#include "flecs/util/os_api.h"
#include "flecs/util/vector.h"
#include "flecs/util/ringbuf.h"
#include "flecs/util/sparse.h"
#include "flecs/util/map.h"
#include "flecs/util/strbuf.h"
#include "flecs/util/os_api.h"

#ifdef __cplusplus
extern "C" {
#endif


////////////////////////////////////////////////////////////////////////////////
//// Opaque types
////////////////////////////////////////////////////////////////////////////////

typedef struct ecs_world_t ecs_world_t;
typedef struct ecs_query_t ecs_query_t;
typedef struct ecs_stage_t ecs_stage_t;
typedef struct ecs_record_t ecs_record_t;
typedef struct ecs_table_t ecs_table_t;
typedef struct ecs_iter_t ecs_iter_t;
typedef struct ecs_reference_t ecs_reference_t;
typedef struct ecs_snapshot_t ecs_snapshot_t;


////////////////////////////////////////////////////////////////////////////////
//// Public types
////////////////////////////////////////////////////////////////////////////////

/* An entity identifier. */
typedef uint64_t ecs_entity_t;

/* A vector containing component identifiers used to describe an entity type. */
typedef const ecs_vector_t* ecs_type_t;

/* Array of entity ids that, other than a type, can live on the stack */
typedef struct ecs_entities_t {
    ecs_entity_t *array;
    int32_t count;
} ecs_entities_t;

/** Action callback for systems and triggers */
typedef void (*ecs_iter_action_t)(
    ecs_iter_t *data);

/** Compare callback used for sorting */
typedef int (*ecs_compare_action_t)(
    ecs_entity_t e1,
    void *ptr1,
    ecs_entity_t e2,
    void *ptr2);    

/** Compare callback used for sorting */
typedef int32_t (*ecs_rank_type_action_t)(
    ecs_world_t *world,
    ecs_entity_t rank_component,
    ecs_type_t type);

/** Initialization action for modules */
typedef void (*ecs_module_action_t)(
    ecs_world_t *world,
    int flags);    

/** Action callback on world exit */
typedef void (*ecs_fini_action_t)(
    ecs_world_t *world,
    void *ctx);

/** Types that describe a type filter.
 * Filters provide a quick mechanism to query entities or run operations on
 * entities of one or more types. Filters contain a components to include and
 * components to exclude. Additionally, a filter can specify whether all or any
 * of the components need to be matched, or whether it must be an exact match.
 *
 * When a filter contains only one component, Any and All are equivalent.
 *
 * Suppose an application has entities with the following types:
 * 1. [Position]
 * 2. [Position, Velocity]
 * 3. [Position, Velocity, Mass]
 *
 * And the following filters
 * A. include = [Position], All/Any
 * B. include = [Position], Exact
 * C. include = [Position, Velocity], All
 * D. include = [Position, Velocity], Any
 * E. exclude = [Position], All/Any
 * F. exclude = [Position, Velocity], Exact
 * G. include = [Position, Velocity], Exact
 *
 * Then these types would be matched like this:
 *     1   2   3
 * ---|---|---|---
 *  A | x | x | x
 *  B | x |   | 
 *  C |   | x | x
 *  D | x | x | x 
 *  E |   |   | 
 *  F | x |   | x 
 *  G |   | x | 
 *
 * When the kind is left to EcsMatchDefault, the include_kind will be set to
 * EcsMatchAll, while the exclude_kind will be set to EcsMatchAny.
 */
typedef enum ecs_match_kind_t {
    EcsMatchDefault = 0,
    EcsMatchAll,
    EcsMatchAny,
    EcsMatchExact
} ecs_match_kind_t;

typedef struct ecs_filter_t {
    ecs_type_t include;
    ecs_type_t exclude;
    ecs_match_kind_t include_kind;
    ecs_match_kind_t exclude_kind;
} ecs_filter_t;

typedef struct ecs_ref_t {
    void *table;            /* Last known table */
    int32_t row;            /* Last known location in table */
    int32_t size;           /* Last known size of table (data reallocd?) */
    ecs_stage_t *stage;     /* Last known stage */
    ecs_record_t *record;   /* Pointer to record, if in main stage */
    const void *ptr;        /* Cached ptr */
} ecs_ref_t;

/* Constructor/destructor. Used for initializing / deinitializing components */
typedef void (*ecs_xtor_t)(
    ecs_world_t *world,
    ecs_entity_t component,
    const ecs_entity_t *entity_ptr,
    void *ptr,
    size_t size,
    int32_t count,
    void *ctx);

/* Copy is invoked when a component is copied into another component */
typedef void (*ecs_copy_t)(
    ecs_world_t *world,
    ecs_entity_t component,    
    const ecs_entity_t *dst_entity,
    const ecs_entity_t *src_entity,
    void *dst_ptr,
    const void *src_ptr,
    size_t size,
    int32_t count,
    void *ctx);

/* Move is invoked when a component is moved to another component */
typedef void (*ecs_move_t)(
    ecs_world_t *world,
    ecs_entity_t component,
    const ecs_entity_t *dst_entity,
    const ecs_entity_t *src_entity,
    void *dst_ptr,
    void *src_ptr,
    size_t size,
    int32_t count,
    void *ctx);


/* Macro's to improve component lifecycle ergonomics */

/* Map from typename to function name of component lifecycle action */
#define ecs_ctor(type) type##_ctor
#define ecs_dtor(type) type##_dtor
#define ecs_copy(type) type##_copy
#define ecs_move(type) type##_move

/* Constructor / destructor */
#define ECS_XTOR(type, postfix, var, ...)\
    void type##_##postfix(\
        ecs_world_t *world,\
        ecs_entity_t component,\
        const ecs_entity_t *entity_ptr,\
        void *_ptr,\
        size_t size,\
        int32_t count,\
        void *ctx)\
    {\
        for (int32_t i = 0; i < count; i ++) {\
            ecs_entity_t entity = entity_ptr[i];\
            type *var = &((type*)_ptr)[i];\
            (void)entity;\
            (void)var;\
            __VA_ARGS__\
        }\
    }

#define ECS_CTOR(type, var, ...) ECS_XTOR(type, ctor, var, __VA_ARGS__)
#define ECS_DTOR(type, var, ...) ECS_XTOR(type, dtor, var, __VA_ARGS__)

/* Copy */
#define ECS_COPY(type, dst_var, src_var, ...)\
    void type##_##copy(\
        ecs_world_t *world,\
        ecs_entity_t component,    \
        const ecs_entity_t *dst_entities,\
        const ecs_entity_t *src_entities,\
        void *_dst_ptr,\
        const void *_src_ptr,\
        size_t size,\
        int32_t count,\
        void *ctx)\
    {\
        for (int32_t i = 0; i < count; i ++) {\
            ecs_entity_t dst_entity = dst_entities[i];\
            ecs_entity_t src_entity = src_entities[i];\
            type *dst_var = &((type*)_dst_ptr)[i];\
            type *src_var = &((type*)_src_ptr)[i];\
            (void)dst_entity;\
            (void)src_entity;\
            (void)dst_var;\
            (void)src_var;\
            __VA_ARGS__\
        }\
    }

/* Move */
#define ECS_MOVE(type, dst_var, src_var, ...)\
    void type##_##move(\
        ecs_world_t *world,\
        ecs_entity_t component,    \
        const ecs_entity_t *dst_entities,\
        const ecs_entity_t *src_entities,\
        void *_dst_ptr,\
        void *_src_ptr,\
        size_t size,\
        int32_t count,\
        void *ctx)\
    {\
        for (int32_t i = 0; i < count; i ++) {\
            ecs_entity_t dst_entity = dst_entities[i];\
            ecs_entity_t src_entity = src_entities[i];\
            type *dst_var = &((type*)_dst_ptr)[i];\
            type *src_var = &((type*)_src_ptr)[i];\
            (void)dst_entity;\
            (void)src_entity;\
            (void)dst_var;\
            (void)src_var;\
            __VA_ARGS__\
        }\
    }

typedef struct ecs_scope_iter_t {
    ecs_vector_t *tables;
    int32_t index;
} ecs_scope_iter_t;

typedef struct ecs_filter_iter_t {
    ecs_filter_t filter;
    ecs_sparse_t *tables;
    int32_t index;
} ecs_filter_iter_t;

typedef struct ecs_query_iter_t {
    ecs_query_t *query;
    int32_t offset;
    int32_t limit;
    int32_t remaining;
    int32_t index;
} ecs_query_iter_t;    

/** The ecs_iter_t struct passes data from a system to a system callback.  */
struct ecs_iter_t {
    ecs_world_t *world;          /* Current world */
    ecs_entity_t system;         /* Handle to current system */

    int32_t *columns;    /* Indices mapping system params to columns and refs */
    int32_t table_count;        /* Number of tables matched with system */
    int32_t inactive_table_count; /* Number of inactive tables matched with system */
    uint16_t column_count;       /* Number of columns for system */
    void *table;                 /* Opaque structure with reference to table */
    void *table_columns;         /* Opaque structure with table column data */
    ecs_query_t *query;          /* Query being evaluated */
    ecs_reference_t *references; /* References to other entities */
    ecs_entity_t *components;    /* System-table specific list of components */
    ecs_entity_t *entities;      /* Entity row */

    void *param;                 /* Userdata passed to on-demand system */
    float delta_time;            /* Time elapsed since last frame */
    float delta_system_time;     /* Time elapsed since last system invocation */
    float world_time;            /* Time elapsed since start of simulation */
    int32_t frame_offset;       /* Offset relative to frame */
    int32_t table_offset;       /* Current active table being processed */
    int32_t offset;             /* Offset relative to current table */
    int32_t count;              /* Number of entities to process by system */
    int32_t total_count;        /* Total number of entities in table */

    ecs_entities_t *triggered_by; /* Component(s) that triggered the system */
    ecs_entity_t interrupted_by; /* When set, system execution is interrupted */

    union {
        ecs_scope_iter_t parent;
        ecs_filter_iter_t filter;
        ecs_query_iter_t query;
    } iter;
};

/* World info */
typedef struct ecs_world_info_t {
    /* Ids */
    ecs_entity_t last_component_id;   /* Last issued component entity id */
    ecs_entity_t last_id;             /* Last issued entity id */
    ecs_entity_t min_id;              /* First allowed entity id */
    ecs_entity_t max_id;              /* Last allowed entity id */

    /* Timing stats */
    float delta_time;           /* Time passed to or computed by ecs_progress */
    float target_fps;           /* Target fps */
    double frame_time_total;    /* Total time spent processing a frame */
    double system_time_total;   /* Total time spent in systems */
    double merge_time_total;    /* Total time spent in merges */
    double world_time_total;    /* Time elapsed since first frame */
    
    /* Counters */
    int32_t frame_count_total;  /* Total number of frames */
    int32_t merge_count_total;  /* Total number of merges */
    int32_t pipeline_build_count_total; /* Total number of pipeline builds */
    int32_t systems_ran_frame;  /* Total number of systems ran in last frame */
} ecs_world_info_t;


////////////////////////////////////////////////////////////////////////////////
//// Public builtin components
////////////////////////////////////////////////////////////////////////////////

typedef struct EcsName {
    const char *value;      /* Entity name */
    const char *symbol;     /* Optional symbol name, if it differs from name */
    char *alloc_value;      /* If set, value will be freed on destruction */
} EcsName;

/** Component that contains the size of a component */
typedef struct EcsComponent {
    size_t size;
    size_t alignment;
} EcsComponent;

/** Metadata of an explicitly created type (ECS_TYPE or ecs_new_type) */
typedef struct EcsType {
    ecs_type_t type;        /* Preserved nested types */
    ecs_type_t normalized;  /* Resolved nested types */
} EcsType;

/* Component that contains lifecycle callbacks for a component */
typedef struct EcsComponentLifecycle {
    ecs_xtor_t ctor;
    ecs_xtor_t dtor;
    ecs_copy_t copy;
    ecs_move_t move;
    void *ctx;
} EcsComponentLifecycle;

#include "flecs/util/api_support.h"


////////////////////////////////////////////////////////////////////////////////
//// Public constants
////////////////////////////////////////////////////////////////////////////////

/** Translate C type to type variable */
#define ecs_type(type) FLECS__T##type

/** Translate C type to entity variable */
#define ecs_entity(type) FLECS__E##type

/** Translate C type to module struct */
#define ecs_module(type) FLECS__M##type

/** Translate C type to module struct */
#define ecs_module_ptr(type) FLECS__M##type##_ptr

/** Translate C type to module struct */
#define ecs_iter_action(type) FLECS__F##type

/* Type flags are used to indicate the role of an entity in a type. No flag  
 * means a regular component / tag. */
#define ECS_INSTANCEOF ((ecs_entity_t)1 << 63)/* Share components with entity */
#define ECS_CHILDOF ((ecs_entity_t)1 << 62)   /* Entity is a parent */

/* The following type flags operate on a type entity, and add constraints to
 * what a type can and can't have. In this example 'Movable' MUST have either
 * Velocity or Speed, or creation of the type will fail.
 *
 * ECS_TYPE(world, SpeedType, Velocity, Speed);
 * ECS_TYPE(world, Movable, Position, XOR | SpeedType, Velocity);
 */
#define ECS_AND ((ecs_entity_t)1 << 61) /* All entities of type must be present */
#define ECS_OR ((ecs_entity_t)1 << 60)  /* At least one entity of type must be present */
#define ECS_XOR ((ecs_entity_t)1 << 59) /* Exactly one entity of type must be present */
#define ECS_NOT ((ecs_entity_t)1 << 58) /* None of the entities in the type can be added */

/** This allows passing 0 as type to functions that accept types */
#define FLECS__TNULL 0
#define FLECS__T0 0


////////////////////////////////////////////////////////////////////////////////
//// Global type handles
////////////////////////////////////////////////////////////////////////////////

/** Type handles to builtin components */
FLECS_EXPORT
extern ecs_type_t 
    ecs_type(EcsComponent),
    ecs_type(EcsComponentLifecycle),
    ecs_type(EcsType),
    ecs_type(EcsName);


////////////////////////////////////////////////////////////////////////////////
//// Reserved component & tag ids
////////////////////////////////////////////////////////////////////////////////

/** Builtin component ids */
#define FLECS__EEcsComponent (1)
#define FLECS__EEcsComponentLifecycle (2)
#define FLECS__EEcsType (3)
#define FLECS__EEcsName (6)

/** System module component ids */
#define FLECS__EEcsTrigger (4)
#define FLECS__EEcsSystem (5)
#define FLECS__EEcsTickSource (7)
#define FLECS__EEcsSignatureExpr (8)
#define FLECS__EEcsSignature (9)
#define FLECS__EEcsQuery (10)
#define FLECS__EEcsIterAction (11)
#define FLECS__EEcsContext (12)

/** Pipeline module component ids */
#define FLECS__EEcsPipelineQuery (13)

/** Timer module component ids */
#define FLECS__EEcsTimer (14)
#define FLECS__EEcsRateFilter (15)

/* Builtin tag ids */
#define EcsModule (ECS_HI_COMPONENT_ID + 0)
#define EcsPrefab (ECS_HI_COMPONENT_ID + 1)
#define EcsHidden (ECS_HI_COMPONENT_ID + 2)
#define EcsDisabled (ECS_HI_COMPONENT_ID + 3)
#define EcsDisabledIntern (ECS_HI_COMPONENT_ID + 4)
#define EcsInactive (ECS_HI_COMPONENT_ID + 5)
#define EcsOnDemand (ECS_HI_COMPONENT_ID + 6)
#define EcsMonitor (ECS_HI_COMPONENT_ID + 7)
#define EcsPipeline (ECS_HI_COMPONENT_ID + 8)

/* Trigger tags */
#define EcsOnAdd (ECS_HI_COMPONENT_ID + 9)
#define EcsOnRemove (ECS_HI_COMPONENT_ID + 10)
#define EcsOnSet (ECS_HI_COMPONENT_ID + 11)

/* Builtin pipeline tags */
#define EcsPreFrame (ECS_HI_COMPONENT_ID + 13)
#define EcsOnLoad (ECS_HI_COMPONENT_ID + 14)
#define EcsPostLoad (ECS_HI_COMPONENT_ID + 15)
#define EcsPreUpdate (ECS_HI_COMPONENT_ID + 16)
#define EcsOnUpdate (ECS_HI_COMPONENT_ID + 17)
#define EcsOnValidate (ECS_HI_COMPONENT_ID + 18)
#define EcsPostUpdate (ECS_HI_COMPONENT_ID + 19)
#define EcsPreStore (ECS_HI_COMPONENT_ID + 20)
#define EcsOnStore (ECS_HI_COMPONENT_ID + 21)
#define EcsPostFrame (ECS_HI_COMPONENT_ID + 22)

/** Builtin entity ids */
#define EcsFlecs (ECS_HI_COMPONENT_ID + 23)
#define EcsFlecsCore (ECS_HI_COMPONENT_ID + 24)
#define EcsWorld (ECS_HI_COMPONENT_ID + 25)
#define EcsSingleton ((ecs_entity_t)(ECS_ENTITY_MASK) - 1)

/* Value used to quickly check if component is builtin. This is used to quickly
 * filter out tables with builtin components (for example for ecs_delete) */
#define EcsLastInternalComponentId (ecs_entity(EcsSystem))

/* The first user-defined component starts from this id. Ids up to this number
 * are reserved for builtin components */
#define EcsFirstUserComponentId (32)

/* The first user-defined entity starts from this id. Ids up to this number
 * are reserved for builtin components */
#define EcsFirstUserEntityId (ECS_HI_COMPONENT_ID + 32)

////////////////////////////////////////////////////////////////////////////////
//// Declarative macro's
////////////////////////////////////////////////////////////////////////////////

#ifndef __BAKE_LEGACY__

/** Declare a named entity.
 * This macro will declare a new entity with the provided id and components. The
 * components are specified as a comma-separated list of identifiers, optionally
 * with type flags. The order in which components are specified does not matter.
 *
 * Examples:
 * ECS_ENTITY(world, MyEntity, Position, Velocity);
 * ECS_ENTITY(world, MyEntity 0);
 * ECS_ENTITY(world, MyEntity, Position, Velocity, CHILDOF | MyParentEntity);
 */ 
#define ECS_ENTITY(world, id, ...)\
    ecs_entity_t id = ecs_new_entity(world, 0, #id, #__VA_ARGS__);\
    (void)id;

/** Declare a prefab.
 * This macro will declare a new prefab with the provided id and components. The
 * order in which components are specified does not matter. A prefab is similar 
 * to an entity except that prefabs are typically used in combination with 
 * INSTANCEOF to serve as entity templates. Prefabs are by default not matched 
 * with systems.
 *
 * Examples:
 * ECS_PREFAB(world, MyPrefab, Position, Velocity);
 * ECS_PREFAB(world, MyPrefab, 0);
 * ECS_PREFAB(world, MyPrefab, Position, Velocity, INSTANCEOF | MyBasePrefab);
 *
 * Prefabs can be used with ECS_ENTITY:
 * ECS_ENTITY(world, MyEntity, Position, Velocity, INSTANCEOF | MyPrefab);
 */
#define ECS_PREFAB(world, id, ...) \
    ecs_entity_t id = ecs_new_prefab(world, 0, #id, #__VA_ARGS__);\
    (void)id;

/** Declare a component.
 * This macro declares a new component with the provided type. The type must be 
 * a valid C type or typedef. A type must first be registered as a component 
 * before it can be added to entities.
 *
 * Example:
 * ECS_COMPONENT(world, Position);
 * 
 * Components can be used with ECS_ENTITY:
 * ECS_ENTITY(world, MyEntity, Position);
 */
#define ECS_COMPONENT(world, id) \
    ECS_ENTITY_VAR(id) = ecs_new_component(world, 0, #id, sizeof(id), ECS_ALIGNOF(id));\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, ecs_entity(id));\
    (void)ecs_entity(id);\
    (void)ecs_type(id);\

/** Declare a tag.
 * A tag is a regular entity. This macro is provided for convenience, as in
 * addition to creating an entity, it also declares a type variable. This makes
 * it easier to use the entity in function calls that expect a component. */
#define ECS_TAG(world, id) \
    ECS_ENTITY(world, id, 0);\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, id);\
    (void)ecs_type(id);\

/** Declare a type.
 * This macro declares a type with the provided id and components. Types are
 * similar to components in that they can be added to an entity, but instead of
 * adding just one component, a type can add multiple components at once.
 * 
 * The components are specified as a comma-separated list of identifiers,
 * optionally with type flags.
 *
 * Examples:
 * ECS_ENTITY(world, MyType, Position, Velocity);
 * ECS_ENTITY(world, MyType 0);
 * ECS_ENTITY(world, MyType, Position, Velocity, CHILDOF | MyParentEntity);
 *
 * Types can be used in combination with ECS_ENTITY like this:
 *
 * ECS_ENTITY(world, MyEntity, Position, MyType);
 */
#define ECS_TYPE(world, id, ...) \
    ecs_entity_t id = ecs_new_type(world, 0, #id, #__VA_ARGS__);\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, id);\
    (void)id;\
    (void)ecs_type(id);\

/** Declare a systen.
 * This macro declares a system with the specified function, kind and signature. 
 * Systems are matched with entities that match the system signature. The system
 * signature is specified as a comma-separated list of column expressions, where
 * a column expression can be any of the following: 
 *
 * - A simple component identifier ('Position')
 * - An OR expression ('Position | Velocity')
 * - An optional expression ('?Position')
 * - A NOT expression ('!Position')
 * - An OWNED expression ('OWNED:Position')
 * - A SHARED expression ('SHARED:Position')
 * - A PARENT expression ('PARENT:Position')
 * - A CASCADE expression ('CASCADE:Position')
 * - An entity expression ('MyEntity:Position')
 * - An empty expression (':Position')
 * 
 * The systen kind specifies the phase in which the system is ran.
 *
 * Examples:
 * ECS_SYSTEM(world, Move, EcsOnUpdate, Position, Velocity, !AngularVelocity);
 * ECS_SYSTEM(world, Transform, EcsPostUpdate, PARENT:Transform, Transform);
 *
 * In these examples, 'Move' and 'Transform' must be valid identifiers to a C
 * function of the following signature:
 *
 * void Move(ecs_iter_t *it) { ... }
 *
 * Inside this function the system can access the data from the signature with
 * the ECS_COLUMN macro:
 *
 * ECS_COLUMN(it, Position, p, 1);
 * ECS_COLUMN(it, Velocity, v, 2);
 *
 * For more details on system signatures and phases see the Flecs manual.
 */

#define ECS_SYSTEM(world, name, kind, ...) \
    ecs_iter_action_t ecs_iter_action(name) = name;\
    ecs_entity_t name = ecs_new_system(world, 0, #name, kind, #__VA_ARGS__, ecs_iter_action(name));\
    (void)ecs_iter_action(name);\
    (void)name;

#define ECS_PIPELINE(world, name, ...) \
    ecs_entity_t name = ecs_new_pipeline(world, 0, #name, #__VA_ARGS__);

#endif

#define ECS_TRIGGER(world, name, kind, component) \
    ecs_entity_t __F##name = ecs_new_trigger(world, 0, #name, kind, #component, name);\
    ecs_entity_t name = __F##name;\
    (void)__F##name;\
    (void)name;


////////////////////////////////////////////////////////////////////////////////
//// World API
////////////////////////////////////////////////////////////////////////////////

/** Create a new world.
 * A world manages all the ECS objects. Applications must have at least one
 * world. Entities, component and system handles are local to a world and
 * cannot be shared between worlds.
 *
 * @return A new world object
 */
FLECS_EXPORT
ecs_world_t* ecs_init(void);

/** Same as ecs_init, but with minimal set of modules loaded.
 *
 * @return A new world object
 */
FLECS_EXPORT
ecs_world_t* ecs_mini(void);

/** Create a new world with arguments.
 * Same as ecs_init, but allows passing in command line arguments. These can be
 * used to dynamically enable flecs features to an application, like performance
 * monitoring or the web dashboard (if it is installed) without having to modify
 * the code of an application.
 * 
 * If the functionality requested by the arguments is not available, an error
 * message will be printed to stderr, but the function will not fail. Thus it is
 * important that the application code does not rely on any functionality that
 * is realized through the arguments.
 * 
 * If the arguments specify a setting that is explicity set as well by the
 * application, the application setting will be ignored. For example, if an
 * application specifies it will run on 2 threads, but an argument specify it
 * will run on 6 threads, the argument will take precedence.
 * 
 * The following options are available:
 * --threads [n]   Use n worker threads
 * --fps [hz]      Run at hz FPS
 * --admin [port]  Enable admin dashboard (requires flecs-systems-admin & flecs-systems-civetweb)
 * --console       Enables console (requires flecs-systems-console)
 * --debug         Enables debug tracing
 *
 * @return A new world object
 */
FLECS_EXPORT
ecs_world_t* ecs_init_w_args(
    int argc,
    char *argv[]);

/** Delete a world.
 * This operation deletes the world, and all entities, components and systems
 * within the world.
 *
 * @param world The world to delete.
 */
FLECS_EXPORT
int ecs_fini(
    ecs_world_t *world);

/** Register action to be executed when world is destroyed */
FLECS_EXPORT
void ecs_atfini(
    ecs_world_t *world,
    ecs_fini_action_t action,
    void *ctx);

/** Register ctor, dtor, copy & move callbacks for component */
FLECS_EXPORT
void ecs_set_component_actions(
    ecs_world_t *world,
    ecs_entity_t component,
    EcsComponentLifecycle *lifecycle);


/** Set a world context.
 * This operation allows an application to register custom data with a world
 * that can be accessed anywhere where the application has the world object.
 *
 * A typical usecase is to register a struct with handles to the application
 * entities, components and systems.
 *
 * @param world The world.
 * @param ctx A pointer to a user defined structure.
 */
FLECS_EXPORT
void ecs_set_context(
    ecs_world_t *world,
    void *ctx);

/** Get the world context.
 * This operation retrieves a previously set world context.
 *
 * @param world The world.
 * @return The context set with ecs_set_context. If no context was set, the
 *          function returns NULL.
 */
FLECS_EXPORT
void* ecs_get_context(
    ecs_world_t *world);

/** Get world statistics 
 * @param world The world.
 */
FLECS_EXPORT
const ecs_world_info_t* ecs_get_world_info(
    ecs_world_t *world);

/** Dimension the world for a specified number of entities.
 * This operation will preallocate memory in the world for the specified number
 * of entities. Specifying a number lower than the current number of entities in
 * the world will have no effect.
 *
 * When using this operation, note that flecs uses entities for storing
 * systems, components and builtin components. For an exact calculation of
 * entities, do user_entity_count + component_count + system_count + 3. The 3
 * stands for the number of builtin components.
 *
 * Note that this operation does not allocate memory in tables. To preallocate
 * memory in a table, use ecs_dim_type. Correctly using these functions
 * prevents flecs from doing dynamic memory allocations in the main loop.
 *
 * @param world The world.
 * @param entity_count The number of entities to preallocate.
 */
FLECS_EXPORT
void ecs_dim(
    ecs_world_t *world,
    int32_t entity_count);

/** Dimension a type for a specified number of entities.
 * This operation will preallocate memory for a type (table) for the
 * specified number of entites. Specifying a number lower than the current
 * number of entities in the table will have no effect.
 *
 * If no table exists yet for this type (when no entities have been committed
 * for the type) it will be created, even if the entity_count is zero. This
 * operation can thus also be used to just preallocate empty tables.
 *
 * If the specified type is unknown, the behavior of this function is
 * unspecified. To ensure that the type exists, use ecs_type_get or
 * ECS_TYPE.
 *
 * @param world The world.
 * @param type Handle to the type, as obtained by ecs_type_get.
 * @param entity_count The number of entities to preallocate.
 */
FLECS_EXPORT
void ecs_dim_type(
    ecs_world_t *world,
    ecs_type_t type,
    int32_t entity_count);

/** Set a range for issueing new entity ids.
 * This function constrains the entity identifiers returned by ecs_new to the 
 * specified range. This operation can be used to ensure that multiple processes
 * can run in the same simulation without requiring a central service that
 * coordinates issueing identifiers.
 * 
 * If id_end is set to 0, the range is infinite. If id_end is set to a non-zero
 * value, it has to be larger than id_start. If id_end is set and ecs_new is
 * invoked after an id is issued that is equal to id_end, the application will
 * abort. Flecs does not automatically recycle ids.
 * 
 * The id_end parameter has to be smaller than the last issued identifier.
 * 
 * @param world The world.
 * @param id_start The start of the range.
 * @param id_end The end of the range.
 */
FLECS_EXPORT
void ecs_set_entity_range(
    ecs_world_t *world,
    ecs_entity_t id_start,
    ecs_entity_t id_end);

/** Temporarily enable/disable range limits.
 * When an application is both a receiver of range-limited entities and a
 * producer of range-limited entities, range checking needs to be temporarily
 * disabled when receiving entities.
 * 
 * Range checking is disabled on a stage, so setting this value is thread safe.
 */
FLECS_EXPORT
bool ecs_enable_range_check(
    ecs_world_t *world,
    bool enable);

/** Enable world locking while in progress.
 * When locking is enabled, Flecs will lock the world while in progress. This
 * allows applications to interact with the world from other threads without
 * running into race conditions.
 *
 * This is a better alternative to applications putting a lock around calls to
 * ecs_progress, since ecs_progress can sleep when FPS control is enabled,
 * which is time during which other threads could perform work.
 *
 * Locking must be enabled before applications can use the ecs_lock and
 * ecs_unlock functions. Locking is turned off by default.
 *
 * @param world The world.
 * @param enable True if locking is to be enabled.
 * @result The previous value of the setting.
 */
FLECS_EXPORT
bool ecs_enable_locking(
    ecs_world_t *world,
    bool enable);

/** Locks the world.
 * See ecs_enable_locking for details.
 */
FLECS_EXPORT
void ecs_lock(
    ecs_world_t *world);

/** Unlocks the world.
 * See ecs_enable_locking for details.
 */
FLECS_EXPORT
void ecs_unlock(
    ecs_world_t *world);

/** Tracing */
FLECS_EXPORT
void _ecs_trace(
    int level,
    const char *file,
    int32_t line,
    const char *fmt,
    ...);

#define ecs_trace(lvl, ...)\
    _ecs_trace(lvl, __FILE__, __LINE__, __VA_ARGS__)

FLECS_EXPORT
void ecs_trace_push(void);
void ecs_trace_pop(void);

FLECS_EXPORT
void ecs_tracing_enable(
    bool enabled);

#if !defined(NDEBUG) && !(defined(ECS_VERBOSITY_0) || defined(ECS_VERBOSITY_1) || defined(ECS_VERBOSITY_3))
#define ECS_VERBOSITY_2
#endif

#ifndef NDEBUG

#if defined(ECS_VERBOSITY_3)
#define ecs_trace_1(...) ecs_trace(1, __VA_ARGS__);
#define ecs_trace_2(...) ecs_trace(2, __VA_ARGS__);
#define ecs_trace_3(...) ecs_trace(3, __VA_ARGS__);

#elif defined(ECS_VERBOSITY_2)
#define ecs_trace_1(...) ecs_trace(1, __VA_ARGS__);
#define ecs_trace_2(...) ecs_trace(2, __VA_ARGS__);
#define ecs_trace_3(...)

#elif defined(ECS_VERBOSITY_1)
#define ecs_trace_1(...) ecs_trace(1, __VA_ARGS__);
#define ecs_trace_2(...)
#define ecs_trace_3(...)
#endif

#else

#define ecs_trace_1(...)
#define ecs_trace_2(...)
#define ecs_trace_3(...)

#endif


////////////////////////////////////////////////////////////////////////////////
//// Entity API
////////////////////////////////////////////////////////////////////////////////

/* -- Create single entity -- */

FLECS_EXPORT
ecs_entity_t ecs_new_w_entity(
    ecs_world_t *world,
    ecs_entity_t component);

FLECS_EXPORT
ecs_entity_t ecs_new_w_type(
    ecs_world_t *world,
    ecs_type_t type);

#define ecs_new(world, type)\
    ecs_new_w_type(world, ecs_type(type))


/* -- Bulk create entities -- */

FLECS_EXPORT
ecs_entity_t ecs_bulk_new_w_entity(
    ecs_world_t *world,
    ecs_entity_t component,
    int32_t count);

FLECS_EXPORT
ecs_entity_t ecs_bulk_new_w_type(
    ecs_world_t *world,
    ecs_type_t type,
    int32_t count,
    void** data);

#define ecs_bulk_new(world, type, count)\
    ecs_bulk_new_w_type(world, ecs_type(type), count, NULL)


/* -- Add components -- */

FLECS_EXPORT
void ecs_add_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component);

FLECS_EXPORT
void ecs_add_type(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

#define ecs_add(world, entity, type)\
    ecs_add_type(world, entity, ecs_type(type))


/* -- Remove components -- */

FLECS_EXPORT
void ecs_remove_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component);

FLECS_EXPORT
void ecs_remove_type(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

#define ecs_remove(world, entity, type)\
    ecs_remove_type(world, entity, ecs_type(type))


/* -- Bulk add -- */

FLECS_EXPORT
void ecs_bulk_add_entity(
    ecs_world_t *world,
    ecs_entity_t component,
    const ecs_filter_t *filter);

FLECS_EXPORT
void ecs_bulk_add_type(
    ecs_world_t *world,
    ecs_type_t type,
    const ecs_filter_t *filter);

#define ecs_bulk_add(world, type, filter)\
    ecs_bulk_add_type(world, ecs_type(type), filter)


/* -- Bulk remove -- */

FLECS_EXPORT
void ecs_bulk_remove_entity(
    ecs_world_t *world,
    ecs_entity_t component,
    const ecs_filter_t *filter);

FLECS_EXPORT
void ecs_bulk_remove_type(
    ecs_world_t *world,
    ecs_type_t type,
    const ecs_filter_t *filter);

#define ecs_bulk_remove(world, type, filter)\
    ecs_bulk_remove_type(world, ecs_type(type), filter)


/* -- Add remove / Bulk add remove -- */

FLECS_EXPORT
void ecs_add_remove_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t to_add,
    ecs_entity_t to_remove);

FLECS_EXPORT
void ecs_add_remove_type(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t to_add,
    ecs_type_t to_remove);

#define ecs_add_remove(world, entity, to_add, to_remove)\
    ecs_add_remove_type(world, entity, ecs_type(to_add), ecs_type(to_remove))

FLECS_EXPORT
void ecs_bulk_add_remove_type(
    ecs_world_t *world,
    ecs_type_t to_add,
    ecs_type_t to_remove,
    const ecs_filter_t *filter);

#define ecs_bulk_add_remove(world, to_add, to_remove, filter)\
    ecs_bulk_add_remove_type(world, ecs_type(to_add), ecs_type(to_remove), filter)


/* -- Delete & bulk delete -- */

FLECS_EXPORT
void ecs_delete(
    ecs_world_t *world,
    ecs_entity_t entity);

FLECS_EXPORT
void ecs_bulk_delete(
    ecs_world_t *world,
    const ecs_filter_t *filter);


/* -- Copy -- */

FLECS_EXPORT
ecs_entity_t ecs_clone(
    ecs_world_t *world,
    ecs_entity_t dst,
    ecs_entity_t src,
    bool copy_value);


/* -- Get -- */

FLECS_EXPORT
const void* ecs_get_w_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component);

#define ecs_get(world, entity, component)\
    ((const component*)ecs_get_w_entity(world, entity, ecs_entity(component)))

/* -- Get cached pointer -- */

FLECS_EXPORT
const void* ecs_get_ref_w_entity(
    ecs_world_t *world,
    ecs_ref_t *ref,
    ecs_entity_t entity,
    ecs_entity_t component);

#define ecs_get_ref(world, ref, entity, component)\
    ((const component*)ecs_get_ref_w_entity(world, ref, entity, ecs_entity(component)))


/* -- Get mutable -- */

FLECS_EXPORT
void* ecs_get_mut_w_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component,
    bool *is_added);

#define ecs_get_mut(world, entity, component, is_added)\
    ((component*)ecs_get_mut_w_entity(world, entity, ecs_entity(component), is_added))


/* -- Modified -- */

FLECS_EXPORT 
void ecs_modified_w_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component);

#define ecs_modified(world, entity, component)\
    ecs_modified_w_entity(world, entity, ecs_entity(component))


/* -- Set -- */

FLECS_EXPORT
ecs_entity_t ecs_set_ptr_w_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component,
    size_t size,
    const void *ptr);

#define ecs_set_ptr(world, entity, component, ptr)\
    ecs_set_ptr_w_entity(world, entity, ecs_entity(component), sizeof(component), ptr)

/* Conditionally skip macro's as compound literals are not supported in C89 */
#ifndef __BAKE_LEGACY__
#define ecs_set(world, entity, component, ...)\
    ecs_set_ptr_w_entity(world, entity, ecs_entity(component), sizeof(component), &(component)__VA_ARGS__)
#endif


/* -- Has -- */

FLECS_EXPORT
bool ecs_has_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component);

FLECS_EXPORT
bool ecs_has_type(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

#define ecs_has(world, entity, type)\
    ecs_has_type(world, entity, ecs_type(type))

#define ecs_has_owned(world, entity, type, owned)\
    ecs_type_has_owned_type(world, ecs_get_type(world, entity), ecs_type(type), owned)

#define ecs_has_owned_entity(world, entity, has, owned)\
    ecs_type_has_owned_entity(world, ecs_get_type(world, entity), has, owned)


/* -- Entity info -- */

FLECS_EXPORT
ecs_type_t ecs_get_type(
    ecs_world_t *world,
    ecs_entity_t entity);


FLECS_EXPORT
const char* ecs_get_name(
    ecs_world_t *world,
    ecs_entity_t entity);

FLECS_EXPORT
bool ecs_get_watched(
    ecs_world_t *world,
    ecs_entity_t entity);


/* -- Count entities -- */

FLECS_EXPORT
int32_t ecs_count_entity(
    ecs_world_t *world,
    ecs_entity_t entity);

FLECS_EXPORT
int32_t ecs_count_type(
    ecs_world_t *world,
    ecs_type_t type);

#define ecs_count(world, type)\
    ecs_count_type(world, ecs_type(type))

FLECS_EXPORT
int32_t ecs_count_w_filter(
    ecs_world_t *world,
    const ecs_filter_t *filter);


/* -- Lookup entities by name -- */

FLECS_EXPORT
ecs_entity_t ecs_lookup(
    ecs_world_t *world,
    const char *id);

FLECS_EXPORT
ecs_entity_t ecs_lookup_child(
    ecs_world_t *world,
    ecs_entity_t parent,
    const char *name);


/* -- Get parent -- */

FLECS_EXPORT
ecs_entity_t ecs_get_parent_w_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component);

#define ecs_get_parent(world, entity, component)\
    ecs_get_parent_w_entity(world, entity, ecs_entity(component))

/** Enable or disable an entity.
 * This operation enables or disables an entity by adding or removing the
 * EcsDisabled tag.
 *
 * @param world The world.
 * @param system The system to enable or disable.
 * @param enabled true to enable the system, false to disable the system.
 * @return 0 if succeeded, -1 if the operation failed.
 */
FLECS_EXPORT
void ecs_enable(
    ecs_world_t *world,
    ecs_entity_t system,
    bool enabled);


////////////////////////////////////////////////////////////////////////////////
//// Hierarchies
////////////////////////////////////////////////////////////////////////////////

FLECS_EXPORT
char* ecs_get_path_w_sep(
    ecs_world_t *world,
    ecs_entity_t parent,
    ecs_entity_t child,
    ecs_entity_t component,
    char *sep,
    char *prefix);

#define ecs_get_path(world, parent, child)\
    ecs_get_path_w_sep(world, parent, child, 0, ".", NULL)

#define ecs_get_fullpath(world, child)\
    ecs_get_path_w_sep(world, 0, child, 0, ".", NULL)

FLECS_EXPORT
ecs_entity_t ecs_lookup_path_w_sep(
    ecs_world_t *world,
    ecs_entity_t parent,
    const char *path,
    const char *sep,
    const char *prefix);

#define ecs_lookup_path(world, parent, path)\
    ecs_lookup_path_w_sep(world, parent, path, ".", NULL)

#define ecs_lookup_fullpath(world, path)\
    ecs_lookup_path_w_sep(world, 0, path, ".", NULL)

FLECS_EXPORT
ecs_entity_t ecs_new_from_path_w_sep(
    ecs_world_t *world,
    ecs_entity_t parent,
    const char *path,
    const char *sep,
    const char *prefix);

#define ecs_new_from_path(world, parent, path)\
    ecs_new_from_path_w_sep(world, parent, path, ".", NULL)

#define ecs_new_from_fullpath(world, path)\
    ecs_new_from_path_w_sep(world, 0, path, ".", NULL)

FLECS_EXPORT
ecs_iter_t ecs_scope_iter(
    ecs_world_t *world,
    ecs_entity_t parent);

FLECS_EXPORT
bool ecs_scope_next(
    ecs_iter_t *it);

FLECS_EXPORT
ecs_entity_t ecs_set_scope(
    ecs_world_t *world,
    ecs_entity_t scope);

FLECS_EXPORT
ecs_entity_t ecs_get_scope(
    ecs_world_t *world);

FLECS_EXPORT
const char* ecs_set_name_prefix(
    ecs_world_t *world,
    const char *prefix);

////////////////////////////////////////////////////////////////////////////////
//// View API
////////////////////////////////////////////////////////////////////////////////

/** Obtain column data. 
 * This function is to be used inside a system to obtain data from a column in
 * the system signature. The provided index corresponds with the index of the
 * element in the system signature, starting from one. For example, for the
 * following system signature:
 * 
 * Position, Velocity
 * 
 * Position is at index 1, and Velocity is at index 2.
 * 
 * This function is typically invoked through the `ECS_COLUMN` macro which
 * automates declaring a variable of the correct type in the scope of the system
 * function.
 * 
 * When a valid pointer is obtained, it can be used as an array with it->count
 * elements if the column is owned by the entity being iterated over, or as a
 * pointer if the column is shared (see ecs_is_shared).
 * 
 * @param it The it parameter passed into the system.
 * @param index The index identifying the column in a system signature.
 * @return A pointer to the column data if index is valid, otherwise NULL.
 */
FLECS_EXPORT
void* _ecs_column(
    const ecs_iter_t *it,
    size_t size,
    int32_t column);

#define ecs_column(it, type, column)\
    ((type*)_ecs_column(it, sizeof(type), column))

/** Same as ecs_column, but for const ([in]) columns */
FLECS_EXPORT
const void* _ecs_const_column(
    const ecs_iter_t *it,
    size_t size,
    int32_t column);

#define ecs_const_column(it, type, column)\
    ((const type*)_ecs_const_column(it, sizeof(type), column))

/** Test if column is shared or not. 
 * The following signature shows an example of owned components and shared
 * components:
 * 
 * Position, PARENT:Velocity, MyEntity:Mass
 * 
 * Position is an owned component, while Velocity and Mass are shared 
 * components. While these kinds of relationships are expressed explicity in a
 * system signature, inheritance relationships are implicit. The above signature
 * matches both entities for which Position is owned as well as entities for
 * which Position appears in an entity that they inherit from.
 * 
 * If a system needs to support both cases, it needs to test whether the
 * component is shared or not. This test only needs to happen once per system
 * callback invocation, as all the entities being iterated over will either own
 * or not own the component.
 * 
 * @param it The it parameter passed into the system.
 * @param index The index identifying the column in a system signature.
 * @return true if the column is shared, false if it is owned.
 */
FLECS_EXPORT
bool ecs_is_shared(
    const ecs_iter_t *it,
    int32_t column);

/** Obtain a single field. 
 * This is an alternative method to ecs_column to access data in a system, which
 * accesses data from individual fields (one column per row). This method is
 * slower than iterating over a column array, but has the added benefit that it
 * automatically abstracts between shared components and owned components. 
 * 
 * This is particularly useful if a system is unaware whether a particular 
 * column is from a prefab, as a system does not explicitly state in an argument
 * expression whether prefabs should be matched with, thus it is possible that
 * a system receives both shared and non-shared data for the same column.
 * 
 * When a system uses fields, these differences will be transparent, and it is
 * therefore the method that provides the most flexibility with respect to the
 * kind of data the system can accept.
 */
FLECS_EXPORT
void *_ecs_field(
    const ecs_iter_t *it,
    size_t size,
    int32_t column,
    int32_t row);

#define ecs_field(it, type, column, row)\
    ((type*)_ecs_field(it, sizeof(type), column, row))

/** Obtain the source of a column from inside a system.
 * This operation lets you obtain the entity from which the column data was
 * resolved. In most cases a component will come from the entities being
 * iterated over, but when using prefabs or containers, the component can be
 * shared between entities. For shared components, this function will return the
 * original entity on which the component is stored.
 * 
 * If a column is specified for which the component is stored on the entities
 * being iterated over, the operation will return 0, as the entity id in that
 * case depends on the row, not on the column. To obtain the entity ids for a
 * row, a system should access the entity column (column zero) like this:
 * 
 * ecs_entity_t *entities = ecs_column(it, ecs_entity_t, 0);
 * 
 * @param it Pointer to the it object passed into the system callback.
 * @param index An index identifying the column for which to obtain the component.
 * @return The source entity for the column. 
 */
FLECS_EXPORT
ecs_entity_t ecs_column_source(
    const ecs_iter_t *it,
    int32_t column);

/** Obtain the component for a column inside a system.
 * This operation obtains the component handle for a column in the system. This
 * function wraps around the 'components' array in the ecs_iter_t type.
 * 
 * Note that since component identifiers are obtained from the same pool as
 * regular entities, the return type of this function is ecs_entity_t.
 * 
 * When a system contains an argument that is prefixed with 'ID', the resolved
 * entity will be accessible through this function as well.
 * 
 * Column indices for system arguments start from 1, where 0 is reserved for a
 * column that contains entity identifiers. Passing 0 to this function for the
 * column index will return 0.
 * 
 * @param it Pointer to the it object passed into the system callback.
 * @param index An index identifying the column for which to obtain the component.
 * @return The component for the specified column, or 0 if failed.
 */
FLECS_EXPORT
ecs_entity_t ecs_column_entity(
    const ecs_iter_t *it,
    int32_t column);

/** Obtain the type of a column from inside a system. 
 * This operation is equivalent to ecs_column_entity, except that it returns
 * a type, instead of an entity handle. Invoking this function is the same as
 * doing:
 * 
 * ecs_type_from_entity( ecs_column_entity(it, index));
 * 
 * This function is wrapped in the following convenience macro which ensures
 * that the type variable is named so it can be used with functions like ecs_add
 * and ecs_set:
 * 
 * ECS_COLUMN_COMPONENT(it, Position, 1);
 * 
 * After this macro you can invoke functions like ecs_set as you normally would:
 * 
 * ecs_set(world, e, Position, {10, 20});
 * 
 * @param it Pointer to the it object passed into the system callback.
 * @param index An index identifying the column for which to obtain the component.
 * @return The type for the specified column, or 0 if failed.
 */ 
FLECS_EXPORT
ecs_type_t ecs_column_type(
    const ecs_iter_t *it,
    int32_t column);

/** Is the column readonly.
 * This operation returns if the column is a readonly column. Readonly columns
 * are marked in the system signature with the [in] modifier. 
 * 
 * @param it Pointer to the it object passed into the system callback.
 * @param column An index identifying the column.
 * @return true if the column is readonly, false otherwise. */
FLECS_EXPORT
bool ecs_is_readonly(
    const ecs_iter_t *it,
    int32_t column);

/** Get type of table that system is currently iterating over. */
FLECS_EXPORT
ecs_type_t ecs_table_type(
    const ecs_iter_t *it);

/** Get column using the table index. */
FLECS_EXPORT
void* ecs_table_column(
    const ecs_iter_t *it,
    int32_t column);

/** Get a strongly typed pointer to a column (owned or shared). */
#define ECS_COLUMN(it, type, id, column)\
    ECS_ENTITY_VAR(type) = ecs_column_entity(it, column);\
    ECS_TYPE_VAR(type) = ecs_column_type(it, column);\
    type *id = ecs_column(it, type, column);\
    (void)ecs_entity(type);\
    (void)ecs_type(type);\
    (void)id

/** Get a strongly typed pointer to a column (owned or shared). */
#define ECS_CONST_COLUMN(it, type, id, column)\
    const type *id = ecs_const_column(it, type, column)

/** Obtain a handle to the component of a column */
#define ECS_COLUMN_COMPONENT(it, id, column)\
    ECS_ENTITY_VAR(id) = ecs_column_entity(it, column);\
    ECS_TYPE_VAR(id) = ecs_column_type(it, column);\
    (void)ecs_entity(id);\
    (void)ecs_type(id)

/** Obtain a handle to the entity of a column */
#define ECS_COLUMN_ENTITY(it, id, column)\
    ecs_entity_t id = ecs_column_entity(it, column);\
    ECS_TYPE_VAR(id) = ecs_column_type(it, column);\
    (void)id;\
    (void)ecs_type(id)

/** Utility macro for importing all handles for a module from a system column */
#define ECS_IMPORT_COLUMN(it, module, column) \
    module *ecs_module_ptr(module) = ecs_column(it, module, column);\
    ecs_assert(ecs_module_ptr(module) != NULL, ECS_MODULE_UNDEFINED, #module);\
    ecs_assert(ecs_is_shared(it, column), ECS_COLUMN_IS_NOT_SHARED, NULL);\
    module ecs_module(module) = *ecs_module_ptr(module);\
    module##ImportHandles(ecs_module(module))


////////////////////////////////////////////////////////////////////////////////
//// Filter iterator API
////////////////////////////////////////////////////////////////////////////////

/** Create iterator that matches world tables with specified filter.
 * This operation allows applications to query entities ad hoc with a filter. 
 * Combined with the ecs_filter_next function an application can iterate over a
 * set of tables that matches the provided filter, for which the ecs_filter_next
 * function will populate an ecs_iter_t object, which can be used to iterate the
 * entities in the table.
 * 
 * @param world The world.
 * @param filter The filter.
 * @return An iterator that can be used with ecs_filter_next.
 */
FLECS_EXPORT
ecs_iter_t ecs_filter_iter(
    ecs_world_t *world,
    const ecs_filter_t *filter);

/** Same as ecs_filter_iter, but for iterating snapshots tables. */
FLECS_EXPORT
ecs_iter_t ecs_snapshot_filter_iter(
    ecs_world_t *world,
    const ecs_snapshot_t *snapshot,
    const ecs_filter_t *filter);    

/** Iterate tables matched by filter.
 * This operation can be called repeatedly for an iterator until it returns
 * false, in which case there are no more tables that matched the filter.
 *
 * When the operation returns true, the contents of the table can be accessed
 * through the "it" member of the iterator, which is of type ecs_iter_t. To
 * get the component data, an application has to first obtain the table type
 * with ecs_table_type(iter.it). This type contains the ordered list of
 * components stored in the table.
 *
 * An application can then obtain a specific component by first retrieving the
 * index of the component in the table type with column = 
 * ecs_type_index_of(table_type, Component), followed by 
 * ecs_table_column(it, column) to obtain a pointer to the component array.
 * 
 * @param iter The iterator.
 */
FLECS_EXPORT
bool ecs_filter_next(
    ecs_iter_t *iter);


////////////////////////////////////////////////////////////////////////////////
//// Query API
////////////////////////////////////////////////////////////////////////////////

/** Create a query.
 * This operation creates a query. Queries are used to iterate over entities
 * that match a signature expression.
 * 
 * Queries are 'persistent' meaning they are registered with
 * the world and continuously matched with new entities (tables). Queries
 * are the fastest way to iterate over entities, as a lot of processing is
 * done when entities are matched, outside of the main loop.
 *
 * Queries are the mechanism used by systems, and as such both accept the
 * same signature expressions, and have similar performance. 
 *
 * Queries, like systems, iterate over component data from the main stage.
 * This means that when an application is iterating a query outside of a system,
 * care must be taken when adding/removing components or creating/deleting
 * entities, as this may corrupt the iteration.
 *
 * When a query is iterated over inside a system normal staging applies, and an
 * application can safely update entities.
 *
 * @param world The world.
 * @param expr The query signature expression.
 * @return The new query.
 */
FLECS_EXPORT
ecs_query_t* ecs_query_new(
    ecs_world_t *world,
    const char *sig);

/** Sort the output of a query */
FLECS_EXPORT
void ecs_query_sort(
    ecs_world_t *world,
    ecs_query_t *query,
    ecs_entity_t sort_component,
    ecs_compare_action_t compare);

FLECS_EXPORT
void ecs_query_sort_types(
    ecs_world_t *world,
    ecs_query_t *query,
    ecs_entity_t monitor_component,
    ecs_rank_type_action_t rank_type);

/** Cleanup a query.
 * This operation frees a query.
 *
 * @param query The query.
 */
FLECS_EXPORT
void ecs_query_free(
    ecs_query_t *query);

/** Iterate over a query.
 * This operation returns an iterator to a query. Multiple iterators can be
 * created per query. It is safe to iterate over a query from multiple threads,
 * as long as each thread uses its own iterator.
 *
 * The iterator contains an ecs_iter_t struct which can be read by the 
 * application to obtain the component data, just like with systems.
 *
 * @param query The query to iterate.
 * @return The query iterator.
 */
FLECS_EXPORT
ecs_iter_t ecs_query_iter(
    ecs_query_t *query);  

/** Iterate over a query.
 * This operation returns an iterator to a query. Multiple iterators can be
 * created per query. It is safe to iterate over a query from multiple threads,
 * as long as each thread uses its own iterator.
 *
 * The iterator contains an ecs_iter_t struct which can be read by the 
 * application to obtain the component data, just like with systems.
 *
 * @param query The query to iterate.
 * @param offset The number of entities to skip.
 * @param limit The maximum number of entities to iterate.
 * @return The query iterator.
 */
FLECS_EXPORT
ecs_iter_t ecs_query_iter_page(
    ecs_query_t *query,
    int32_t offset,
    int32_t limit);  

/** Progress the query iterator.
 * This operation progresses the iterator. The iterator will return once for
 * each matched table (entity type). 
 *
 * @param iter The iterator.
 * @return true if more data is available, false if no more data is available.
 */
FLECS_EXPORT
bool ecs_query_next(
    ecs_iter_t *iter);      

bool ecs_query_next_worker(
    ecs_iter_t *it,
    int32_t current,
    int32_t total);


////////////////////////////////////////////////////////////////////////////////
//// Snapshot API
////////////////////////////////////////////////////////////////////////////////

/** Create a snapshot.
 * This operation makes a copy of all component in the world that matches the 
 * specified filter.
 *
 * @param world The world to snapshot.
 * @param filter A filter that specifies which components to snapshot.
 * @param return The snapshot.
 */
FLECS_EXPORT
ecs_snapshot_t* ecs_snapshot_take(
    ecs_world_t *world,
    const ecs_filter_t *filter);

/** Restore a snapshot.
 * This operation restores the world to the state it was in when the specified
 * snapshot was taken. A snapshot can only be used once for restoring, as its
 * data replaces the data that is currently in the world.
 * This operation also resets the last issued entity handle, so any calls to
 * ecs_new may return entity ids that have been issued before restoring the 
 * snapshot.
 *
 * The world in which the snapshot is restored must be the same as the world in
 * which the snapshot is taken.
 *
 * @param world The world to restore the snapshot to.
 * @param snapshot The snapshot to restore. 
 */
FLECS_EXPORT
void ecs_snapshot_restore(
    ecs_world_t *world,
    ecs_snapshot_t *snapshot);

/** Copy a snapshot.
 * This operation creates a copy of the provided snapshot. An application can
 * optionally filter the tables to copy.
 *
 * @param world The world.
 * @param snapshot The snapshot to copy.
 * @param filter Filter to apply to the copy (optional)
 * @return The duplicated snapshot.
 */
FLECS_EXPORT
ecs_snapshot_t* ecs_snapshot_copy(
    ecs_world_t *world,
    const ecs_snapshot_t *snapshot,
    const ecs_filter_t *filter);

/** Free snapshot resources.
 * This frees resources associated with a snapshot without restoring it.
 *
 * @param world The world.
 * @param snapshot The snapshot to free. 
 */
FLECS_EXPORT
void ecs_snapshot_free(
    ecs_world_t *world,
    ecs_snapshot_t *snapshot);


////////////////////////////////////////////////////////////////////////////////
//// Reader/writer API
////////////////////////////////////////////////////////////////////////////////

/** Initialize a reader.
 * A reader serializes data in a world to a sequence of bytes that can be stored
 * in a file or sent across a network. 
 *
 * @param world The world to serialize.
 * @return The reader.
 */
FLECS_EXPORT
ecs_reader_t ecs_reader_init(
    ecs_world_t *world);

/** Initialize a snapshot reader.
 * A snapshot reader serializes data in a snapshot to a sequence of bytes that 
 * can be stored in a file or sent across a network. A snapshot reader has as
 * advantage that serialization can take place asynchronously while the world
 * is progressing.
 *
 * @param world The world in which the snapshot is taken.
 * @param snapshot The snapshot to serialize.
 * @return The reader.
 */
FLECS_EXPORT
ecs_reader_t ecs_snapshot_reader_init(
    ecs_world_t *world,
    const ecs_snapshot_t *snapshot);

/** Read from a reader.
 * This operation reads a specified number of bytes from a reader and stores it
 * in the specified buffer. When there are no more bytes to read from the reader
 * the operation will return 0, otherwise it will return the number of bytes
 * read.
 *
 * The specified buffer must be at least as big as the specified size, and the
 * specified size must be a multiple of 4.
 *
 * @param buffer The buffer in which to store the read bytes.
 * @param size The maximum number of bytes to read.
 * @param reader The reader from which to read the bytes.
 * @return The number of bytes read.
 */ 
FLECS_EXPORT
size_t ecs_reader_read(
    char *buffer,
    size_t size,
    ecs_reader_t *reader);

/** Initialize a writer.
 * A writer deserializes data from a sequence of bytes into a world. This 
 * enables applications to restore data from disk or the network.
 *
 * The provided world must be either empty or compatible with the data to
 * deserialize, where compatible means that the serialized component ids and 
 * sizes must match exactly with those in the world. Errors can occur if a world
 * is provided in which components have been declared in a different order, or
 * when components have different type definitions.
 *
 * @param world The world in which to deserialize the data.
 * @return The writer. 
 */
FLECS_EXPORT
ecs_writer_t ecs_writer_init(
    ecs_world_t *world);

/** Write to a writer.
 * This operation writes a specified number of bytes from a specified buffer
 * into the writer. The writer will restore the deserialized data into the 
 * original serialized entities. The write operation may be invoked multiple
 * times with partial buffers, which allows applications to use static buffers
 * when reading from, for example, a file or the network.
 *
 * The data contained in the buffers must have been serialized with the
 * ecs_reader_read operation. If the data does not match the expected format, or
 * the data contains conflicts with the world, the operation will fail. The
 * data must be provided in the same order as produced by ecs_reader_read,
 * but the used buffer size does not have to be the same as the one used by
 * ecs_reader_read. The buffer size must be a multiple of 4.
 * 
 * @param buffer The buffer to deserialize.
 * @param size The maximum number of bytes.
 * @param writer The writer to write to.
 * @return Zero if success, non-zero if failed to deserialize.
 */
FLECS_EXPORT
int ecs_writer_write(
    const char *buffer,
    size_t size,
    ecs_writer_t *writer);


////////////////////////////////////////////////////////////////////////////////
//// Module API
////////////////////////////////////////////////////////////////////////////////

/** Import a flecs module.
 * Flecs modules enable reusing components and systems across projects. To
 * use a module, a project needs to link with its library and include its header
 * file.
 *
 * The module returns a struct with handles to the loaded components / systems
 * so they can be accessed by the application. Note that if the module is loaded
 * in different worlds, the handles may not be the same.
 *
 * These naming conventions are not enforced, and projects are free to use their
 * own conventions, though these are the conventions used by the modules
 * provided by flecs.
 *
 * The load function has an additional flags argument which is passed to the
 * module, and is intended to allow applications to select only features they
 * require from a module. The mapping granularity of flags to components/systems
 * is to be defined by the module.
 *
 * This function is wrapped by the ECS_IMPORT convenience macro:
 *
 * ECS_IMPORT(world, EcsComponentsTransform 0);
 *
 * This macro automatically creates a variable called eEcsComponentsTransform
 * that is the struct with the handles for that component.
 *
 * @param world The world.
 * @param module The module to load.
 * @param flags A bitmask that specifies which parts of the module to load.
 * @param handles_out A struct with handles to the module components/systems.
 */
FLECS_EXPORT
ecs_entity_t ecs_import(
    ecs_world_t *world,
    ecs_module_action_t module,
    const char *module_name,
    int flags,
    void *handles_out,
    size_t handles_size);

/* Import a module from a library.
 * If a module is stored in another library, it can be dynamically loaded with
 * this operation. A library may contain multiple modules, and to disambiguate
 * the function allows applications to specify the 'module_name' aprameter.
 *
 * A library name typically looks like 'flecs.components.transform', whereas a
 * module name typically looks like 'FlecsComponentsTransform'.
 *
 * To use this function, Flecs needs to be built with bake, as it relies on
 * bake's package discovery utility API.
 *
 * @param world The world.
 * @param library_name The name of the library to load.
 * @param module_name The name of the module to load.
 * @param flags The flags to pass to the module.
 */
FLECS_EXPORT
ecs_entity_t ecs_import_from_library(
    ecs_world_t *world,
    const char *library_name,
    const char *module_name,
    int flags);

/** Define module
 */
#define ECS_MODULE(world, id)\
    ECS_ENTITY_VAR(id) = ecs_new_module(world, 0, #id, sizeof(id), ECS_ALIGNOF(id));\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, ecs_entity(id));\
    id *handles = (id*)ecs_get_mut(world, ecs_entity(id), id, NULL);\
    (void)ecs_entity(id);\
    (void)ecs_type(id);\
    (void)handles;


/** Wrapper around ecs_import.
 * This macro provides a convenient way to load a module with the world. It can
 * be used like this:
 *
 * ECS_IMPORT(world, FlecsSystemsPhysics, 0);
 * 
 * This macro will define entity and type handles for the component associated
 * with the module. An application can retrieve the module component like this:
 * 
 * FlecsSystemsPhysics m = ecs_get(world, EcsSingleton, FlecsSystemsPhysics);
 * 
 * The contents of a module component are module specific, although they
 * typically contain handles to the content of the module.
 */
#define ECS_IMPORT(world, id, flags) \
    id ecs_module(id);\
    char *id##__name = ecs_module_path_from_c(#id);\
    ECS_ENTITY_VAR(id) = ecs_import(\
        world, id##Import, id##__name, flags, &ecs_module(id), sizeof(id));\
    ecs_os_free(id##__name);\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, ecs_entity(id));\
    id##ImportHandles(ecs_module(id));\
    (void)ecs_entity(id);\
    (void)ecs_type(id);\

/** Utility macro for declaring a component inside a handles type */
#define ECS_DECLARE_COMPONENT(type)\
    ECS_ENTITY_VAR(type);\
    ECS_TYPE_VAR(type)

/** Utility macro for declaring a system inside a handles type */
#define ECS_DECLARE_ENTITY(entity)\
    ecs_entity_t entity;\
    ECS_TYPE_VAR(entity)

#define ECS_EXPORT_COMPONENT(type)\
    ECS_SET_COMPONENT(type)

#define ECS_EXPORT_ENTITY(type)\
    ECS_SET_ENTITY(type)

/** Utility macro for declaring handles by modules */
#define ECS_IMPORT_COMPONENT(handles, type)\
    ECS_ENTITY_VAR(type) = (handles).ecs_entity(type); (void)ecs_entity(type);\
    ECS_TYPE_VAR(type) = (handles).ecs_type(type); (void)ecs_type(type);\
    (void)ecs_entity(type);\
    (void)ecs_type(type)

/** Utility macro for declaring handles by modules */
#define ECS_IMPORT_ENTITY(handles, entity)\
    ecs_entity_t entity = (handles).entity;\
    ECS_TYPE_VAR(entity) = (handles).ecs_type(entity); (void)ecs_type(entity);\
    (void)entity;\
    (void)ecs_type(entity)

/** -- Builtin module flags -- */
#define ECS_REFLECTION (1)
#define ECS_2D (2)
#define ECS_3D (3)


////////////////////////////////////////////////////////////////////////////////
//// Type API
////////////////////////////////////////////////////////////////////////////////

FLECS_EXPORT
ecs_type_t ecs_type_from_entity(
    ecs_world_t *world,
    ecs_entity_t entity);

FLECS_EXPORT
ecs_entity_t ecs_type_to_entity(
    ecs_world_t *world,
    ecs_type_t type);

FLECS_EXPORT
char* ecs_type_str(
    ecs_world_t *world,
    ecs_type_t type);

FLECS_EXPORT
ecs_type_t ecs_type_from_str(
    ecs_world_t *world,
    const char *expr);    

FLECS_EXPORT
ecs_type_t ecs_type_find(
    ecs_world_t *world,
    ecs_entity_t *array,
    int32_t count);

FLECS_EXPORT
ecs_type_t ecs_type_merge(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_type_t type_add,
    ecs_type_t type_remove);

FLECS_EXPORT
ecs_type_t ecs_type_add(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_entity_t entity);

FLECS_EXPORT
ecs_type_t ecs_type_remove(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_entity_t entity);

FLECS_EXPORT
bool ecs_type_has_entity(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_entity_t entity);

FLECS_EXPORT
bool ecs_type_has_type(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_type_t has);

FLECS_EXPORT
bool ecs_type_has_owned_entity(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_entity_t entity,
    bool owned);

FLECS_EXPORT
bool ecs_type_has_owned_type(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_type_t has,
    bool owned);

FLECS_EXPORT
ecs_entity_t ecs_type_get_entity_for_xor(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_entity_t xor_tag);

FLECS_EXPORT
int16_t ecs_type_index_of(
    ecs_type_t type,
    ecs_entity_t component);


////////////////////////////////////////////////////////////////////////////////
//// Threading / Staging API
////////////////////////////////////////////////////////////////////////////////

FLECS_EXPORT
void ecs_merge(
    ecs_world_t *world);

FLECS_EXPORT
void ecs_set_automerge(
    ecs_world_t *world,
    bool auto_merge);

FLECS_EXPORT
bool ecs_staging_begin(
    ecs_world_t *world);

FLECS_EXPORT
bool ecs_staging_end(
    ecs_world_t *world,
    bool is_staged);


////////////////////////////////////////////////////////////////////////////////
//// Utilities
////////////////////////////////////////////////////////////////////////////////

/** Enables admin web server
 * This operation allows an profile and enable/disable registered systems. If
 * the flecs.systems.civetweb or flecs.systems.admin modules cannot be found,
 * the operation will fail.
 *
 * @param world The world.
 * @param port A port number for server.
 * 
 * @return The error code
 *          0 - success
 *          1 - failed to dynamically load `flecs.systems.civetweb` module
 *          2 - failed to dynamically load `flecs.systems.admin` module
 */
FLECS_EXPORT
int ecs_enable_admin(
	ecs_world_t* world,
	uint16_t port);

/** Enable command line console for inspecting Flecs internals.
 * If the flecs.systems.console module cannot be found, the operation will fail.
 *
 * @param world The world.
 * @return 0 if success, nonzero if failed.  
 */
FLECS_EXPORT
int ecs_enable_console(
	ecs_world_t* world);

#include "flecs/modules/systems.h"
#include "flecs/modules/pipeline.h"
#include "flecs/modules/timers.h"

#ifdef __cplusplus
}

#ifndef FLECS_NO_CPP
#ifndef __BAKE_LEGACY__
#include "flecs/flecs.hpp"
#endif
#endif

#endif

#endif
