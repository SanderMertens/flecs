
#ifndef FLECS_H
#define FLECS_H

#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#ifndef __BAKE__
#include <stdint.h>
#endif

/* This file is generated by bake and contains macro's for 
 * importing/exporting symbols */
#include <flecs/bake_config.h>

/* The API uses the native bool type in C++, or a custom one in C */
#ifndef __cplusplus
#undef bool
#undef true
#undef false
typedef char bool;
#define false 0
#define true !false
#endif

#include <flecs/util/os_api.h>
#include <flecs/util/vector.h>
#include <flecs/util/chunked.h>
#include <flecs/util/map.h>
#include <flecs/util/os_api.h>

#ifdef __cplusplus
extern "C" {
#endif


////////////////////////////////////////////////////////////////////////////////
//// Opaque types
////////////////////////////////////////////////////////////////////////////////

typedef struct ecs_world_t ecs_world_t;
typedef struct ecs_rows_t ecs_rows_t;
typedef struct ecs_reference_t ecs_reference_t;
typedef struct ecs_snapshot_t ecs_snapshot_t;


////////////////////////////////////////////////////////////////////////////////
//// Public types
////////////////////////////////////////////////////////////////////////////////

/* An entity identifier. */
typedef uint64_t ecs_entity_t;

/* A vector containing component identifiers used to describe an entity type. */
typedef const ecs_vector_t* ecs_type_t;

/** System kinds that determine when and how systems are ran */
typedef enum EcsSystemKind {
    /* Periodic systems */
    EcsOnLoad,
    EcsPostLoad,
    EcsPreUpdate,
    EcsOnUpdate,
    EcsOnValidate,
    EcsPostUpdate,
    EcsPreStore,
    EcsOnStore,

    /* Manual systems */
    EcsManual,

    /* Reactive systems */
    EcsOnAdd,
    EcsOnRemove,
    EcsOnSet
} EcsSystemKind;

/** System action callback */
typedef void (*ecs_system_action_t)(
    ecs_rows_t *data);

/** Initialization function signature of modules */
typedef void (*ecs_module_init_action_t)(
    ecs_world_t *world,
    int flags);    

/** Types that describe a type filter.
 * Filters provide a quick mechanism to query entities or run operations on
 * entities of one or more types. Filters contain a components to include and
 * components to exclude. Additionally, a filter can specify whether all or any
 * of the components need to be matched, or whether it must be an exact match.
 *
 * When a filter contains only one component, Any and All are equivalent.
 *
 * Suppose an application has entities with the following types:
 * 1. [Position]
 * 2. [Position, Velocity]
 * 3. [Position, Velocity, Mass]
 *
 * And the following filters
 * A. include = [Position], All/Any
 * B. include = [Position], Exact
 * C. include = [Position, Velocity], All
 * D. include = [Position, Velocity], Any
 * E. exclude = [Position], All/Any
 * F. exclude = [Position, Velocity], Exact
 * G. include = [Position, Velocity], Exact
 *
 * Then these types would be matched like this:
 *     1   2   3
 * ---|---|---|---
 *  A | x | x | x
 *  B | x |   | 
 *  C |   | x | x
 *  D | x | x | x 
 *  E |   |   | 
 *  F | x |   | x 
 *  G |   | x | 
 *
 * When the kind is left to EcsMatchDefault, the include_kind will be set to
 * EcsMatchAll, while the exclude_kind will be set to EcsMatchAny.
 */
typedef enum ecs_match_kind_t {
    EcsMatchDefault = 0,
    EcsMatchAll,
    EcsMatchAny,
    EcsMatchExact
} ecs_match_kind_t;

typedef struct ecs_filter_t {
    ecs_type_t include;
    ecs_type_t exclude;
    ecs_match_kind_t include_kind;
    ecs_match_kind_t exclude_kind;
} ecs_filter_t;

/** The ecs_rows_t struct passes data from a system to a system callback.  */
struct ecs_rows_t {
    ecs_world_t *world;          /* Current world */
    ecs_entity_t system;         /* Handle to current system */

    int32_t *columns;    /* Indices mapping system params to columns and refs */
    uint16_t column_count;       /* Number of columns for system */
    void *table;                 /* Opaque structure with reference to table */
    void *table_columns;         /* Opaque structure with table column data */
    void *system_data;           /* Opaque strucutre with system internals */
    ecs_reference_t *references; /* References to other entities */
    ecs_entity_t *components;    /* System-table specific list of components */
    ecs_entity_t *entities;      /* Entity row */

    void *param;                 /* Userdata passed to on-demand system */
    float delta_time;            /* Time elapsed since last frame */
    float world_time;            /* Time elapsed since start of simulation */
    uint32_t frame_offset;       /* Offset relative to frame */
    uint32_t table_offset;       /* Current active table being processed */
    uint32_t offset;             /* Offset relative to current table */
    uint32_t count;              /* Number of rows to process by system */

    ecs_entity_t interrupted_by; /* When set, system execution is interrupted */
};


////////////////////////////////////////////////////////////////////////////////
//// Public builtin components
////////////////////////////////////////////////////////////////////////////////

/** Component that contains an entity name */
typedef const char *EcsId;

/** Component that contains metadata about a component */
typedef struct EcsComponent {
    uint32_t size;
} EcsComponent;

/** Metadata of an explicitly created type (ECS_TYPE or ecs_new_type) */
typedef struct EcsTypeComponent {
    ecs_type_t type;    /* Preserved nested types */
    ecs_type_t resolved;  /* Resolved nested types */
} EcsTypeComponent;

/** Component used to create prefabs and prefab hierarchies */
typedef struct EcsPrefab {
    ecs_entity_t parent;
} EcsPrefab;

#include <flecs/util/api_support.h>


////////////////////////////////////////////////////////////////////////////////
//// Public constants
////////////////////////////////////////////////////////////////////////////////

/* Type masks used for marking entities as base or parent */
#define ECS_INSTANCEOF ((ecs_entity_t)1 << 63)
#define ECS_CHILDOF ((ecs_entity_t)1 << 62) 

/** Type handles to builtin components */
FLECS_EXPORT
extern ecs_type_t 
    TEcsComponent,
    TEcsTypeComponent,
    TEcsPrefab,
    TEcsPrefabParent,
    TEcsPrefabBuilder,
    TEcsRowSystem,
    TEcsColSystem,
    TEcsId,
    TEcsHidden,
    TEcsDisabled,
    TEcsOnDemand;

/** Handles to builtin components */
#define EEcsComponent (1)
#define EEcsTypeComponent (2)
#define EEcsPrefab (3)
#define EEcsPrefabParent (4)
#define EEcsPrefabBuilder (5)
#define EEcsRowSystem (6)
#define EEcsColSystem (7)
#define EEcsId (8)
#define EEcsHidden (9)
#define EEcsDisabled (10)
#define EEcsOnDemand (11)

/** Builtin entity ids */
#define EcsWorld (13)
#define EcsSingleton (ECS_SINGLETON)
#define EcsInvalid (ECS_INVALID_ENTITY)

/** Value used to quickly check if component is builtin */
#define EcsLastBuiltin (EEcsColSystem)

/** This allows passing 0 as type to functions that accept types */
#define T0 (0)


////////////////////////////////////////////////////////////////////////////////
//// Declarative macro's
////////////////////////////////////////////////////////////////////////////////

#ifndef __BAKE_LEGACY__

/** Declare a named entity.
 * This macro will declare a new entity with the provided id and components. The
 * components are specified as a comma-separated list of identifiers, optionally
 * with type flags. The order in which components are specified does not matter.
 *
 * Examples:
 * ECS_ENTITY(world, MyEntity, Position, Velocity);
 * ECS_ENTITY(world, MyEntity 0);
 * ECS_ENTITY(world, MyEntity, Position, Velocity, CHILDOF | MyParentEntity);
 */ 
#define ECS_ENTITY(world, id, ...)\
    ecs_entity_t id = ecs_new_entity(world, #id, #__VA_ARGS__);\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, id);\
    (void)id;\
    (void)ecs_type(id);

/** Declare a prefab.
 * This macro will declare a new prefab with the provided id and components. The
 * order in which components are specified does not matter. A prefab is similar 
 * to an entity except that prefabs are typically used in combination with 
 * INSTANCEOF to serve as entity templates. Prefabs are by default not matched 
 * with systems.
 *
 * Examples:
 * ECS_PREFAB(world, MyPrefab, Position, Velocity);
 * ECS_PREFAB(world, MyPrefab, 0);
 * ECS_PREFAB(world, MyPrefab, Position, Velocity, INSTANCEOF | MyBasePrefab);
 *
 * Prefabs can be used with ECS_ENTITY:
 * ECS_ENTITY(world, MyEntity, Position, Velocity, INSTANCEOF | MyPrefab);
 */
#define ECS_PREFAB(world, id, ...) \
    ecs_entity_t id = ecs_new_prefab(world, #id, #__VA_ARGS__);\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, id);\
    (void)id;\
    (void)ecs_type(id);\

/** Declare a component.
 * This macro declares a new component with the provided type. The type must be 
 * a valid C type or typedef. A type must first be registered as a component 
 * before it can be added to entities.
 *
 * Example:
 * ECS_COMPONENT(world, Position);
 * 
 * Components can be used with ECS_ENTITY:
 * ECS_ENTITY(world, MyEntity, Position);
 */
#define ECS_COMPONENT(world, id) \
    ECS_ENTITY_VAR(id) = ecs_new_component(world, #id, sizeof(id));\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, ecs_entity(id));\
    (void)ecs_entity(id);\
    (void)ecs_type(id);\

/** Declare a tag. 
 * This macro declares a tag with the provided id. Tags are the similar to 
 * components in that they can be added to an entity, but have no C type 
 * associated with them. 
 *
 * Example:
 * ECS_TAG(world, MyTag);
 * 
 * Components can be used with ECS_ENTITY:
 * ECS_ENTITY(world, MyEntity, MyTag);
 */
#define ECS_TAG(world, id) \
    ecs_entity_t id = ecs_new_component(world, #id, 0);\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, id);\
    (void)id;\
    (void)ecs_type(id);\

/** Declare a type.
 * This macro declares a type with the provided id and components. Types are
 * similar to components in that they can be added to an entity, but instead of
 * adding just one component, a type can add multiple components at once.
 * 
 * The components are specified as a comma-separated list of identifiers,
 * optionally with type flags.
 *
 * Examples:
 * ECS_ENTITY(world, MyType, Position, Velocity);
 * ECS_ENTITY(world, MyType 0);
 * ECS_ENTITY(world, MyType, Position, Velocity, CHILDOF | MyParentEntity);
 *
 * Types can be used in combination with ECS_ENTITY like this:
 *
 * ECS_ENTITY(world, MyEntity, Position, MyType);
 */
#define ECS_TYPE(world, id, ...) \
    ecs_entity_t id = ecs_new_type(world, #id, #__VA_ARGS__);\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, id);\
    (void)id;\
    (void)ecs_type(id);\

/** Declare a systen.
 * This macro declares a system with the specified function, kind and signature. 
 * Systems are matched with entities that match the system signature. The system
 * signature is specified as a comma-separated list of column expressions, where
 * a column expression can be any of the following: 
 *
 * - A simple component identifier ('Position')
 * - An OR expression ('Position | Velocity')
 * - An optional expression ('?Position')
 * - A NOT expression ('!Position')
 * - An OWNED expression ('OWNED.Position')
 * - A SHARED expression ('SHARED.Position')
 * - A CONTAINER expression ('CONTAINER.Position')
 * - A CASCADE expression ('CASCADE.Position')
 * - An entity expression ('MyEntity.Position')
 * - An empty expression ('.Position')
 * 
 * The systen kind specifies the phase in which the system is ran.
 *
 * Examples:
 * ECS_SYSTEM(world, Move, EcsOnUpdate, Position, Velocity, !AngularVelocity);
 * ECS_SYSTEM(world, Transform, EcsPostUpdate, CONTAINER.Transform, Transform);
 *
 * In these examples, 'Move' and 'Transform' must be valid identifiers to a C
 * function of the following signature:
 *
 * void Move(ecs_rows_t *rows) { ... }
 *
 * Inside this function the system can access the data from the signature with
 * the ECS_COLUMN macro:
 *
 * ECS_COLUMN(rows, Position, p, 1);
 * ECS_COLUMN(rows, Velocity, v, 2);
 *
 * For more details on system signatures and phases see the Flecs manual.
 */
#define ECS_SYSTEM(world, id, kind, ...) \
    ecs_entity_t F##id = ecs_new_system(world, #id, kind, #__VA_ARGS__, id);\
    ecs_entity_t id = F##id;\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, id);\
    (void)id;\
    (void)ecs_type(id);

#endif

////////////////////////////////////////////////////////////////////////////////
//// World API
////////////////////////////////////////////////////////////////////////////////

/** Create a new world.
 * A world manages all the ECS objects. Applications must have at least one
 * world. Entities, component and system handles are local to a world and
 * cannot be shared between worlds.
 *
 * @return A new world object
 */
FLECS_EXPORT
ecs_world_t* ecs_init(void);

/** Create a new world with arguments.
 * Same as ecs_init, but allows passing in command line arguments. These can be
 * used to dynamically enable flecs features to an application, like performance
 * monitoring or the web dashboard (if it is installed) without having to modify
 * the code of an application.
 * 
 * If the functionality requested by the arguments is not available, an error
 * message will be printed to stderr, but the function will not fail. Thus it is
 * important that the application code does not rely on any functionality that
 * is realized through the arguments.
 * 
 * If the arguments specify a setting that is explicity set as well by the
 * application, the application setting will be ignored. For example, if an
 * application specifies it will run on 2 threads, but an argument specify it
 * will run on 6 threads, the argument will take precedence.
 * 
 * The following options are available:
 * --threads [n]   Use n worker threads
 * --fps [hz]      Run at hz FPS
 * --admin [port]  Enable admin dashboard (requires flecs-systems-admin & flecs-systems-civetweb)
 * --console       Enables console (requires flecs-systems-console)
 * --debug         Enables debug tracing
 *
 * @return A new world object
 */
FLECS_EXPORT
ecs_world_t* ecs_init_w_args(
    int argc,
    char *argv[]);

/** Delete a world.
 * This operation deletes the world, and all entities, components and systems
 * within the world.
 *
 * @param world The world to delete.
 */
FLECS_EXPORT
int ecs_fini(
    ecs_world_t *world);

/** Signal exit
 * This operation signals that the application should quit. It will cause
 * ecs_progress to return false.
 *
 * @param world The world to quit.
 */
FLECS_EXPORT
void ecs_quit(
    ecs_world_t *world);

/** Progress a world.
 * This operation progresses the world by running all systems that are both
 * enabled and periodic on their matching entities.
 *
 * An application can pass a delta_time into the function, which is the time
 * passed since the last frame. This value is passed to systems so they can
 * update entity values proportional to the elapsed time since their last
 * invocation.
 *
 * When an application passes 0 to delta_time, ecs_progress will automatically
 * measure the time passed since the last frame. If an application does not uses
 * time management, it should pass a non-zero value for delta_time (1.0 is
 * recommended). That way, no time will be wasted measuring the time.
 *
 * @param world The world to progress.
 * @param delta_time The time passed since the last frame.
 */
FLECS_EXPORT
bool ecs_progress(
    ecs_world_t *world,
    float delta_time);

/** Set target frames per second (FPS) for application.
 * Setting the target FPS ensures that ecs_progress is not invoked faster than
 * the specified FPS. When enabled, ecs_progress tracks the time passed since
 * the last invocation, and sleeps the remaining time of the frame (if any).
 *
 * This feature ensures systems are ran at a consistent interval, as well as
 * conserving CPU time by not running systems more often than required.
 *
 * Note that ecs_progress only sleeps if there is time left in the frame. Both
 * time spent in flecs as time spent outside of flecs are taken into
 * account.
 *
 * @param world The world.
 * @param fps The target FPS.
 */
FLECS_EXPORT
void ecs_set_target_fps(
    ecs_world_t *world,
    float fps);

/** Get configured target frames per second.
 * This operation returns the FPS set with ecs_set_target_fps.
 * 
 * @param world The world.
 * @param return The current target FPS.
 */
FLECS_EXPORT
uint32_t ecs_get_target_fps(
    ecs_world_t *world);   

/** Get last delta time from world.
 * This operation returns the delta_time used in the last frame. If a non-zero
 * value was provided to ecs_progress then this value is returned, otherwise the
 * time measured by ecs_progress is returned.
 *
 * @param world The world.
 * @return The last used delta_time.
 */
FLECS_EXPORT
float ecs_get_delta_time(
    ecs_world_t *world);

/** Set a world context.
 * This operation allows an application to register custom data with a world
 * that can be accessed anywhere where the application has the world object.
 *
 * A typical usecase is to register a struct with handles to the application
 * entities, components and systems.
 *
 * @param world The world.
 * @param ctx A pointer to a user defined structure.
 */
FLECS_EXPORT
void ecs_set_context(
    ecs_world_t *world,
    void *ctx);

/** Get the world context.
 * This operation retrieves a previously set world context.
 *
 * @param world The world.
 * @return The context set with ecs_set_context. If no context was set, the
 *          function returns NULL.
 */
FLECS_EXPORT
void* ecs_get_context(
    ecs_world_t *world);

/** Get the world tick.
 * This operation retrieves the tick count (frame number). The tick count is 0
 * when ecs_process is called for the first time, and increases by one for every
 * subsequent call.
 *
 * @param world The world.
 * @return The current tick.
 */
FLECS_EXPORT
uint32_t ecs_get_tick(
    ecs_world_t *world);

/** Dimension the world for a specified number of entities.
 * This operation will preallocate memory in the world for the specified number
 * of entities. Specifying a number lower than the current number of entities in
 * the world will have no effect.
 *
 * When using this operation, note that flecs uses entities for storing
 * systems, components and builtin components. For an exact calculation of
 * entities, do user_entity_count + component_count + system_count + 3. The 3
 * stands for the number of builtin components.
 *
 * Note that this operation does not allocate memory in tables. To preallocate
 * memory in a table, use ecs_dim_type. Correctly using these functions
 * prevents flecs from doing dynamic memory allocations in the main loop.
 *
 * @param world The world.
 * @param entity_count The number of entities to preallocate.
 */
FLECS_EXPORT
void ecs_dim(
    ecs_world_t *world,
    uint32_t entity_count);

/** Dimension a type for a specified number of entities.
 * This operation will preallocate memory for a type (table) for the
 * specified number of entites. Specifying a number lower than the current
 * number of entities in the table will have no effect.
 *
 * If no table exists yet for this type (when no entities have been committed
 * for the type) it will be created, even if the entity_count is zero. This
 * operation can thus also be used to just preallocate empty tables.
 *
 * If the specified type is unknown, the behavior of this function is
 * unspecified. To ensure that the type exists, use ecs_type_get or
 * ECS_TYPE.
 *
 * @param world The world.
 * @param type Handle to the type, as obtained by ecs_type_get.
 * @param entity_count The number of entities to preallocate.
 */
FLECS_EXPORT
void _ecs_dim_type(
    ecs_world_t *world,
    ecs_type_t type,
    uint32_t entity_count);

#define ecs_dim_type(world, type, entity_count)\
    _ecs_dim_type(world, T##type, entity_count)

/** Set a range for issueing new entity ids.
 * This function constrains the entity identifiers returned by ecs_new to the 
 * specified range. This operation can be used to ensure that multiple processes
 * can run in the same simulation without requiring a central service that
 * coordinates issueing identifiers.
 * 
 * If id_end is set to 0, the range is infinite. If id_end is set to a non-zero
 * value, it has to be larger than id_start. If id_end is set and ecs_new is
 * invoked after an id is issued that is equal to id_end, the application will
 * abort. Flecs does not automatically recycle ids.
 * 
 * The id_end parameter has to be smaller than the last issued identifier.
 * 
 * @param world The world.
 * @param id_start The start of the range.
 * @param id_end The end of the range.
 */
FLECS_EXPORT
void ecs_set_entity_range(
    ecs_world_t *world,
    ecs_entity_t id_start,
    ecs_entity_t id_end);

/** Temporarily enable/disable range limits.
 * When an application is both a receiver of range-limited entities and a
 * producer of range-limited entities, range checking needs to be temporarily
 * disabled when receiving entities.
 * 
 * Range checking is disabled on a stage, so setting this value is thread safe.
 */
FLECS_EXPORT
bool ecs_enable_range_check(
    ecs_world_t *world,
    bool enable);


////////////////////////////////////////////////////////////////////////////////
//// Entity API
////////////////////////////////////////////////////////////////////////////////

/** Create a new entity.
 * Entities are light-weight objects that represent "things" in the application.
 * Entities themselves do not have any state or logic, but instead are composed
 * out of a set of zero or more stateful components.
 *
 * Entities can be assigned a type at creation time, which specifies zero or
 * more components that the entity will be created with. Applications can either
 * specify single components (created with ECS_COMPONENT) or types (created with 
 * ECS_TYPE) to this function.
 *
 * @param world The world to which to add the entity.
 * @param type Zero if no type, or handle to a component, type or prefab.
 * @return A handle to the new entity.
 */
FLECS_EXPORT
ecs_entity_t _ecs_new(
    ecs_world_t *world,
    ecs_type_t type);

#define ecs_new(world, type)\
    _ecs_new(world, T##type)

/** Create new entities in a batch.
 * This operation creates the number of specified entities with one API call
 * which is a more efficient alternative to repeatedly calling ecs_new.
 *
 * The created entity identifiers will always be a contiguous list of integers.
 *
 * @param world The world.
 * @param type Zero if no type, or handle to a component, type or prefab.
 * @param count The number of entities to create.
 * @return The first created entity.
 */
FLECS_EXPORT
ecs_entity_t _ecs_new_w_count(
    ecs_world_t *world,
    ecs_type_t type,
    uint32_t count);

#define ecs_new_w_count(world, type, count)\
    _ecs_new_w_count(world, T##type, count)

typedef void* ecs_table_columns_t;

typedef struct ecs_table_data_t {
    uint32_t row_count;
    uint32_t column_count;
    ecs_entity_t *entities;
    ecs_entity_t *components;
    ecs_table_columns_t *columns;
} ecs_table_data_t;

/** Insert data in bulk.
 * This operation allows applications to insert data in bulk by providing the
 * entity and component data as arrays. The data is passed in using the
 * ecs_table_data_t type, which has to be populated with the data that has to be
 * inserted.
 * 
 * The application must at least provide the row_count, column_count and 
 * components fields. The latter is an array of component identifiers that
 * identifies the components to be added to the entitiy.
 *
 * The entities array must be populated with the entity identifiers to set. If
 * this field is left NULL, Flecs will create row_count new entities.
 *
 * The component data must be provided in the columns field. This is an array of
 * component arrays. The component arrays must be provided in the same order as
 * the components have been provided in the components array. For example, if
 * the components array is set to {ecs_entity(Position), ecs_entity(Velocity)},
 * the columns must first specify the Position, and then the Velocity array. If
 * no component data is provided, the components will be left uninitialized.
 *
 * Both the entities array and the component data arrays in columns must contain
 * exactly row_count elements. The columns array must contain exactly 
 * column_count elements.
 *
 * The operation allows for efficient insertion of data for the same set of
 * entities, provided that the entities are specified in the same order for
 * every invocation of this function. After executing this operation, entities
 * will be ordered in the same order specified in the entities array.
 *
 * If entities already exist in another table, they will be deleted from that
 * table and inserted into the new table. 
 */
FLECS_EXPORT
ecs_entity_t ecs_set_w_data(
    ecs_world_t *world,
    ecs_table_data_t *data);

/** Create a new child entity.
 * Child entities are equivalent to normal entities, but can additionally be 
 * created with a container entity. Container entities allow for the creation of
 * entity hierarchies.
 * 
 * This function is equivalent to calling ecs_new with a type that combines both
 * the type specified in this function and the type id for the container.
 *
 * @param world The world.
 * @param parent The container to which to add the child entity.
 * @param type The type with which to create the child entity.
 * @return The created entity.
 */
FLECS_EXPORT
ecs_entity_t _ecs_new_child(
    ecs_world_t *world,
    ecs_entity_t parent,
    ecs_type_t type);

#define ecs_new_child(world, parent, type)\
    _ecs_new_child(world, parent, T##type)

/* Create new child entities in batch.
 * This operation is similar to ecs_new_w_count, with as only difference that
 * the parent is added to the type of the new entities.
 *
 * @param world The world.
 * @param parent The parent.
 * @param type The type to create the new entities with.
 * @param count The number of entities to create.
 * @return The first created entity.
 */
FLECS_EXPORT
ecs_entity_t _ecs_new_child_w_count(
    ecs_world_t *world,
    ecs_entity_t parent,
    ecs_type_t type,
    uint32_t count);

#define ecs_new_child_w_count(world, parent, type, count)\
    _ecs_new_child_w_count(world, parent, T##type, count)

/** Instantiate entity from a base entity.
 * This operation returns a new entity that shares components with the provided 
 * base entity.
 * 
 * @param world The world.
 * @param base The base entity.
 * @return The created entity.
 */
FLECS_EXPORT
ecs_entity_t _ecs_new_instance(
    ecs_world_t *world,
    ecs_entity_t base,
    ecs_type_t type);

#define ecs_new_instance(world, base, type)\
    _ecs_new_instance(world, base, T##type)

/** Instantiate entities from a base entity in batch.
 * This operation returns a specified number of new entities that share 
 * components with the provided base entity.
 * 
 * @param world The world.
 * @param base The base entity.
 * @param count The number of entities to create.
 * @return The first created entity.
 */
FLECS_EXPORT
ecs_entity_t _ecs_new_instance_w_count(
    ecs_world_t *world,
    ecs_entity_t base,
    ecs_type_t type,
    uint32_t count);

#define ecs_new_instance_w_count(world, base, type, count)\
    _ecs_new_instance_w_count(world, base, T##type, count)

/** Create new entity with same components as specified entity.
 * This operation creates a new entity which has the same components as the
 * specified entity. This includes prefabs and entity-components (entities to
 * which the EcsComponent component has been added manually).
 *
 * The application can optionally copy the values of the specified entity by
 * passing true to copy_value. In that case, the resulting entity will have the
 * same value as source specified entity.
 *
 * @param world The world.
 * @param entity The source entity.
 * @param copy_value Whether to copy the value from the source entity.
 * @return The new entity.
 */
FLECS_EXPORT
ecs_entity_t ecs_clone(
    ecs_world_t *world,
    ecs_entity_t entity,
    bool copy_value);

/** Delete components of an entity.
 * This operation will delete all components from the specified entity.
 *
 * When the delete operation is invoked upon an already deleted entity, the
 * operation will have no effect, as it will attempt to delete components from
 * an already empty entity.
 *
 * As a result of a delete operation, EcsOnRemove systems will be invoked if
 * applicable for any of the removed components.
 *
 * @param world The world.
 * @param entity The entity to empty.
 */
FLECS_EXPORT
void ecs_delete(
    ecs_world_t *world,
    ecs_entity_t entity);

/** Delete all entities containing a (set of) component(s). 
 * This operation provides a more efficient alternative to deleting entities one
 * by one by deleting an entire table or set of tables in a single operation.
 * The operation will clear all tables that match the specified table.
 *
 * As a result of a delete operation, EcsOnRemove systems will be invoked if
 * applicable for any of the removed components. 
 * 
 * @param world The world.
 * @param filter Filter that matches zero or more tables.
 */
FLECS_EXPORT
void ecs_delete_w_filter(
    ecs_world_t *world,
    const ecs_filter_t *filter);

/** Add a type to an entity.
 * This operation will add one or more components (as per the specified type) to
 * an entity. If the entity already contains a subset of the components in the
 * type, only components that are not contained by the entity will be added. If
 * the entity already contains all components, this operation has no effect.
 *
 * As a result of an add operation, EcsOnAdd systems will be invoked if
 * applicable for any of the added components.
 *
 * @param world The world.
 * @param entity The entity to which to add the type.
 * @param type The type to add to the entity.
 */
FLECS_EXPORT
void _ecs_add(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

#define ecs_add(world, entity, type)\
    _ecs_add(world, entity, T##type)

/** Add single entity to entity */
FLECS_EXPORT
void ecs_add_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t to_add);

/** Remove a type from an entity.
 * This operation will remove one or more components (as per the specified type)
 * from an entity. If the entity contained a subset of the components in the
 * type, only that subset will be removed. If the entity contains none of the
 * components in the type, the operation has no effect.
 *
 * As a result of a remove operation, EcsOnRemove systems will be invoked if
 * applicable for any of the removed components.
 *
 * @param world The world.
 * @param entity The entity from which to remove the type.
 * @param type The type to remove from the entity.
 */
FLECS_EXPORT
void _ecs_remove(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

#define ecs_remove(world, entity, type)\
    _ecs_remove(world, entity, T##type)

/** Add single entity to entity */
FLECS_EXPORT
void ecs_remove_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t to_remove);

/** Add and remove types from an entity.
 * This operation is a combination of ecs_add and ecs_remove. The operation
 * behaves as if the specified to_remove type is removed first, and 
 * subsequently the to_add type is added. This operation is more efficient than
 * adding/removing components separately with ecs_add/ecs_remove, as the entity
 * is moved between tables at most once.
 * 
 * @param world The world.
 * @param entity The entity from which to remove, and to which to add the types.
 * @param to_add The type to add to the entity.
 * @param to_remove The type to remove from the entity.
 */ 
FLECS_EXPORT
void _ecs_add_remove(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t to_add,
    ecs_type_t to_remove);

#define ecs_add_remove(world, entity, to_add, to_remove)\
    _ecs_add_remove(world, entity, T##to_add, T##to_remove)

/** Adopt a child entity by a parent.
 * This operation adds the specified parent entity to the type of the specified
 * entity, which effectively establishes a parent-child relationship. The parent
 * entity, when added, behaves like a normal component in that it becomes part
 * of the entity type.
 *
 * If the parent was already added to the entity, this operation will have no
 * effect.
 *
 * This operation is similar to an ecs_add, with as difference that instead of a 
 * type it accepts any entity handle.
 *
 * @param world The world.
 * @param entity The entity to adopt.
 * @param parent The parent entity to add to the entity.
 */
FLECS_EXPORT
void ecs_adopt(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t parent);

/** Orphan a child by a parent. 
 * This operation removes the specified parent entity from the type of the
 * specified entity. If the parent was not added to the entity, this operation
 * has no effect.
 *
 * This operation is similar to ecs_remove, with as difference that instead of a
 * type it accepts any entity handle.
 *
 * @param world The world.
 * @param entity The entity to orphan.
 * @param parent The parent entity to remove from the entity.
 */
FLECS_EXPORT
void ecs_orphan(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t parent);

/** Inherit from a base.
 * This operation adds a base to an entity, which will cause the entity to
 * inherit the components of the base. If the entity already inherited from the
 * specified base, this operation does nothing.
 * 
 * @param world The world.
 * @param entity The entity to add the base to.
 * @param base The base to add to the entity.
 */
FLECS_EXPORT
void ecs_inherit(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t base);

/** Disinherit from a base.
 * This operation removes a base from an entity, which will cause the entity to
 * no longer inherit the components of the base. If the entity did not inherit
 * from the specified base, this operation does nothing.
 * 
 * @param world The world.
 * @param entity The entity to remove the base from.
 * @param base The base to remove from the entity.
 */
FLECS_EXPORT
void ecs_disinherit(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t base);

/** Add/remove one or more components from a set of tables.
 * This operation adds/removes one or more components from a set of tables 
 * matching a filter. This operation is more efficient than calling ecs_add 
 * or ecs_remove on the individual entities.
 *
 * If no filter is provided, the component(s) will be added/removed from all the
 * tables in which it/they (not) occur(s).
 *
 * After this operation it is guaranteed that no tables matching the filter
 * will have the components in to_remove, and similarly, all will have the
 * components in to_add. If to_add or to_remove has multiple components
 * and only one of the components occurs in a table, that component will be
 * added/removed from the entities in the table.
 *
 * @param world The world.
 * @param to_add The components to add.
 * @param to_remove The components to remove.
 * @param filter Filter that matches zero or more tables.
 */
FLECS_EXPORT
void _ecs_add_remove_w_filter(
    ecs_world_t *world,
    ecs_type_t to_add,
    ecs_type_t to_remove,
    const ecs_filter_t *filter);

#define ecs_add_remove_w_filter(world, to_add, to_remove, filter)\
    _ecs_add_remove_w_filter(world, ecs_type(to_add), ecs_type(to_remove), filter)

/** Get pointer to component data.
 * This operation obtains a pointer to the component data of an entity. If the
 * component was not added for the specified entity, the operation will return
 * NULL.
 *
 * Note that the returned pointer has temporary validity. Operations such as
 * delete and add/remove may invalidate the pointer as data is potentially moved
 * to different locations. After one of these operations is invoked, the pointer
 * will have to be re-obtained.
 *
 * This function is wrapped by the ecs_get convenience macro, which can be
 * used like this:
 *
 * Foo value = ecs_get(world, e, Foo);
 *
 * @param world The world.
 * @param entity Handle to the entity from which to obtain the component data.
 * @param component The component to retrieve the data for.
 * @return A pointer to the data, or NULL of the component was not found.
 */
FLECS_EXPORT
void* _ecs_get_ptr(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

#define ecs_get_ptr(world, entity, type)\
    (type*)_ecs_get_ptr(world, entity, T##type)

#define ecs_get(world, entity, type)\
  (*(type*)_ecs_get_ptr(world, entity, T##type))

/* Set value of component.
 * This function sets the value of a component on the specified entity. If the
 * component does not yet exist, it will be added to the entity.
 *
 * This function can be used like this:
 * Foo value = {.x = 10, .y = 20};
 * ecs_set_ptr(world, e, ecs_type(Foo), &value);
 *
 * This function is wrapped by the ecs_set convenience macro, which can be used
 * like this:
 *
 * ecs_set(world, e, Foo, {.x = 10, .y = 20});
 *
 * @param world The world.
 * @param entity The entity on which to set the component.
 * @param component The component to set.
 */
FLECS_EXPORT
ecs_entity_t _ecs_set_ptr(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component,
    size_t size,
    const void *ptr);

#define ecs_set_ptr(world, entity, component, ptr)\
    _ecs_set_ptr(world, entity, ecs_entity(component), sizeof(component), ptr)

/* Conditionally skip macro's as compound literals are not supported in C89 */
#ifndef __BAKE_LEGACY__
#define ecs_set(world, entity, component, ...)\
    _ecs_set_ptr(world, entity, ecs_entity(component), sizeof(component), &(component)__VA_ARGS__)
#endif

/** Check if entity has the specified type.
 * This operation checks if the entity has the components associated with the
 * specified type. It accepts component handles, types and prefabs.
 *
 * For example, if an entity has component 'Foo' and a type has 'Foo, Bar'
 * invoking this function with the entity and type as type will return false
 * because the entity does not have 'Bar'. Invoking the entity with the 'Bar'
 * component, or a type that contains only 'Bar' will return true.
 *
 * @param world The world.
 * @param entity Handle to a entity.
 * @param type Handle to a component, type or prefab.
 * @return true if entity has type, otherwise false.
 */
FLECS_EXPORT
bool _ecs_has(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

#define ecs_has(world, entity, type)\
    _ecs_has(world, entity, T##type)

/** Same as ecs_has, but only returns true if entity owns the component(s). */
FLECS_EXPORT
bool _ecs_has_owned(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

#define ecs_has_owned(world, entity, type)\
    _ecs_has_owned(world, entity, T##type)

/** Check if entity has any of the components in the specified type.
 * This operation checks if the entity has any of the components associated with
 * the specified type. It accepts component handles, types and prefabs.
 *
 * For example, if an entity has component 'Foo' and a type has 'Foo, Bar'
 * invoking this function with the entity and type as type will return true
 * because the entity has one of the components.
 *
 * @param world The world.
 * @param entity Handle to a entity.
 * @param type Handle to a component, type or prefab.
 * @return true if entity has one of the components, otherwise false.
 */
FLECS_EXPORT
bool _ecs_has_any(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

#define ecs_has_any(world, entity, type)\
    _ecs_has_any(world, entity, T##type)

/** Same as ecs_has_any, but only returns true if entity owns the component(s). */
FLECS_EXPORT
bool _ecs_has_any_owned(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

#define ecs_has_any_owned(world, entity, type)\
    _ecs_has_any_owned(world, entity, T##type)

FLECS_EXPORT
bool ecs_has_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component);

FLECS_EXPORT
bool ecs_has_entity_owned(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component);    

/** Check if parent entity contains child entity.
 * This function tests if the specified parent entity has been added to the
 * specified child entity.
 *
 * This function is similar to ecs_has, with as difference that instead of a 
 * type it accepts a handle to any entity.
 *
 * @param world The world.
 * @param parent The parent.
 * @param child The child.
 * @return true if the parent contains the child, otherwise false.
 */
FLECS_EXPORT
bool ecs_contains(
    ecs_world_t *world,
    ecs_entity_t parent,
    ecs_entity_t child);

/** Return container for component.
 * This function allows the application to query for a container of the
 * specified entity that has the specified component. If there are multiple
 * containers with this component, the function will return the first one it
 * encounters.
 *
 * @param world The world.
 * @param entity The entity for which to resolve the container.
 * @param component The component which the resovled container should have.
 */
FLECS_EXPORT
ecs_entity_t _ecs_get_parent(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component);

#define ecs_get_parent(world, entity, component)\
    _ecs_get_parent(world, entity, ecs_entity(component))

/** Get type of entity.
 * This operation returns the entity type, which is a handle to the a list of
 * the current components an entity has.
 *
 * Note that this function is different from ecs_type_from_entity, which returns
 * a type which only contains the specified entity.
 *
 * This operation is mostly intended for debugging, as it is considered a bad
 * practice to rely on the type for logic, as the type changes when components
 * are added/removed to the entity.
 *
 * @param world The world.
 * @param entity The entity for which to obtain the type.
 * @return The type of the entity.
 */
FLECS_EXPORT
ecs_type_t ecs_get_type(
    ecs_world_t *world,
    ecs_entity_t entity);

/** Return the entity id.
 * This returns the string identifier of an entity, if the entity has the EcsId
 * component. By default, all component, type, system and prefab entities add
 * the EcsId component if they have been created with the ecs_new_* functions.
 *
 * If the entity does not contain the EcsId component, this function will return
 * NULL.
 *
 * @param world The world.
 * @param entity The entity for which to resolve the id.
 * @return The id of the entity.
 */
FLECS_EXPORT
const char* ecs_get_id(
    ecs_world_t *world,
    ecs_entity_t entity);

/** Returns number of entities that have a given type. 
 * This operation will count the number of entities that have all of the
 * components in the specified type.
 *
 * This operation will not reflect entities created/deleted when invoked while
 * iterating. To get a consistent count, the function should be invoked after
 * data from an iteration has been merged.
 *
 * @param world The world.
 * @param type The type used to match entities.
 */
FLECS_EXPORT
uint32_t _ecs_count(
    ecs_world_t *world,
    ecs_type_t type);

#define ecs_count(world, type) _ecs_count(world, ecs_type(type))

/** Lookup an entity by id.
 * This operation is a convenient way to lookup entities by string identifier
 * that have the EcsId component. It is recommended to cache the result of this
 * function, as the function must iterates over all entities and all components
 * in an entity.
 *
 * @param world The world.
 * @param id The id to lookup.
 * @return The entity handle if found, or 0 if not found.
 */
FLECS_EXPORT
ecs_entity_t ecs_lookup(
    ecs_world_t *world,
    const char *id);

/** Lookup child of parent by id.
 * This operation is the same as ecs_lookup, except for that it only searches
 * entities that are children of the specified parent.
 * 
 * This operation can also be used to only lookup entities with a certain
 * component, in the following way:
 * 
 * ecs_lookup_child(world, ecs_entity(Component), "child_id");
 * 
 * Here, 'Component' refers to the component (type) identifier.
 * 
 * @param world The world.
 * @param parent The parent.
 * @param id The id to lookup.
 * @return The entity handle if found, or 0 if not found.
 */
FLECS_EXPORT
ecs_entity_t ecs_lookup_child(
    ecs_world_t *world,
    ecs_entity_t parent,
    const char *id);


////////////////////////////////////////////////////////////////////////////////
//// Rows API
////////////////////////////////////////////////////////////////////////////////

/** Obtain column data. 
 * This function is to be used inside a system to obtain data from a column in
 * the system signature. The provided index corresponds with the index of the
 * element in the system signature, starting from one. For example, for the
 * following system signature:
 * 
 * Position, Velocity
 * 
 * Position is at index 1, and Velocity is at index 2.
 * 
 * This function is typically invoked through the `ECS_COLUMN` macro which
 * automates declaring a variable of the correct type in the scope of the system
 * function.
 * 
 * When a valid pointer is obtained, it can be used as an array with rows->count
 * elements if the column is owned by the entity being iterated over, or as a
 * pointer if the column is shared (see ecs_is_shared).
 * 
 * @param rows The rows parameter passed into the system.
 * @param index The index identifying the column in a system signature.
 * @return A pointer to the column data if index is valid, otherwise NULL.
 */
FLECS_EXPORT
void* _ecs_column(
    const ecs_rows_t *rows,
    size_t size,
    uint32_t column);

#define ecs_column(rows, type, column)\
    ((type*)_ecs_column(rows, sizeof(type), column))

/** Test if column is shared or not. 
 * The following signature shows an example of owned components and shared
 * components:
 * 
 * Position, CONTAINER.Velocity, MyEntity.Mass
 * 
 * Position is an owned component, while Velocity and Mass are shared 
 * components. While these kinds of relationships are expressed explicity in a
 * system signature, inheritance relationships are implicit. The above signature
 * matches both entities for which Position is owned as well as entities for
 * which Position appears in an entity that they inherit from.
 * 
 * If a system needs to support both cases, it needs to test whether the
 * component is shared or not. This test only needs to happen once per system
 * callback invocation, as all the entities being iterated over will either own
 * or not own the component.
 * 
 * @param rows The rows parameter passed into the system.
 * @param index The index identifying the column in a system signature.
 * @return true if the column is shared, false if it is owned.
 */
FLECS_EXPORT
bool ecs_is_shared(
    const ecs_rows_t *rows,
    uint32_t column);

/** Obtain a single field. 
 * This is an alternative method to ecs_column to access data in a system, which
 * accesses data from individual fields (one column per row). This method is
 * slower than iterating over a column array, but has the added benefit that it
 * automatically abstracts between shared components and owned components. 
 * 
 * This is particularly useful if a system is unaware whether a particular 
 * column is from a prefab, as a system does not explicitly state in an argument
 * expression whether prefabs should be matched with, thus it is possible that
 * a system receives both shared and non-shared data for the same column.
 * 
 * When a system uses fields, these differences will be transparent, and it is
 * therefore the method that provides the most flexibility with respect to the
 * kind of data the system can accept.
 */
FLECS_EXPORT
void *_ecs_field(
    const ecs_rows_t *rows,
    size_t size,
    uint32_t column,
    uint32_t row);

#define ecs_field(rows, type, column, row)\
    ((type*)_ecs_field(rows, sizeof(type), column, row))

/** Obtain the source of a column from inside a system.
 * This operation lets you obtain the entity from which the column data was
 * resolved. In most cases a component will come from the entities being
 * iterated over, but when using prefabs or containers, the component can be
 * shared between entities. For shared components, this function will return the
 * original entity on which the component is stored.
 * 
 * If a column is specified for which the component is stored on the entities
 * being iterated over, the operation will return 0, as the entity id in that
 * case depends on the row, not on the column. To obtain the entity ids for a
 * row, a system should access the entity column (column zero) like this:
 * 
 * ecs_entity_t *entities = ecs_column(rows, ecs_entity_t, 0);
 * 
 * @param rows Pointer to the rows object passed into the system callback.
 * @param index An index identifying the column for which to obtain the component.
 * @return The source entity for the column. 
 */
FLECS_EXPORT
ecs_entity_t ecs_column_source(
    const ecs_rows_t *rows,
    uint32_t column);

/** Obtain the component for a column inside a system.
 * This operation obtains the component handle for a column in the system. This
 * function wraps around the 'components' array in the ecs_rows_t type.
 * 
 * Note that since component identifiers are obtained from the same pool as
 * regular entities, the return type of this function is ecs_entity_t.
 * 
 * When a system contains an argument that is prefixed with 'ID', the resolved
 * entity will be accessible through this function as well.
 * 
 * Column indices for system arguments start from 1, where 0 is reserved for a
 * column that contains entity identifiers. Passing 0 to this function for the
 * column index will return 0.
 * 
 * @param rows Pointer to the rows object passed into the system callback.
 * @param index An index identifying the column for which to obtain the component.
 * @return The component for the specified column, or 0 if failed.
 */
FLECS_EXPORT
ecs_entity_t ecs_column_entity(
    const ecs_rows_t *rows,
    uint32_t column);

/** Obtain the type of a column from inside a system. 
 * This operation is equivalent to ecs_column_entity, except that it returns
 * a type, instead of an entity handle. Invoking this function is the same as
 * doing:
 * 
 * ecs_type_from_entity( ecs_column_entity(rows, index));
 * 
 * This function is wrapped in the following convenience macro which ensures
 * that the type variable is named so it can be used with functions like ecs_add
 * and ecs_set:
 * 
 * ECS_COLUMN_COMPONENT(rows, Position, 1);
 * 
 * After this macro you can invoke functions like ecs_set as you normally would:
 * 
 * ecs_set(world, e, Position, {10, 20});
 * 
 * @param rows Pointer to the rows object passed into the system callback.
 * @param index An index identifying the column for which to obtain the component.
 * @return The type for the specified column, or 0 if failed.
 */ 
FLECS_EXPORT
ecs_type_t ecs_column_type(
    const ecs_rows_t *rows,
    uint32_t column);

/** Is the column readonly.
 * This operation returns if the column is a readonly column. Readonly columns
 * are marked in the system signature with the [in] modifier. 
 * 
 * @param rows Pointer to the rows object passed into the system callback.
 * @param column An index identifying the column.
 * @return true if the column is readonly, false otherwise. */
FLECS_EXPORT
bool ecs_is_readonly(
    const ecs_rows_t *rows,
    uint32_t column);

/** Get type of table that system is currently iterating over. */
FLECS_EXPORT
ecs_type_t ecs_table_type(
    const ecs_rows_t *rows);

/** Get column using the table index. */
FLECS_EXPORT
void* ecs_table_column(
    const ecs_rows_t *rows,
    uint32_t column);

/** Get a strongly typed pointer to a column (owned or shared). */
#define ECS_COLUMN(rows, type, id, column)\
    type *id = ecs_column(rows, type, column)

/** Obtain a handle to the component of a column */
#define ECS_COLUMN_COMPONENT(rows, id, column)\
    ECS_ENTITY_VAR(id) = ecs_column_entity(rows, column);\
    ECS_TYPE_VAR(id) = ecs_column_type(rows, column);\
    (void)ecs_entity(id);\
    (void)ecs_type(id)

/** Obtain a handle to the entity of a column */
#define ECS_COLUMN_ENTITY(rows, id, column)\
    ecs_entity_t id = ecs_column_entity(rows, column);\
    ECS_TYPE_VAR(id) = ecs_column_type(rows, column);\
    (void)id;\
    (void)ecs_type(id)

/** Utility macro for importing all handles for a module from a system column */
#define ECS_IMPORT_COLUMN(rows, module, column) \
    module *M##module##_ptr = ecs_column(rows, module, column);\
    ecs_assert(M##module##_ptr != NULL, ECS_MODULE_UNDEFINED, #module);\
    ecs_assert(ecs_is_shared(rows, column), ECS_COLUMN_IS_NOT_SHARED, NULL);\
    module M##module = *M##module##_ptr;\
    module##ImportHandles(M##module)


////////////////////////////////////////////////////////////////////////////////
//// Filter iterator API
////////////////////////////////////////////////////////////////////////////////

typedef struct ecs_filter_iter_t {
    ecs_filter_t filter;
    ecs_chunked_t *tables;
    uint32_t index;
    ecs_rows_t rows;
} ecs_filter_iter_t;

/** Create iterator that matches world tables with specified filter.
 * This operation allows applications to query entities ad hoc with a filter. 
 * Combined with the ecs_filter_next function an application can iterate over a
 * set of tables that matches the provided filter, for which the ecs_filter_next
 * function will populate an ecs_rows_t object, which can be used to iterate the
 * entities in the table.
 * 
 * @param world The world.
 * @param filter The filter.
 * @return An iterator that can be used with ecs_filter_next.
 */
FLECS_EXPORT
ecs_filter_iter_t ecs_filter_iter(
    ecs_world_t *world,
    const ecs_filter_t *filter);

/** Same as ecs_filter_iter, but for iterating snapshots tables. */
FLECS_EXPORT
ecs_filter_iter_t ecs_snapshot_filter_iter(
    ecs_world_t *world,
    const ecs_snapshot_t *snapshot,
    const ecs_filter_t *filter);    

/** Iterate tables matched by filter.
 * This operation can be called repeatedly for an iterator until it returns
 * false, in which case there are no more tables that matched the filter.
 *
 * When the operation returns true, the contents of the table can be accessed
 * through the "rows" member of the iterator, which is of type ecs_rows_t. To
 * get the component data, an application has to first obtain the table type
 * with ecs_table_type(iter.rows). This type contains the ordered list of
 * components stored in the table.
 *
 * An application can then obtain a specific component by first retrieving the
 * index of the component in the table type with column = 
 * ecs_type_index_of(table_type, Component), followed by 
 * ecs_table_column(rows, column) to obtain a pointer to the component array.
 * 
 * @param iter The iterator.
 */
FLECS_EXPORT
bool ecs_filter_next(
    ecs_filter_iter_t *iter);


////////////////////////////////////////////////////////////////////////////////
//// System API
////////////////////////////////////////////////////////////////////////////////

/** Enable or disable a system.
 * This operation enables or disables a system. A disabled system will not be
 * ran during ecs_progress or when components must be initialized or
 * deinitialized. Systems are enabled by default.
 *
 * This operation expects a valid system handle, or in other words, an entity
 * with the EcsSystem component. If a handle to an entity is provided that does
 * not have this component, the operation will fail.
 *
 * @param world The world.
 * @param system The system to enable or disable.
 * @param enabled true to enable the system, false to disable the system.
 * @return 0 if succeeded, -1 if the operation failed.
 */
FLECS_EXPORT
void ecs_enable(
    ecs_world_t *world,
    ecs_entity_t system,
    bool enabled);

/** Configure how often a system should be invoked.
 * This operation lets an application control how often a system should be
 * invoked. The provided period is the minimum interval between two invocations.
 *
 * Correct operation of this feature relies on an application providing a
 * delta_time value to ecs_progress. Once the delta_time exceeds the period that
 * is specified for a system, ecs_progress will invoke it.
 *
 * This operation is only valid on EcsPeriodic systems. If it is invoked on
 * handles of other systems or entities it will be ignored. An application may
 * only set the period outside ecs_progress.
 *
 * Note that a system will never be invoked more often than ecs_progress is
 * invoked. If the specified period is smaller than the interval at which
 * ecs_progress is invoked, the system will be invoked at every ecs_progress,
 * provided that the delta_time provided to ecs_progress is accurate.
 *
 * @param world The world.
 * @param system The system for which to set the period.
 * @param period The period.
 */
FLECS_EXPORT
void ecs_set_period(
    ecs_world_t *world,
    ecs_entity_t system,
    float period);

/** Returns the enabled status for a system / entity.
 * This operation will return whether a system is enabled or disabled. Currently
 * only systems can be enabled or disabled, but this operation does not fail
 * when a handle to an entity is provided that is not a system. If this
 * operation is called on a non-system entity, the operation will return true.
 *
 * @param world The world.
 * @param system The system to check.
 * @return True if the system is enabled, false if the system is disabled.
 */
FLECS_EXPORT
bool ecs_is_enabled(
    ecs_world_t *world,
    ecs_entity_t system);

/** Run a specific system manually.
 * This operation runs a single system manually. It is an efficient way to
 * invoke logic on a set of entities, as manual systems are only matched to
 * tables at creation time or after creation time, when a new table is created.
 *
 * Manual systems are useful to evaluate lists of prematched entities at
 * application defined times. Because none of the matching logic is evaluated
 * before the system is invoked, manual systems are much more efficient than
 * manually obtaining a list of entities and retrieving their components.
 *
 * An application may pass custom data to a system through the param parameter.
 * This data can be accessed by the system through the param member in the
 * ecs_rows_t value that is passed to the system callback.
 *
 * Any system may interrupt execution by setting the interrupted_by member in
 * the ecs_rows_t value. This is particularly useful for manual systems, where
 * the value of interrupted_by is returned by this operation. This, in
 * cominbation with the param argument lets applications use manual systems
 * to lookup entities: once the entity has been found its handle is passed to
 * interrupted_by, which is then subsequently returned.
 *
 * @param world The world.
 * @param system The system to run.
 * @param delta_time: The time passed since the last system invocation.
 * @param param A user-defined parameter to pass to the system.
 * @return handle to last evaluated entity if system was interrupted.
 */
FLECS_EXPORT
ecs_entity_t ecs_run(
    ecs_world_t *world,
    ecs_entity_t system,
    float delta_time,
    void *param);

/** Run system with offset/limit and type filter.
 * This operation is the same as ecs_run, but filters the entities that will be
 * iterated by the system.
 * 
 * Entities can be filtered in two ways. Offset and limit control the range of
 * entities that is iterated over. The range is applied to all entities matched
 * with the system, thus may cover multiple archetypes.
 * 
 * The type filter controls which entity types the system will evaluate. Only
 * types that contain all components in the type filter will be iterated over. A
 * type filter is only evaluated once per table, which makes filtering cheap if
 * the number of entities is large and the number of tables is small, but not as
 * cheap as filtering in the system signature.
 * 
 * @param world The world.
 * @param system The system to invoke.
 * @param delta_time: The time passed since the last system invocation.
 * @param filter A component or type to filter matched entities.
 * @param param A user-defined parameter to pass to the system.
 * @return handle to last evaluated entity if system was interrupted.
 */
FLECS_EXPORT
ecs_entity_t _ecs_run_w_filter(
    ecs_world_t *world,
    ecs_entity_t system,
    float delta_time,
    uint32_t offset,
    uint32_t limit,
    ecs_type_t filter,
    void *param);

#define ecs_run_w_filter(world, system, delta_time, offset, limit, type, param)\
    _ecs_run_w_filter(world, system, delta_time, offset, limit, T##type, param)

/** Set system context.
 * This operation allows an application to register custom data with a system.
 * This data can be accessed using the ecs_get_system_context operation, or
 * through the 'param' field in the ecs_rows_t parameter passed into the system
 * callback.
 *
 * @param world The world.
 * @param system The system on which to set the context.
 * @param ctx A pointer to a user defined structure.
 */
FLECS_EXPORT
void ecs_set_system_context(
    ecs_world_t *world,
    ecs_entity_t system,
    const void *ctx);

/** Get system context.
 * Get custom data from a system previously set with ecs_set_system_context.
 *
 * @param world The world.
 * @param system The system of which to obtain the context.
 * @return The system context.
 */
FLECS_EXPORT
void* ecs_get_system_context(
    ecs_world_t *world,
    ecs_entity_t system);

/** System status change callback */
typedef enum ecs_system_status_t {
    EcsSystemStatusNone = 0,
    EcsSystemEnabled,
    EcsSystemDisabled,
    EcsSystemActivated,
    EcsSystemDeactivated
} ecs_system_status_t;

typedef void (*ecs_system_status_action_t)(
    ecs_world_t *world,
    ecs_entity_t system,
    ecs_system_status_t status,
    void *ctx);

/** Set system status action.
 * The status action is invoked whenever a system is enabled or disabled. Note
 * that a system may be enabled but may not actually match any entities. In this
 * case the system is enabled but not _active_.
 *
 * In addition to communicating the enabled / disabled status, the action also
 * communicates changes in the activation status of the system. A system becomes
 * active when it has one or more matching entities, and becomes inactive when
 * it no longer matches any entities.
 * 
 * A system switches between enabled and disabled when an application invokes the
 * ecs_enable operation with a state different from the state of the system, for
 * example the system is disabled, and ecs_enable is invoked with enabled: true.
 *
 * Additionally a system may switch between enabled and disabled when it is an
 * EcsOnDemand system, and interest is generated or lost for one of its [out]
 * columns.
 *
 * @param world The world.
 * @param system The system for which to set the action.
 * @param action The action.
 * @param ctx Context that will be passed to the action when invoked.
 */
FLECS_EXPORT
void ecs_set_system_status_action(
    ecs_world_t *world,
    ecs_entity_t system,
    ecs_system_status_action_t action,
    const void *ctx);


////////////////////////////////////////////////////////////////////////////////
//// Snapshot API
////////////////////////////////////////////////////////////////////////////////

/** Create a snapshot.
 * This operation makes a copy of all component in the world that matches the 
 * specified filter.
 *
 * @param world The world to snapshot.
 * @param filter A filter that specifies which components to snapshot.
 * @param return The snapshot.
 */
FLECS_EXPORT
ecs_snapshot_t* ecs_snapshot_take(
    ecs_world_t *world,
    const ecs_filter_t *filter);

/** Restore a snapshot.
 * This operation restores the world to the state it was in when the specified
 * snapshot was taken. A snapshot can only be used once for restoring, as its
 * data replaces the data that is currently in the world.
 * This operation also resets the last issued entity handle, so any calls to
 * ecs_new may return entity ids that have been issued before restoring the 
 * snapshot.
 *
 * The world in which the snapshot is restored must be the same as the world in
 * which the snapshot is taken.
 *
 * @param world The world to restore the snapshot to.
 * @param snapshot The snapshot to restore. 
 */
FLECS_EXPORT
void ecs_snapshot_restore(
    ecs_world_t *world,
    ecs_snapshot_t *snapshot);

/** Copy a snapshot.
 * This operation creates a copy of the provided snapshot. An application can
 * optionally filter the tables to copy.
 *
 * @param world The world.
 * @param snapshot The snapshot to copy.
 * @param filter Filter to apply to the copy (optional)
 * @return The duplicated snapshot.
 */
FLECS_EXPORT
ecs_snapshot_t* ecs_snapshot_copy(
    ecs_world_t *world,
    const ecs_snapshot_t *snapshot,
    const ecs_filter_t *filter);

/** Free snapshot resources.
 * This frees resources associated with a snapshot without restoring it.
 *
 * @param world The world.
 * @param snapshot The snapshot to free. 
 */
FLECS_EXPORT
void ecs_snapshot_free(
    ecs_world_t *world,
    ecs_snapshot_t *snapshot);


////////////////////////////////////////////////////////////////////////////////
//// Reader/writer API
////////////////////////////////////////////////////////////////////////////////

/** Initialize a reader.
 * A reader serializes data in a world to a sequence of bytes that can be stored
 * in a file or sent across a network. 
 *
 * @param world The world to serialize.
 * @return The reader.
 */
FLECS_EXPORT
ecs_reader_t ecs_reader_init(
    ecs_world_t *world);

/** Initialize a snapshot reader.
 * A snapshot reader serializes data in a snapshot to a sequence of bytes that 
 * can be stored in a file or sent across a network. A snapshot reader has as
 * advantage that serialization can take place asynchronously while the world
 * is progressing.
 *
 * @param world The world in which the snapshot is taken.
 * @param snapshot The snapshot to serialize.
 * @return The reader.
 */
FLECS_EXPORT
ecs_reader_t ecs_snapshot_reader_init(
    ecs_world_t *world,
    const ecs_snapshot_t *snapshot);

/** Read from a reader.
 * This operation reads a specified number of bytes from a reader and stores it
 * in the specified buffer. When there are no more bytes to read from the reader
 * the operation will return 0, otherwise it will return the number of bytes
 * read.
 *
 * The specified buffer must be at least as big as the specified size, and the
 * specified size must be a multiple of 4.
 *
 * @param buffer The buffer in which to store the read bytes.
 * @param size The maximum number of bytes to read.
 * @param reader The reader from which to read the bytes.
 * @return The number of bytes read.
 */ 
FLECS_EXPORT
size_t ecs_reader_read(
    char *buffer,
    size_t size,
    ecs_reader_t *reader);

/** Initialize a writer.
 * A writer deserializes data from a sequence of bytes into a world. This 
 * enables applications to restore data from disk or the network.
 *
 * The provided world must be either empty or compatible with the data to
 * deserialize, where compatible means that the serialized component ids and 
 * sizes must match exactly with those in the world. Errors can occur if a world
 * is provided in which components have been declared in a different order, or
 * when components have different type definitions.
 *
 * @param world The world in which to deserialize the data.
 * @return The writer. 
 */
FLECS_EXPORT
ecs_writer_t ecs_writer_init(
    ecs_world_t *world);

/** Write to a writer.
 * This operation writes a specified number of bytes from a specified buffer
 * into the writer. The writer will restore the deserialized data into the 
 * original serialized entities. The write operation may be invoked multiple
 * times with partial buffers, which allows applications to use static buffers
 * when reading from, for example, a file or the network.
 *
 * The data contained in the buffers must have been serialized with the
 * ecs_reader_read operation. If the data does not match the expected format, or
 * the data contains conflicts with the world, the operation will fail. The
 * data must be provided in the same order as produced by ecs_reader_read,
 * but the used buffer size does not have to be the same as the one used by
 * ecs_reader_read. The buffer size must be a multiple of 4.
 * 
 * @param buffer The buffer to deserialize.
 * @param size The maximum number of bytes.
 * @param writer The writer to write to.
 * @return Zero if success, non-zero if failed to deserialize.
 */
FLECS_EXPORT
int ecs_writer_write(
    const char *buffer,
    size_t size,
    ecs_writer_t *writer);


////////////////////////////////////////////////////////////////////////////////
//// Module API
////////////////////////////////////////////////////////////////////////////////

/** Import a flecs module.
 * Flecs modules enable reusing components and systems across projects. To
 * use a module, a project needs to link with its library and include its header
 * file.
 *
 * The module returns a struct with handles to the loaded components / systems
 * so they can be accessed by the application. Note that if the module is loaded
 * in different worlds, the handles may not be the same.
 *
 * These naming conventions are not enforced, and projects are free to use their
 * own conventions, though these are the conventions used by the modules
 * provided by flecs.
 *
 * The load function has an additional flags argument which is passed to the
 * module, and is intended to allow applications to select only features they
 * require from a module. The mapping granularity of flags to components/systems
 * is to be defined by the module.
 *
 * This function is wrapped by the ECS_IMPORT convenience macro:
 *
 * ECS_IMPORT(world, EcsComponentsTransform 0);
 *
 * This macro automatically creates a variable called eEcsComponentsTransform
 * that is the struct with the handles for that component.
 *
 * @param world The world.
 * @param module The module to load.
 * @param flags A bitmask that specifies which parts of the module to load.
 * @param handles_out A struct with handles to the module components/systems.
 */
FLECS_EXPORT
ecs_entity_t _ecs_import(
    ecs_world_t *world,
    ecs_module_init_action_t module,
    const char *module_name,
    int flags,
    void *handles_out,
    size_t handles_size);

#define ecs_import(world, module, flags, handles_out)\
    _ecs_import(world, module##Import, #module, flags, handles_out, sizeof(module))

/* Import a module from a library.
 * If a module is stored in another library, it can be dynamically loaded with
 * this operation. A library may contain multiple modules, and to disambiguate
 * the function allows applications to specify the 'module_name' aprameter.
 *
 * A library name typically looks like 'flecs.components.transform', whereas a
 * module name typically looks like 'FlecsComponentsTransform'.
 *
 * To use this function, Flecs needs to be built with bake, as it relies on
 * bake's package discovery utility API.
 *
 * @param world The world.
 * @param library_name The name of the library to load.
 * @param module_name The name of the module to load.
 * @param flags The flags to pass to the module.
 */
FLECS_EXPORT
ecs_entity_t ecs_import_from_library(
    ecs_world_t *world,
    const char *library_name,
    const char *module_name,
    int flags);

/** Define module
 */
#define ECS_MODULE(world, id)\
    ECS_COMPONENT(world, id);\
    ecs_set_ptr(world, EcsSingleton, id, NULL);\
    id *handles = (id*)ecs_get_singleton_ptr(world, id);\

/** Wrapper around ecs_import.
 * This macro provides a convenient way to load a module with the world. It can
 * be used like this:
 *
 * ECS_IMPORT(world, FlecsSystemsPhysics, 0);
 * 
 * This macro will define entity and type handles for the component associated
 * with the module. An application can retrieve the module component like this:
 * 
 * FlecsSystemsPhysics m = ecs_get_singleton(world, FlecsSystemsPhysics);
 * 
 * The contents of a module component are module specific, although they
 * typically contain handles to the content of the module.
 */
#define ECS_IMPORT(world, id, flags) \
    id M##id;\
    ECS_ENTITY_VAR(id) = ecs_import(world, id, flags, &M##id);\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, ecs_entity(id));\
    id##ImportHandles(M##id);\
    (void)ecs_entity(id);\
    (void)ecs_type(id);\

/** Utility macro for declaring a component inside a handles type */
#define ECS_DECLARE_COMPONENT(type)\
    ECS_ENTITY_VAR(type);\
    ECS_TYPE_VAR(type)

/** Utility macro for declaring a system inside a handles type */
#define ECS_DECLARE_ENTITY(entity)\
    ecs_entity_t entity;\
    ECS_TYPE_VAR(entity)

#define ECS_EXPORT_COMPONENT(type)\
    ECS_SET_COMPONENT(type)

#define ECS_EXPORT_ENTITY(type)\
    ECS_SET_ENTITY(type)

/** Utility macro for declaring handles by modules */
#define ECS_IMPORT_COMPONENT(handles, type)\
    ECS_ENTITY_VAR(type) = (handles).ecs_entity(type); (void)ecs_entity(type);\
    ECS_TYPE_VAR(type) = (handles).ecs_type(type); (void)ecs_type(type);\
    (void)ecs_entity(type);\
    (void)ecs_type(type)

/** Utility macro for declaring handles by modules */
#define ECS_IMPORT_ENTITY(handles, entity)\
    ecs_entity_t entity = (handles).entity;\
    ECS_TYPE_VAR(entity) = (handles).ecs_type(entity); (void)ecs_type(entity);\
    (void)entity;\
    (void)ecs_type(entity)

/** -- Builtin module flags -- */
#define ECS_REFLECTION (1)
#define ECS_2D (2)
#define ECS_3D (3)


////////////////////////////////////////////////////////////////////////////////
//// Type API
////////////////////////////////////////////////////////////////////////////////

/** Get a type from an entity.
 * This function returns a type that can be added/removed to entities. If you
 * create a new component, type or prefab with the ecs_new_* function, you get
 * an ecs_entity_t handle which provides access to builtin components associated
 * with the component, type or prefab.
 * 
 * To add a component to an entity, you first have to obtain its type. Types
 * uniquely identify sets of one or more components, and can be used with
 * functions like ecs_add and ecs_remove.
 * 
 * You can only obtain types from entities that have EcsComponent, EcsPrefab,
 * or EcsTypeComponent. These components are automatically added
 * by the ecs_new_* functions, but can also be added manually.
 * 
 * The ECS_COMPONENT, ECS_TAG, ECS_TYPE or ECS_PREFAB macro's will auto-
 * declare a variable containing the type called tFoo (where 'Foo' is the id
 * provided to the macro).
 */
FLECS_EXPORT
ecs_type_t ecs_type_from_entity(
    ecs_world_t *world,
    ecs_entity_t entity);

/** Get an entity from a type.
 * This function is the reverse of ecs_type_from_entity. It only works for types
 * that contain exactly one entity. 
 *
 * If this operation is invoked on a type that contains more than just one 
 * entity, the function will abort. Applications should only use types with this
 * function that are guaranteed to have one entity, such as the types created 
 * for prefabs. 
 *
 * @param world The world.
 * @param type The entity for which to obtain the type.
 * @return The entity associated with the type.
 */
FLECS_EXPORT
ecs_entity_t ecs_type_to_entity(
    ecs_world_t *world,
    ecs_type_t type);

/** Find or create type from existing type and entity. 
 * This operation adds the specified entity to the specified type, and returns a
 * new or existing type that is a union of the specified type and entity. The
 * provided type will not be altered.
 * 
 * @param world The world.
 * @param type The type to which to add the entity.
 * @param entity The entity to add to the type.
 * @return A type that is the union of the specified type and entity.
 */
FLECS_EXPORT
ecs_type_t ecs_type_add(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_entity_t entity);

/** Find or create type from existing type and removed entity. 
 * This operation removes the specified entity from the specified type, and returns a
 * new or existing type without the specified entity. The provided type will not 
 * be altered.
 * 
 * @param world The world.
 * @param type The type from which to remove the entity.
 * @param entity The entity to remove from the type.
 * @return A type that does not have the specified entity.
 */
FLECS_EXPORT
ecs_type_t ecs_type_remove(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_entity_t entity);    

/** Find or create type that is the union of two types. 
 * This operation will return a type that contains exactly the components in the
 * specified type, plus the components in type_add, and not the components in
 * type_remove.
 *
 * The result of the operation is as if type_remove is subtracted before adding 
 * type_add. If type_add contains components that are removed by type_remove,
 * the result will contain the components in type_add.
 *
 * @oaram world The world.
 * @param type The original type.
 * @param type_add The type to add to the original type.
 * @param type_remove The type to remove from the original type.
 */
FLECS_EXPORT
ecs_type_t ecs_type_merge(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_type_t type_add,
    ecs_type_t type_remove);

/** Find or create type from entity array.
 * This operation will return a type that contains the entities in the specified
 * array. If a type with the specified entities already exists, it will be
 * returned, otherwise a new type will be created.
 * 
 * @param world The world.
 * @param array A C array with entity identifiers.
 * @param count The number of elements in the array.
 * @return A type that contains the specified number of entities.
 */
FLECS_EXPORT
ecs_type_t ecs_type_find(
    ecs_world_t *world,
    ecs_entity_t *array,
    uint32_t count);

/** Get component from type at index. 
 * This operation returns the components (or entities) that are contained in the
 * type at the specified index.
 *
 * @param world The world.
 * @param type The type for which to obtain the component.
 * @param index The index at which to obtain the component.
 * @return zero if out of bounds, a component if within bounds.
 */
FLECS_EXPORT
ecs_entity_t ecs_type_get_entity(
    ecs_world_t *world,
    ecs_type_t type,
    uint32_t index);

/** Check if type has entity.
 * This operation returns whether a type has a specified entity.
 * 
 * @param world The world.
 * @param type The type to check.
 * @param entity The entity to check for.
 * @return true if the type contains the entity, otherwise false.
 */
FLECS_EXPORT
bool ecs_type_has_entity(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_entity_t entity);

/** Get type from type expression.
 * This function obtains a type from a type expression. A type expression is a
 * comma-deliminated list of the type's entity identifiers. For example, a type
 * with entities Position and Velocity is: "Position, Velocity".
 * 
 * Type expressions may include type flags that indicate the role of the entity
 * within the type. The following type flags are supported:
 * - INSTANCEOF: share components from this entity
 * - CHILDOF:    treat entity as parent
 * 
 * Type flags can be added with the OR (|) operator. More than one type flag may
 * be specified. This is an example of a type expression with type flags:
 * 
 * Position, Velocity, INSTANCEOF | my_prefab, CHILDOF | my_parent
 * 
 * Entities created with this type will have the Position and Velocity 
 * components, will share components from my_prefab, and will be children of
 * my_parent. The following is also a valid type expression:
 * 
 * INSTANCEOF | CHILDOF | my_prefab
 * 
 * Entities of this type will both share components from my_prefab, as well as
 * be treated as children of my_prefab.
 * 
 * The order in which components are specified has no effect. The following type
 * expressions are equivalent:
 * 
 * - Position, Velocity
 * - Velocity, Position
 * 
 * @param world The world.
 * @param expr The type expression.
 * @return A type if the expression is valid, otherwise NULL.
 */
FLECS_EXPORT
ecs_type_t ecs_expr_to_type(
    ecs_world_t *world,
    const char *expr);

/** Get type expression from type. 
 * This function converts a type to a type expression, which is a string
 * representation of the type as it is provided to the ecs_new_entity and
 * ecs_new_type functions. For more information on type expressions, see 
 * ecs_expr_to_type.
 * 
 * @param world The world.
 * @param type The type for which to obtain the expression.
 * @return The type expression string. This string needs to be deallocated in
 *          order to prevent memory leaks.
 */ 
FLECS_EXPORT
char* ecs_type_to_expr(
    ecs_world_t *world,
    ecs_type_t type);

FLECS_EXPORT
bool ecs_type_match_w_filter(
    ecs_world_t *world,
    ecs_type_t type,
    const ecs_filter_t *filter);

FLECS_EXPORT
int16_t ecs_type_index_of(
    ecs_type_t type,
    ecs_entity_t entity);


////////////////////////////////////////////////////////////////////////////////
//// Threading / Staging API
////////////////////////////////////////////////////////////////////////////////

/** Set number of worker threads.
 * This operation sets the number of worker threads to which to distribute the
 * processing load. If this function is called multiple times, the total number
 * of threads running will reflect the number specified in the last call.
 *
 * This function should not be called while processing an iteration, but should
 * only be called before or after calling ecs_progress.
 *
 * The initial value is zero, which means that ecs_progress will only use the
 * mainthread.
 *
 * @param world The world.
 * @param threads: The number of threads.
 * @return 0 if successful, or -1 if failed.
 */
FLECS_EXPORT
void ecs_set_threads(
    ecs_world_t *world,
    uint32_t threads);

/** Get number of configured threads.
 * This operation will return the number of threads set with ecs_set_threads.
 *
 * @param world The world.
 * @return The number of threads.
 */
FLECS_EXPORT
uint32_t ecs_get_threads(
    ecs_world_t *world);

/** Get index of current worker thread.
 * While iterting, a system can invoke this operation to obtain a number that
 * uniquely identifies the thread from which the operation is invoked.
 *
 * @param world The world.
 * @return The thread index.
 */
FLECS_EXPORT
uint16_t ecs_get_thread_index(
    ecs_world_t *world);

/** Merge staged data.
 * This operation merges data from one or more stages (if there are multiple
 * threads) to the world state. By default, this happens every time ecs_progress
 * is called. To change this to manual merging, call ecs_set_automerge.
 *
 * Calling ecs_merge manually is a performance optimization which trades
 * consistency for speed. By default thread-specific staging areas are merged
 * automatically after each time ecs_progress is called. For some applications
 * this may impact performance too much, in which case manual merging may be
 * used.
 *
 * Manual merging requires that the application logic is capable of handling
 * application state that is out of sync for multiple iterations.
 *
 * @param world The world.
 */
FLECS_EXPORT
void ecs_merge(
    ecs_world_t *world);

/** Set whether the world should merge data each frame.
 * By default, ecs_progress merges data each frame. With this operation that
 * behavior can be changed to merge manually, using ecs_merge.
 *
 * Merging is an expensive task, and having to merge each time ecs_progress is
 * called can slow down the application. If ecs_progress is invoked at high
 * frequencies, it may be sufficient to merge at a reduced rate.
 *
 * As a result of delayed merging, any operation that requires adding or
 * removing components from an entity will not be visible to all threads until
 * the merge occurs.
 *
 * @param world The world.
 * @param auto_merge: When true, ecs_progress performs merging.
 */
FLECS_EXPORT
void ecs_set_automerge(
    ecs_world_t *world,
    bool auto_merge);

////////////////////////////////////////////////////////////////////////////////
//// Utilities
////////////////////////////////////////////////////////////////////////////////

/** Enables admin web server
 * This operation allows an profile and enable/disable registered systems. If
 * the flecs.systems.civetweb or flecs.systems.admin modules cannot be found,
 * the operation will fail.
 *
 * @param world The world.
 * @param port A port number for server.
 * 
 * @return The error code
 *          0 - success
 *          1 - failed to dynamically load `flecs.systems.civetweb` module
 *          2 - failed to dynamically load `flecs.systems.admin` module
 */
FLECS_EXPORT
int ecs_enable_admin(
	ecs_world_t* world,
	uint16_t port);

/** Enable command line console for inspecting Flecs internals.
 * If the flecs.systems.console module cannot be found, the operation will fail.
 *
 * @param world The world.
 * @return 0 if success, nonzero if failed.  
 */
FLECS_EXPORT
int ecs_enable_console(
	ecs_world_t* world);

/** Translate C type to entity variable */
#define ecs_entity(type) E##type

/** Translate C type to type variable */
#define ecs_type(type) T##type

/** Translate module name into handles struct */
#define ecs_module(type) M##type

/* Include stats at the end so it gets all the declarations */
#include <flecs/util/stats.h>

#ifdef __cplusplus
}

#ifndef FLECS_NO_CPP
#ifndef __BAKE_LEGACY__
#include <flecs/flecs.hpp>
#endif
#endif

#endif

#endif
