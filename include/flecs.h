
#ifndef FLECS_H
#define FLECS_H

#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#ifndef __BAKE__
#include <stdint.h>
#endif

/* Utility file generated by bake */
#include <flecs/bake_config.h>

/* -- The API uses the native bool type in C++, or a custom one in C -- */

#ifndef __cplusplus
#undef bool
#undef true
#undef false
typedef char bool;
#define false 0
#define true !false
#endif

#define uint unsigned int
/* The flecs world object */
typedef struct ecs_world ecs_world_t;

/** A handle identifies an entity */
typedef uint64_t ecs_entity_t;

typedef struct ecs_time_t {
    int32_t sec;
    uint32_t nanosec;
} ecs_time_t;

/* Utility headers */
#include <flecs/util/os_api.h>
#include <flecs/util/vector.h>
#include <flecs/util/chunked.h>
#include <flecs/util/map.h>
#include <flecs/util/os_api.h>

/** -- Builtin module flags -- */
#define ECS_REFLECTION (1)
#define ECS_2D (2)
#define ECS_3D (3)

#ifdef __cplusplus
extern "C" {
#endif


/* -- Supporting types -- */

/** A hash of the component identifiers in a type. */
typedef const ecs_vector_t* ecs_type_t;

/** Id component type */
typedef const char *EcsId;

/** Component component */
typedef struct EcsComponent {
    uint32_t size;
} EcsComponent;

/** Prefab component */
typedef struct EcsPrefab {
    ecs_entity_t parent;
} EcsPrefab;

/** System kinds determine when and how systems are ran */
typedef enum EcsSystemKind {
    /* Periodic systems */
    EcsOnLoad,
    EcsPostLoad,
    EcsPreUpdate,
    EcsOnUpdate,
    EcsOnValidate,
    EcsPostUpdate,
    EcsPreStore,
    EcsOnStore,

    /* Manual systems */
    EcsManual,

    /* Reactive systems */
    EcsOnAdd,
    EcsOnRemove,
    EcsOnSet
} EcsSystemKind;

/** Reference to a component from another entity */
typedef struct ecs_reference_t {
    ecs_entity_t entity;
    ecs_entity_t component;
    void *cached_ptr;
} ecs_reference_t;

/** Data passed to system action callback, used for iterating entities */
typedef struct ecs_rows_t {
    ecs_world_t *world;          /* Current world */
    ecs_entity_t system;         /* Handle to current system */

    int32_t *columns;    /* Indices mapping system params to columns and refs */
    uint16_t column_count;       /* Number of columns for system */
    void *table;                 /* Opaque structure with reference to table */
    void *table_columns;         /* Opaque structure with table column data */
    ecs_reference_t *references; /* References to other entities */
    ecs_entity_t *components;    /* System-table specific list of components */
    ecs_entity_t *entities;      /* Entity row */

    void *param;                 /* Userdata passed to on-demand system */
    float delta_time;            /* Time elapsed since last frame */
    float world_time;            /* Time elapsed since start of simulation */
    uint32_t frame_offset;       /* Offset relative to frame */
    uint32_t table_offset;       /* Current active table being processed */
    uint32_t offset;             /* Offset relative to current table */
    uint32_t count;              /* Number of rows to process by system */

    ecs_entity_t interrupted_by; /* When set, system execution is interrupted */
} ecs_rows_t;

/** Types that describes a type filter.
 * A type filter is used to match against zero or more types. For example,
 * a type filter that includes component "Position" will match types 
 * [Position], [Position, Velocity], [Position, Mass] etc. When no include
 * filter is specified, all types will be matched.
 *
 * A filter can be narrowed down by specifying an exclude filter. For example,
 * a filter which includes "Position" but excludes "Mass" will match types
 * [Position] and [Position, Velocity], but not [Position, Mass].
 *
 * A type filter may contain multiple components. The filter kind determines
 * how the filter is interpreted. When the kind is EcsMatchAll, all the
 * components in the filter must be either included or excluded from the type
 * being matched. If the kind is EcsMatchAny, any of the components should
 * match with the type being matched.
 *
 * For example, a filter that includes {[Position, Velocity], EcsMatchAny} will
 * match types [Position], [Position, Velocity] and [Velocity], but not [Mass].
 * A filter that excludes {[Position, Velocity], EcsMatchAll} will not match 
 * [Position, Velocity] or [Position, Velocity, Mass], but will match 
 * [Position].
 *
 * If the kind is set to EcsMatchExact, the type needs to match the table type
 * exactly. This applies to both the include and exclude types. For example, if
 * the include type is {[Position, Velocity], EcsMatchExact}, only 
 * [Position, Velocity] will be matched, and not, for example, 
 * [Position, Velocity, Mass].
 * 
 * Similarly, if the exclude filter is set to {[Position, Velocity], 
 * EcsMatchExact}, only [Position, Velocity] will be excluded from the matching
 * set of types and not, for example [Position], or [Position, Velocity, Mass].
 *
 * When the kind is left to EcsMatchDefault, the include_kind will be set to
 * EcsMatchAll, while the exclude_kind will be set to EcsMatchAny.
 */
typedef enum ecs_type_filter_kind_t {
    EcsMatchDefault = 0,
    EcsMatchAll,
    EcsMatchAny,
    EcsMatchExact
} ecs_type_filter_kind_t;

typedef struct ecs_type_filter_t {
    ecs_type_t include;
    ecs_type_t exclude;
    ecs_type_filter_kind_t include_kind;
    ecs_type_filter_kind_t exclude_kind;
} ecs_type_filter_t;

/** System action callback type */
typedef void (*ecs_system_action_t)(
    ecs_rows_t *data);

/** System enable action callback bitmask */
typedef enum ecs_system_status_t {
    EcsSystemStatusNone = 0,
    EcsSystemEnabled,
    EcsSystemDisabled,
    EcsSystemActivated,
    EcsSystemDeactivated
} ecs_system_status_t;

typedef void (*ecs_system_status_action_t)(
    ecs_world_t *world,
    ecs_entity_t system,
    ecs_system_status_t status,
    void *ctx);

/** Initialization function signature of modules */
typedef void (*ecs_module_init_action_t)(
    ecs_world_t *world,
    int flags);

#define ECS_INSTANCEOF ((ecs_entity_t)1 << 63)
#define ECS_CHILDOF ((ecs_entity_t)1 << 62)
#define ECS_ENTITY_FLAGS_MASK ((ecs_entity_t)(ECS_INSTANCEOF | ECS_CHILDOF))
#define ECS_ENTITY_MASK ((ecs_entity_t)~ECS_ENTITY_FLAGS_MASK)
#define ECS_SINGLETON ((ecs_entity_t)(ECS_ENTITY_MASK) - 1)
#define ECS_INVALID_ENTITY (0)    

/** Handles to builtin components */
#define EEcsComponent (1)
#define EEcsTypeComponent (2)
#define EEcsPrefab (3)
#define EEcsPrefabParent (4)
#define EEcsPrefabBuilder (5)
#define EEcsRowSystem (6)
#define EEcsColSystem (7)
#define EEcsId (8)
#define EEcsHidden (9)
#define EEcsDisabled (10)
#define EEcsOnDemand (11)

/* World entity */
#define EcsWorld (13)

/* Singleton entity */
#define EcsSingleton (ECS_SINGLETON)

/* Type handles to builtin components */
FLECS_EXPORT
extern ecs_type_t 
    TEcsComponent,
    TEcsTypeComponent,
    TEcsPrefab,
    TEcsPrefabParent,
    TEcsPrefabBuilder,
    TEcsRowSystem,
    TEcsColSystem,
    TEcsId,
    TEcsHidden,
    TEcsDisabled,
    TEcsOnDemand;

/* This allows passing 0 as type to functions that accept types */
#define T0 (0)

/* Ids (names) of builtin components */
FLECS_EXPORT
extern const char 
    *ECS_COMPONENT_ID,
    *ECS_TYPE_COMPONENT_ID,
    *ECS_PREFAB_ID,
    *ECS_PREFAB_PARENT_ID,
    *ECS_ROW_SYSTEM_ID,
    *ECS_COL_SYSTEM_ID,
    *ECS_ID_ID,
    *ECS_HIDDEN_ID,
    *ECS_CONTAINER_ID,
    *ECS_DISABLED_ID,
    *ECS_ON_DEMAND_ID;

/* -- World API -- */

/** Create a new world.
 * A world manages all the ECS objects. Applications must have at least one
 * world. Entities, component and system handles are local to a world and
 * cannot be shared between worlds.
 *
 * @returns A new world object
 */
FLECS_EXPORT
ecs_world_t* ecs_init(void);

/** Create a new world with arguments.
 * Same as ecs_init, but allows passing in command line arguments. These can be
 * used to dynamically enable flecs features to an application, like performance
 * monitoring or the web dashboard (if it is installed) without having to modify
 * the code of an application.
 * 
 * If the functionality requested by the arguments is not available, an error
 * message will be printed to stderr, but the function will not fail. Thus it is
 * important that the application code does not rely on any functionality that
 * is realized through the arguments.
 * 
 * If the arguments specify a setting that is explicity set as well by the
 * application, the application setting will be ignored. For example, if an
 * application specifies it will run on 2 threads, but an argument specify it
 * will run on 6 threads, the argument will take precedence.
 * 
 * The following options are available:
 * --threads [n]   Use n worker threads
 * --fps [hz]      Run at hz FPS
 * --admin [port]  Enable admin dashboard (requires flecs-systems-admin & flecs-systems-civetweb)
 * --debug         Enables debug tracing
 *
 * @returns A new world object
 */
FLECS_EXPORT
ecs_world_t* ecs_init_w_args(
    int argc,
    char *argv[]);

/** Delete a world.
 * This operation deletes the world, and all entities, components and systems
 * within the world.
 *
 * @param world The world to delete.
 */
FLECS_EXPORT
int ecs_fini(
    ecs_world_t *world);

/** Signal exit
 * This operation signals that the application should quit. It will cause
 * ecs_progress to return false.
 *
 * @param world The world to quit.
 */
FLECS_EXPORT
void ecs_quit(
    ecs_world_t *world);

/** Import a flecs module.
 * Flecs modules enable reusing components and systems across projects. To
 * use a module, a project needs to link with its library and include its header
 * file.
 *
 * The module returns a struct with handles to the loaded components / systems
 * so they can be accessed by the application. Note that if the module is loaded
 * in different worlds, the handles may not be the same.
 *
 * These naming conventions are not enforced, and projects are free to use their
 * own conventions, though these are the conventions used by the modules
 * provided by flecs.
 *
 * The load function has an additional flags argument which is passed to the
 * module, and is intended to allow applications to select only features they
 * require from a module. The mapping granularity of flags to components/systems
 * is to be defined by the module.
 *
 * This function is wrapped by the ECS_IMPORT convenience macro:
 *
 * ECS_IMPORT(world, EcsComponentsTransform 0);
 *
 * This macro automatically creates a variable called eEcsComponentsTransform
 * that is the struct with the handles for that component.
 *
 * @param world The world.
 * @param module The module to load.
 * @param flags A bitmask that specifies which parts of the module to load.
 * @param handles_out A struct with handles to the module components/systems.
 */
FLECS_EXPORT
ecs_entity_t _ecs_import(
    ecs_world_t *world,
    ecs_module_init_action_t module,
    const char *module_name,
    int flags,
    void *handles_out,
    size_t handles_size);

#define ecs_import(world, module, flags, handles_out)\
    _ecs_import(world, module##Import, #module, flags, handles_out, sizeof(module))

/* Import a module from a library.
 * If a module is stored in another library, it can be dynamically loaded with
 * this operation. A library may contain multiple modules, and to disambiguate
 * the function allows applications to specify the 'module_name' aprameter.
 *
 * A library name typically looks like 'flecs.components.transform', whereas a
 * module name typically looks like 'FlecsComponentsTransform'.
 *
 * To use this function, Flecs needs to be built with bake, as it relies on
 * bake's package discovery utility API.
 *
 * @param world The world.
 * @param library_name The name of the library to load.
 * @param module_name The name of the module to load.
 * @param flags The flags to pass to the module.
 */
FLECS_EXPORT
ecs_entity_t ecs_import_from_library(
    ecs_world_t *world,
    const char *library_name,
    const char *module_name,
    int flags);

/** Progress a world.
 * This operation progresses the world by running all systems that are both
 * enabled and periodic on their matching entities.
 *
 * To ensure consistency of the data, mutations that add/remove components or
 * create/delete entities are staged and merged after all systems are evaluated.
 * When using multiple threads, each thread will have its own "staging area".
 * Threads will be able to see their own changes, but may not see changes from
 * other threads until changes are merged.
 *
 * Staging only occurs when ecs_progress is executing systems. The operations
 * that use staging are:
 *
 * - ecs_new
 * - ecs_new_w_count
 * - ecs_clone
 * - ecs_delete
 * - ecs_add
 * - ecs_remove
 * - ecs_set
 *
 * By default, staged data is merged each time ecs_progress has evaluated all
 * systems. An application may choose to manually merge instead, by setting
 * auto-merging to false with ecs_set_automerge and invoking ecs_merge when a
 * merge is required. In applications with relatively lots of data to merge,
 * this can significantly boost performance.
 *
 * It should be noted that delaying a merge in a multithreaded application
 * causes temporary inconsistencies between threads. A thread will be able to
 * see changes from the previous iteration, but will not be able to see updates
 * from other threads until a merge has taken place.
 *
 * Note that staging only occurs for changes caused by the aforementioned
 * functions. If a system makes in-place modifications to components (through
 * pointers obtained with ecs_data) they will be "instantly" visible to other
 * threads.
 *
 * An application can pass a delta_time into the function, which is the time
 * passed since the last frame. This value is passed to systems so they can
 * update entity values proportional to the elapsed time since their last
 * invocation.
 *
 * By passing the delta_time into ecs_progress, an application can take full
 * control of the "speed" at which entities are progressed. This can be
 * particularly useful in simulations, where this feature can be used to control
 * playback speed.
 *
 * When an application passes 0 to delta_time, ecs_progress will automatically
 * measure the time passed since the last frame. If an application does not uses
 * time management, it should pass a non-zero value for delta_time (1.0 is
 * recommended). That way, no time will be wasted measuring the time.
 *
 * @param world The world to progress.
 * @param delta_time The time passed since the last frame.
 */
FLECS_EXPORT
bool ecs_progress(
    ecs_world_t *world,
    float delta_time);

/** Merge staged data.
 * This operation merges data from one or more stages (if there are multiple
 * threads) to the world state. By default, this happens every time ecs_progress
 * is called. To change this to manual merging, call ecs_set_automerge.
 *
 * Calling ecs_merge manually is a performance optimization which trades
 * consistency for speed. By default thread-specific staging areas are merged
 * automatically after each time ecs_progress is called. For some applications
 * this may impact performance too much, in which case manual merging may be
 * used.
 *
 * Manual merging requires that the application logic is capable of handling
 * application state that is out of sync for multiple iterations.
 *
 * @param world The world.
 */
FLECS_EXPORT
void ecs_merge(
    ecs_world_t *world);

/** Set whether the world should merge data each frame.
 * By default, ecs_progress merges data each frame. With this operation that
 * behavior can be changed to merge manually, using ecs_merge.
 *
 * Merging is an expensive task, and having to merge each time ecs_progress is
 * called can slow down the application. If ecs_progress is invoked at high
 * frequencies, it may be sufficient to merge at a reduced rate.
 *
 * As a result of delayed merging, any operation that requires adding or
 * removing components from an entity will not be visible to all threads until
 * the merge occurs.
 *
 * @param world The world.
 * @param auto_merge: When true, ecs_progress performs merging.
 */
FLECS_EXPORT
void ecs_set_automerge(
    ecs_world_t *world,
    bool auto_merge);

/** Set number of worker threads.
 * This operation sets the number of worker threads to which to distribute the
 * processing load. If this function is called multiple times, the total number
 * of threads running will reflect the number specified in the last call.
 *
 * This function should not be called while processing an iteration, but should
 * only be called before or after calling ecs_progress.
 *
 * The initial value is zero, which means that ecs_progress will only use the
 * mainthread.
 *
 * @param world The world.
 * @param threads: The number of threads.
 * @returns 0 if successful, or -1 if failed.
 */
FLECS_EXPORT
void ecs_set_threads(
    ecs_world_t *world,
    uint32_t threads);

/** Get number of configured threads */
FLECS_EXPORT
uint32_t ecs_get_threads(
    ecs_world_t *world);

/** Get index of current worker thread */
FLECS_EXPORT
uint16_t ecs_get_thread_index(
    ecs_world_t *world);

/** Set target frames per second (FPS) for application.
 * Setting the target FPS ensures that ecs_progress is not invoked faster than
 * the specified FPS. When enabled, ecs_progress tracks the time passed since
 * the last invocation, and sleeps the remaining time of the frame (if any).
 *
 * This feature ensures systems are ran at a consistent interval, as well as
 * conserving CPU time by not running systems more often than required.
 *
 * This feature depends upon frame profiling. When this operation is called,
 * frame profiling is automatically enabled. Frame profiling can be manually
 * turned on/off with ecs_measure_frame_time. It is not possible to turn off
 * frame profiling if a target FPS is set.
 *
 * Note that ecs_progress only sleeps if there is time left in the frame. Both
 * time spent in flecs as time spent outside of flecs are taken into
 * account.
 *
 * Setting a target FPS can be more efficient than letting the application do it
 * manually, as the feature can reuse clock measurements that are taken for
 * frame profiling as well as automatically measuring delta_time.
 */
FLECS_EXPORT
void ecs_set_target_fps(
    ecs_world_t *world,
    float fps);

/** Get number of configured threads */
FLECS_EXPORT
uint32_t ecs_get_target_fps(
    ecs_world_t *world);

/** Enables admin web server
 * This operation allows an profile and enable/disable registered systems
 *
 * @param world The world.
 * @param port A port number for server.
 * 
 * @returns The error code
 *          0 - success
 *          1 - failed to dynamically load `flecs.systems.civetweb` module
 *          2 - failed to dynamically load `flecs.systems.admin` module
 */
FLECS_EXPORT
int ecs_enable_admin(
	ecs_world_t* world,
	uint16_t port);

/** Get last used delta time from world */
FLECS_EXPORT
float ecs_get_delta_time(
    ecs_world_t *world);

/** Set a world context.
 * This operation allows an application to register custom data with a world
 * that can be accessed anywhere where the application has the world object.
 *
 * A typical usecase is to register a struct with handles to the application
 * entities, components and systems.
 *
 * @param world The world.
 * @param ctx A pointer to a user defined structure.
 */
FLECS_EXPORT
void ecs_set_context(
    ecs_world_t *world,
    void *ctx);

/** Get the world context.
 * This operation retrieves a previously set world context.
 *
 * @param world The world.
 * @returns The context set with ecs_set_context. If no context was set, the
 *          function returns NULL.
 */
FLECS_EXPORT
void* ecs_get_context(
    ecs_world_t *world);

/** Get the world tick.
 * This operation retrieves the tick count (frame number). The tick count is 0
 * when ecs_process is called for the first time, and increases by one for every
 * subsequent call.
 *
 * @param world The world.
 * @returns The current tick.
 */
FLECS_EXPORT
uint32_t ecs_get_tick(
    ecs_world_t *world);

/** Dimension the world for a specified number of entities.
 * This operation will preallocate memory in the world for the specified number
 * of entities. Specifying a number lower than the current number of entities in
 * the world will have no effect.
 *
 * When using this operation, note that flecs uses entities for storing
 * systems, components and builtin components. For an exact calculation of
 * entities, do user_entity_count + component_count + system_count + 3. The 3
 * stands for the number of builtin components.
 *
 * Note that this operation does not allocate memory in tables. To preallocate
 * memory in a table, use ecs_dim_type. Correctly using these functions
 * prevents flecs from doing dynamic memory allocations in the main loop.
 *
 * @param world The world.
 * @param entity_count The number of entities to preallocate.
 */
FLECS_EXPORT
void ecs_dim(
    ecs_world_t *world,
    uint32_t entity_count);

/** Dimension a type for a specified number of entities.
 * This operation will preallocate memory for a type (table) for the
 * specified number of entites. Specifying a number lower than the current
 * number of entities in the table will have no effect.
 *
 * If no table exists yet for this type (when no entities have been committed
 * for the type) it will be created, even if the entity_count is zero. This
 * operation can thus also be used to just preallocate empty tables.
 *
 * If the specified type is unknown, the behavior of this function is
 * unspecified. To ensure that the type exists, use ecs_type_get or
 * ECS_TYPE.
 *
 * @param world The world.
 * @param type Handle to the type, as obtained by ecs_type_get.
 * @param entity_count The number of entities to preallocate.
 */
FLECS_EXPORT
void _ecs_dim_type(
    ecs_world_t *world,
    ecs_type_t type,
    uint32_t entity_count);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_dim_type(world, type, entity_count)\
    _ecs_dim_type(world, T##type, entity_count)

/** Set a range for issueing new entity ids.
 * This function constrains the entity identifiers returned by ecs_new to the 
 * specified range. This operation can be used to ensure that multiple processes
 * can run in the same simulation without requiring a central service that
 * coordinates issueing identifiers.
 * 
 * If id_end is set to 0, the range is infinite. If id_end is set to a non-zero
 * value, it has to be larger than id_start. If id_end is set and ecs_new is
 * invoked after an id is issued that is equal to id_end, the application will
 * abort. Flecs does not automatically recycle ids.
 * 
 * The id_end parameter has to be smaller than the last issued identifier.
 * 
 * @param world The world.
 * @param id_start The start of the range.
 * @param id_end The end of the range.
 */
FLECS_EXPORT
void ecs_set_entity_range(
    ecs_world_t *world,
    ecs_entity_t id_start,
    ecs_entity_t id_end);

/** Temporarily enable/disable range limits.
 * When an application is both a receiver of range-limited entities and a
 * producer of range-limited entities, range checking needs to be temporarily
 * disabled when receiving entities.
 * 
 * Range checking is disabled on a stage, so setting this value is thread safe.
 */
FLECS_EXPORT
bool ecs_enable_range_check(
    ecs_world_t *world,
    bool enable);

/* -- Entity API -- */

/** Create a new entity.
 * Entities are light-weight objects that represent "things" in the application.
 * Entities themselves do not have any state or logic, but instead are composed
 * out of a set of zero or more components.
 *
 * Entities are accessed through handles instead of direct pointers. Certain
 * operations may move an entity in memory. Handles provide a safe mechanism for
 * addressing entities.
 *
 * Flecs does not require applications to explicitly create handles, as entities
 * do not have an explicit lifecycle. The ecs_new operation merely provides a
 * convenient way to dispense handles. It is guaranteed that the handle returned
 * by ecs_new has not bee returned before.
 *
 * @param world The world to which to add the entity.
 * @param type Zero if no type, or handle to a component, type or prefab.
 * @returns A handle to the new entity.
 * @see ecs_new_entity ecs_new_component ecs_new_system ecs_new_prefab ecs_new_type ecs_new_child ecs_new_w_count
 */
FLECS_EXPORT
ecs_entity_t _ecs_new(
    ecs_world_t *world,
    ecs_type_t type);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_new(world, type)\
    _ecs_new(world, T##type)

/** Create new entities in a batch.
 * This operation creates the number of specified entities with one API call
 * which is a more efficient alternative to calling ecs_new in a loop.
 *
 * @param world The world.
 * @param type Zero if no type, or handle to a component, type or prefab.
 * @param count The number of entities to create.
 * @param handles_out An array which contains the handles of the new entities.
 * @returns The handle to the first created entity.
 */
FLECS_EXPORT
ecs_entity_t _ecs_new_w_count(
    ecs_world_t *world,
    ecs_type_t type,
    uint32_t count);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_new_w_count(world, type, count)\
    _ecs_new_w_count(world, T##type, count)

typedef void* ecs_table_columns_t;

typedef struct ecs_table_data_t {
    uint32_t row_count;
    uint32_t column_count;
    ecs_entity_t *entities;
    ecs_entity_t *components;
    ecs_table_columns_t *columns;
} ecs_table_data_t;

/** Insert data in bulk.
 * This operation allows applications to insert data in bulk by providing the
 * entity and component data as arrays. The data is passed in using the
 * ecs_table_data_t type, which has to be populated with the data that has to be
 * inserted.
 * 
 * The application must at least provide the row_count, column_count and 
 * components fields. The latter is an array of component identifiers that
 * identifies the components to be added to the entitiy.
 *
 * The entities array must be populated with the entity identifiers to set. If
 * this field is left NULL, Flecs will create row_count new entities.
 *
 * The component data must be provided in the columns field. This is an array of
 * component arrays. The component arrays must be provided in the same order as
 * the components have been provided in the components array. For example, if
 * the components array is set to {ecs_entity(Position), ecs_entity(Velocity)},
 * the columns must first specify the Position, and then the Velocity array. If
 * no component data is provided, the components will be left uninitialized.
 *
 * Both the entities array and the component data arrays in columns must contain
 * exactly row_count elements. The columns array must contain exactly 
 * column_count elements.
 *
 * The operation allows for efficient insertion of data for the same set of
 * entities, provided that the entities are specified in the same order for
 * every invocation of this function. After executing this operation, entities
 * will be ordered in the same order specified in the entities array.
 *
 * If entities already exist in another table, they will be deleted from that
 * table and inserted into the new table. 
 */
FLECS_EXPORT
ecs_entity_t ecs_set_w_data(
    ecs_world_t *world,
    ecs_table_data_t *data);

/** Create a new child entity.
 * Child entities are equivalent to normal entities, but can additionally be 
 * created with a container entity. Container entities allow for the creation of
 * entity hierarchies.
 * 
 * This function is equivalent to calling ecs_new with a type that combines both
 * the type specified in this function and the type id for the container.
 *
 * @param world The world.
 * @param parent The container to which to add the child entity.
 * @param type The type with which to create the child entity.
 * @returns A handle to the created entity.
 * @see ecs_new_entity ecs_new_component ecs_new_system ecs_new_prefab ecs_new_type ecs_new ecs_new_w_count
 */
FLECS_EXPORT
ecs_entity_t _ecs_new_child(
    ecs_world_t *world,
    ecs_entity_t parent,
    ecs_type_t type);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_new_child(world, parent, type)\
    _ecs_new_child(world, parent, T##type)

/* Create new child entities in batch.
 * This operation is similar to ecs_new_w_count, with as only difference that
 * the parent is added to the type of the new entities.
 *
 * @param world The world.
 * @param parent The parent.
 * @param type The type to create the new entities with.
 * @param count The number of entities to create.
 */
FLECS_EXPORT
ecs_entity_t _ecs_new_child_w_count(
    ecs_world_t *world,
    ecs_entity_t parent,
    ecs_type_t type,
    uint32_t count);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_new_child_w_count(world, parent, type, count)\
    _ecs_new_child_w_count(world, parent, T##type, count)

/** Instantiate entity from a base entity.
 * This operation returns a new entity that shares components with the provided 
 * base entity.
 * 
 * @param world The world.
 * @param base The base entity.
 * @return A new entity that is an instance of base.
 */
FLECS_EXPORT
ecs_entity_t _ecs_new_instance(
    ecs_world_t *world,
    ecs_entity_t base,
    ecs_type_t type);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_new_instance(world, base, type)\
    _ecs_new_instance(world, base, T##type)

/** Instantiate entities from a base entity in batch.
 * This operation returns a specified number of new entities that share 
 * components with the provided base entity.
 * 
 * @param world The world.
 * @param base The base entity.
 * @return The id to the first new entity.
 */
FLECS_EXPORT
ecs_entity_t _ecs_new_instance_w_count(
    ecs_world_t *world,
    ecs_entity_t base,
    ecs_type_t type,
    uint32_t count);

#define ecs_new_instance_w_count(world, base, type, count)\
    _ecs_new_instance_w_count(world, base, T##type, count)

/** Create new entity with same components as specified entity.
 * This operation creates a new entity which has the same components as the
 * specified entity. This includes prefabs and entity-components (entities to
 * which the EcsComponent component has been added manually).
 *
 * The application can optionally copy the values of the specified entity by
 * passing true to copy_value. In that case, the resulting entity will have the
 * same value as source specified entity.
 *
 * @param world The world.
 * @param entity The source entity.
 * @param copy_value Whether to copy the entity value.
 * @returns The handle to the new entity.
 */
FLECS_EXPORT
ecs_entity_t ecs_clone(
    ecs_world_t *world,
    ecs_entity_t entity,
    bool copy_value);

/** Delete components for an entity.
 * This operation will delete all components from the specified entity. As
 * entities in Flecs do not have an explicit lifecycle, this operation will not
 * invalidate the entity id.
 *
 * When the delete operation is invoked upon an already deleted entity, the
 * operation will have no effect, as it will attempt to delete components from
 * an already empty entity.
 *
 * As a result of a delete operation, EcsOnRemove systems will be invoked if
 * applicable for any of the removed components.
 *
 * @param world The world.
 * @param entity The entity to empty.
 */
FLECS_EXPORT
void ecs_delete(
    ecs_world_t *world,
    ecs_entity_t entity);

/** Delete all entities containing a (set of) component(s). 
 * This operation provides a more efficient alternative to deleting entities one
 * by one by deleting an entire table or set of tables in a single operation.
 * The operation will clear all tables that match the specified table.
 * 
 * @param world The world.
 * @param filter Filter that matches zero or more tables.
 */
FLECS_EXPORT
void ecs_delete_w_filter(
    ecs_world_t *world,
    ecs_type_filter_t *filter);

/** Add a type to an entity.
 * This operation will add one or more components (as per the specified type) to
 * an entity. If the entity already contains a subset of the components in the
 * type, only components that are not contained by the entity will be added. If
 * the entity already contains all components, this operation has no effect.
 *
 * As a result of an add operation, EcsOnAdd systems will be invoked if
 * applicable for any of the added components.
 *
 * @param world The world.
 * @param entity The entity to which to add the type.
 * @param type The type to add to the entity.
 */
FLECS_EXPORT
void _ecs_add(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_add(world, entity, type)\
    _ecs_add(world, entity, T##type)

/** Remove a type from an entity.
 * This operation will remove one or more components (as per the specified type)
 * from an entity. If the entity contained a subset of the components in the
 * type, only that subset will be removed. If the entity contains none of the
 * components in the type, the operation has no effect.
 *
 * As a result of a remove operation, EcsOnRemove systems will be invoked if
 * applicable for any of the removed components.
 *
 * @param world The world.
 * @param entity The entity from which to remove the type.
 * @param type The type to remove from the entity.
 */
FLECS_EXPORT
void _ecs_remove(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_remove(world, entity, type)\
    _ecs_remove(world, entity, T##type)

/** Add and remove types from an entity.
 * This operation is a combination of ecs_add and ecs_remove. The operation
 * behaves as if the specified to_remove type is removed first, and 
 * subsequently the to_add type is added. This operation is more efficient than
 * adding/removing components separately with ecs_add/ecs_remove, as the entity
 * is moved between tables at most once.
 * 
 * @param world The world.
 * @param entity The entity from which to remove, and to which to add the types.
 * @param to_add The type to add to the entity.
 * @param to_remove The type to remove from the entity.
 */ 
FLECS_EXPORT
void _ecs_add_remove(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t to_add,
    ecs_type_t to_remove);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_add_remove(world, entity, to_add, to_remove)\
    _ecs_add_remove(world, entity, T##to_add, T##to_remove)

/** Adopt a child entity by a parent.
 * This operation adds the specified parent entity to the type of the specified
 * entity, which effectively establishes a parent-child relationship. The parent
 * entity, when added, behaves like a normal component in that it becomes part
 * of the entity type.
 *
 * If the parent was already added to the entity, this operation will have no
 * effect.
 *
 * This operation is similar to an ecs_add, with as difference that instead of a 
 * type it accepts any entity handle.
 *
 * @param world The world.
 * @param entity The entity to adopt.
 * @param parent The parent entity to add to the entity.
 */
FLECS_EXPORT
void ecs_adopt(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t parent);

/** Orphan a child by a parent. 
 * This operation removes the specified parent entity from the type of the
 * specified entity. If the parent was not added to the entity, this operation
 * has no effect.
 *
 * This operation is similar to ecs_remove, with as difference that instead of a
 * type it accepts any entity handle.
 *
 * @param world The world.
 * @param entity The entity to orphan.
 * @param parent The parent entity to remove from the entity.
 */
FLECS_EXPORT
void ecs_orphan(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t parent);

/** Inherit from a base.
 * This operation adds a base to an entity, which will cause the entity to
 * inherit the components of the base. If the entity already inherited from the
 * specified base, this operation does nothing.
 * 
 * @param world The world.
 * @param entity The entity to add the base to.
 * @param base The base to add to the entity.
 */
FLECS_EXPORT
void ecs_inherit(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t base);

/** Disinherit from a base.
 * This operation removes a base from an entity, which will cause the entity to
 * no longer inherit the components of the base. If the entity did not inherit
 * from the specified base, this operation does nothing.
 * 
 * @param world The world.
 * @param entity The entity to remove the base from.
 * @param base The base to remove from the entity.
 */
FLECS_EXPORT
void ecs_disinherit(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t base);

/** Add/remove one or more components from a set of tables.
 * This operation adds/removes one or more components from a set of tables 
 * matching a filter. This operation is more efficient than calling ecs_add 
 * or ecs_remove on the individual entities.
 *
 * If no filter is provided, the component(s) will be added/removed from all the
 * tables in which it/they (not) occur(s).
 *
 * After this operation it is guaranteed that no tables matching the filter
 * will have the components in to_remove, and similarly, all will have the
 * components in to_add. If to_add or to_remove has multiple components
 * and only one of the components occurs in a table, that component will be
 * added/removed from the entities in the table.
 *
 * @param world The world.
 * @param to_add The components to add.
 * @param to_remove The components to remove.
 * @param filter Filter that matches zero or more tables.
 */
FLECS_EXPORT
void _ecs_add_remove_w_filter(
    ecs_world_t *world,
    ecs_type_t to_add,
    ecs_type_t to_remove,
    ecs_type_filter_t *filter);

#define ecs_add_remove_w_filter(world, to_add, to_remove, filter)\
    _ecs_add_remove_w_filter(world, ecs_type(to_add), ecs_type(to_remove), filter)

/** Get pointer to component data.
 * This operation obtains a pointer to the component data of an entity. If the
 * component was not added for the specified entity, the operation will return
 * NULL.
 *
 * Note that the returned pointer has temporary validity. Operations such as
 * delete and add/remove may invalidate the pointer as data is potentially moved
 * to different locations. After one of these operations is invoked, the pointer
 * will have to be re-obtained.
 *
 * This function is wrapped by the ecs_get convenience macro, which can be
 * used like this:
 *
 * Foo value = ecs_get(world, e, Foo);
 *
 * @param world The world.
 * @param entity Handle to the entity from which to obtain the component data.
 * @param component The component to retrieve the data for.
 * @returns A pointer to the data, or NULL of the component was not found.
 */
FLECS_EXPORT
void* _ecs_get_ptr(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_get_ptr(world, entity, type)\
    _ecs_get_ptr(world, entity, T##type)

/* Convenienve macro for returning a value instead of a pointer */
#define ecs_get(world, entity, type)\
  (*(type*)_ecs_get_ptr(world, entity, T##type))

#define ecs_get_singleton(world, type)\
    (*(type*)_ecs_get_ptr(world, ECS_SINGLETON, T##type))

#define ecs_get_singleton_ptr(world, type)\
    _ecs_get_ptr(world, ECS_SINGLETON, T##type)

/* Set value of component.
 * This function sets the value of a component on the specified entity. If the
 * component does not yet exist, it will be added to the entity.
 *
 * This function can be used like this:
 * Foo value = {.x = 10, .y = 20};
 * ecs_set_ptr(world, e, ecs_type(Foo), &value);
 *
 * This function is wrapped by the ecs_set convenience macro, which can be used
 * like this:
 *
 * ecs_set(world, e, Foo, {.x = 10, .y = 20});
 *
 * @param world The world.
 * @param entity The entity on which to set the component.
 * @param component The component to set.
 */
FLECS_EXPORT
ecs_entity_t _ecs_set_ptr(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component,
    size_t size,
    void *ptr);

FLECS_EXPORT
ecs_entity_t _ecs_set_singleton_ptr(
    ecs_world_t *world,
    ecs_entity_t component,
    size_t size,
    void *ptr);

#define ecs_set_ptr(world, entity, component, ptr)\
    _ecs_set_ptr(world, entity, ecs_entity(component), sizeof(component), ptr)

/* Conditionally skip macro's as compound literals are not supported in C89 */
#ifndef __BAKE_LEGACY__
#define ecs_set(world, entity, component, ...)\
    _ecs_set_ptr(world, entity, ecs_entity(component), sizeof(component), &(component)__VA_ARGS__)

#define ecs_set_singleton(world, component, ...)\
    _ecs_set_singleton_ptr(world, ecs_entity(component), sizeof(component), &(component)__VA_ARGS__)
#endif

#define ecs_set_singleton_ptr(world, component, ptr)\
    _ecs_set_singleton_ptr(world, ecs_entity(component), sizeof(component), ptr)


/** Check if entity has the specified type.
 * This operation checks if the entity has the components associated with the
 * specified type. It accepts component handles, types and prefabs.
 *
 * For example, if an entity has component 'Foo' and a type has 'Foo, Bar'
 * invoking this function with the entity and type as type will return false
 * because the entity does not have 'Bar'. Invoking the entity with the 'Bar'
 * component, or a type that contains only 'Bar' will return true.
 *
 * @param world The world.
 * @param entity Handle to a entity.
 * @param type Handle to a component, type or prefab.
 * @returns true if entity has type, otherwise false.
 */
FLECS_EXPORT
bool _ecs_has(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_has(world, entity, type)\
    _ecs_has(world, entity, T##type)

/** Same as ecs_has, but only returns true if entity owns the component(s). */
FLECS_EXPORT
bool _ecs_has_owned(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_has_owned(world, entity, type)\
    _ecs_has_owned(world, entity, T##type)

/** Check if entity has any of the components in the specified type.
 * This operation checks if the entity has any of the components associated with
 * the specified type. It accepts component handles, types and prefabs.
 *
 * For example, if an entity has component 'Foo' and a type has 'Foo, Bar'
 * invoking this function with the entity and type as type will return true
 * because the entity has one of the components.
 *
 * @param world The world.
 * @param entity Handle to a entity.
 * @param type Handle to a component, type or prefab.
 * @returns true if entity has one of the components, otherwise false.
 */
FLECS_EXPORT
bool _ecs_has_any(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

#define ecs_has_any(world, entity, type)\
    _ecs_has_any(world, entity, T##type)

/** Same as ecs_has_any, but only returns true if entity owns the component(s). */
FLECS_EXPORT
bool _ecs_has_any_owned(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_type_t type);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_has_any_owned(world, entity, type)\
    _ecs_has_any_owned(world, entity, T##type)

FLECS_EXPORT
bool ecs_has_entity(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component);

/** Check if parent entity contains child entity.
 * This function tests if the specified parent entity has been added to the
 * specified child entity.
 *
 * This function is similar to ecs_has, with as difference that instead of a 
 * type it accepts a handle to any entity.
 *
 * @param world The world.
 * @param parent The parent.
 * @param child The child.
 * @returns true if the parent contains the child, otherwise false.
 */
FLECS_EXPORT
bool ecs_contains(
    ecs_world_t *world,
    ecs_entity_t parent,
    ecs_entity_t child);

/** Return container for component.
 * This function allows the application to query for a container of the
 * specified entity that has the specified component. If there are multiple
 * containers with this component, the function will return the first one it
 * encounters.
 *
 * @param world The world.
 * @param entity The entity for which to resolve the container.
 * @param component The component which the resovled container should have.
 */
FLECS_EXPORT
ecs_entity_t _ecs_get_parent(
    ecs_world_t *world,
    ecs_entity_t entity,
    ecs_entity_t component);

#define ecs_get_parent(world, entity, component)\
    _ecs_get_parent(world, entity, ecs_entity(component))

/** Get type of entity.
 * This operation returns the entity type, which is a handle to the a list of
 * the current components an entity has.
 *
 * Note that this function is different from ecs_type_from_entity, which returns
 * a type which only contains the specified entity.
 *
 * This operation is mostly intended for debugging, as it is considered a bad
 * practice to rely on the type for logic, as the type changes when components
 * are added/removed to the entity.
 *
 * @param world The world.
 * @param entity The entity for which to obtain the type.
 * @returns The type of the entity.
 */
FLECS_EXPORT
ecs_type_t ecs_get_type(
    ecs_world_t *world,
    ecs_entity_t entity);

/** Return the entity id.
 * This returns the string identifier of an entity, if the entity has the EcsId
 * component. By default, all component, type, system and prefab entities add
 * the EcsId component if they have been created with the ecs_new_* functions.
 *
 * If the entity does not contain the EcsId component, this function will return
 * NULL.
 *
 * @param world The world.
 * @param entity The entity for which to resolve the id.
 * @returns The id of the entity.
 */
FLECS_EXPORT
const char* ecs_get_id(
    ecs_world_t *world,
    ecs_entity_t entity);

/** Return if the entity is empty.
 * This returns whether the provided entity handle is empty. An entity that is
 * empty has no components.
 *
 * @param world The world.
 * @param entity The entity handle.
 * @returns true if empty, false if not empty.
 */
FLECS_EXPORT
bool ecs_is_empty(
    ecs_world_t *world,
    ecs_entity_t entity);

/** Returns number of entities that have a given type. 
 * This operation will count the number of entities that have all of the
 * components in the specified type.
 *
 * This operation will not reflect entities created/deleted when invoked while
 * iterating. To get a consistent count, the function should be invoked after
 * data from an iteration has been merged.
 *
 * @param world The world.
 * @param type The type used to match entities.
 */
FLECS_EXPORT
uint32_t _ecs_count(
    ecs_world_t *world,
    ecs_type_t type);

#define ecs_count(world, type) _ecs_count(world, ecs_type(type))

/** Lookup an entity by id.
 * This operation is a convenient way to lookup entities by string identifier
 * that have the EcsId component. It is recommended to cache the result of this
 * function, as the function must iterates over all entities and all components
 * in an entity.
 *
 * @param world The world.
 * @param id The id to lookup.
 * @returns The entity handle if found, or 0 if not found.
 */
FLECS_EXPORT
ecs_entity_t ecs_lookup(
    ecs_world_t *world,
    const char *id);

/** Lookup child of parent by id.
 * This operation is the same as ecs_lookup, except for that it only searches
 * entities that are children of the specified parent.
 * 
 * This operation can also be used to only lookup entities with a certain
 * component, in the following way:
 * 
 * ecs_lookup_child(world, ecs_entity(Component), "child_id");
 * 
 * Here, 'Component' refers to the component (type) identifier.
 * 
 * @param world The world.
 * @param parent The parent.
 * @param id The id to lookup.
 * @returns The entity handle if found, or 0 if not found.
 */
FLECS_EXPORT
ecs_entity_t ecs_lookup_child(
    ecs_world_t *world,
    ecs_entity_t parent,
    const char *id);


/* -- Type API -- */

/** Get a type from an entity.
 * This function returns a type that can be added/removed to entities. If you
 * create a new component, type or prefab with the ecs_new_* function, you get
 * an ecs_entity_t handle which provides access to builtin components associated
 * with the component, type or prefab.
 * 
 * To add a component to an entity, you first have to obtain its type. Types
 * uniquely identify sets of one or more components, and can be used with
 * functions like ecs_add and ecs_remove.
 * 
 * You can only obtain types from entities that have EcsComponent, EcsPrefab,
 * or EcsTypeComponent. These components are automatically added
 * by the ecs_new_* functions, but can also be added manually.
 * 
 * The ECS_COMPONENT, ECS_TAG, ECS_TYPE or ECS_PREFAB macro's will auto-
 * declare a variable containing the type called tFoo (where 'Foo' is the id
 * provided to the macro).
 */
FLECS_EXPORT
ecs_type_t ecs_type_from_entity(
    ecs_world_t *world,
    ecs_entity_t entity);

/** Get an entity from a type.
 * This function is the reverse of ecs_type_from_entity. It only works for types
 * that contain exactly one entity. 
 *
 * If this operation is invoked on a type that contains more than just one 
 * entity, the function will abort. Applications should only use types with this
 * function that are guaranteed to have one entity, such as the types created 
 * for prefabs. 
 *
 * @param world The world.
 * @param type The entity for which to obtain the type.
 * @returns The entity associated with the type.
 */
FLECS_EXPORT
ecs_entity_t ecs_type_to_entity(
    ecs_world_t *world,
    ecs_type_t type);

/** Find or create type from existing type and entity. 
 * This operation adds the specified entity to the specified type, and returns a
 * new or existing type that is a union of the specified type and entity. The
 * provided type will not be altered.
 * 
 * @param world The world.
 * @param type The type to which to add the entity.
 * @param entity The entity to add to the type.
 * @returns A type that is the union of the specified type and entity.
 */
FLECS_EXPORT
ecs_type_t ecs_type_add(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_entity_t entity);

/** Find or create type that is the union of two types. 
 * This operation will return a type that contains exactly the components in the
 * specified type, plus the components in type_add, and not the components in
 * type_remove.
 *
 * The result of the operation is as if type_remove is subtracted before adding 
 * type_add. If type_add contains components that are removed by type_remove,
 * the result will contain the components in type_add.
 *
 * @oaram world The world.
 * @param type The original type.
 * @param type_add The type to add to the original type.
 * @param type_remove The type to remove from the original type.
 */
FLECS_EXPORT
ecs_type_t ecs_type_merge(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_type_t type_add,
    ecs_type_t type_remove);

/** Find or create type from entity array.
 * This operation will return a type that contains the entities in the specified
 * array. If a type with the specified entities already exists, it will be
 * returned, otherwise a new type will be created.
 * 
 * @param world The world.
 * @param array A C array with entity identifiers.
 * @param count The number of elements in the array.
 * @returns A type that contains the specified number of entities.
 */
FLECS_EXPORT
ecs_type_t ecs_type_find(
    ecs_world_t *world,
    ecs_entity_t *array,
    uint32_t count);

/** Get component from type at index. 
 * This operation returns the components (or entities) that are contained in the
 * type at the specified index.
 *
 * @param world The world.
 * @param type The type for which to obtain the component.
 * @param index The index at which to obtain the component.
 * @returns zero if out of bounds, a component if within bounds.
 */
FLECS_EXPORT
ecs_entity_t ecs_type_get_entity(
    ecs_world_t *world,
    ecs_type_t type,
    uint32_t index);

/** Check if type has entity.
 * This operation returns whether a type has a specified entity.
 * 
 * @param world The world.
 * @param type The type to check.
 * @param entity The entity to check for.
 * @returns true if the type contains the entity, otherwise false.
 */
FLECS_EXPORT
bool ecs_type_has_entity(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_entity_t entity);

/** Get type from type expression.
 * This function obtains a type from a type expression. A type expression is a
 * comma-deliminated list of the type's entity identifiers. For example, a type
 * with entities Position and Velocity is: "Position, Velocity".
 * 
 * Type expressions may include type flags that indicate the role of the entity
 * within the type. The following type flags are supported:
 * - INSTANCEOF: share components from this entity
 * - CHILDOF:    treat entity as parent
 * 
 * Type flags can be added with the OR (|) operator. More than one type flag may
 * be specified. This is an example of a type expression with type flags:
 * 
 * Position, Velocity, INSTANCEOF | my_prefab, CHILDOF | my_parent
 * 
 * Entities created with this type will have the Position and Velocity 
 * components, will share components from my_prefab, and will be children of
 * my_parent. The following is also a valid type expression:
 * 
 * INSTANCEOF | CHILDOF | my_prefab
 * 
 * Entities of this type will both share components from my_prefab, as well as
 * be treated as children of my_prefab.
 * 
 * The order in which components are specified has no effect. The following type
 * expressions are equivalent:
 * 
 * - Position, Velocity
 * - Velocity, Position
 * 
 * @param world The world.
 * @param expr The type expression.
 * @returns A type if the expression is valid, otherwise NULL.
 */
FLECS_EXPORT
ecs_type_t ecs_expr_to_type(
    ecs_world_t *world,
    const char *expr);

/** Get type expression from type. 
 * This function converts a type to a type expression, which is a string
 * representation of the type as it is provided to the ecs_new_entity and
 * ecs_new_type functions. For more information on type expressions, see 
 * ecs_expr_to_type.
 * 
 * @param world The world.
 * @param type The type for which to obtain the expression.
 * @returns The type expression string. This string needs to be deallocated in
 *          order to prevent memory leaks.
 */ 
FLECS_EXPORT
char* ecs_type_to_expr(
    ecs_world_t *world,
    ecs_type_t type);

FLECS_EXPORT
bool ecs_type_match_w_filter(
    ecs_world_t *world,
    ecs_type_t type,
    ecs_type_filter_t *filter);

/* -- System API -- */

/** Enable or disable a system.
 * This operation enables or disables a system. A disabled system will not be
 * ran during ecs_progress or when components must be initialized or
 * deinitialized. Systems are enabled by default.
 *
 * This operation expects a valid system handle, or in other words, an entity
 * with the EcsSystem component. If a handle to an entity is provided that does
 * not have this component, the operation will fail.
 *
 * @param world The world.
 * @param system The system to enable or disable.
 * @param enabled true to enable the system, false to disable the system.
 * @returns 0 if succeeded, -1 if the operation failed.
 */
FLECS_EXPORT
void ecs_enable(
    ecs_world_t *world,
    ecs_entity_t system,
    bool enabled);

/** Configure how often a system should be invoked.
 * This operation lets an application control how often a system should be
 * invoked. The provided period is the minimum interval between two invocations.
 *
 * Correct operation of this feature relies on an application providing a
 * delta_time value to ecs_progress. Once the delta_time exceeds the period that
 * is specified for a system, ecs_progress will invoke it.
 *
 * This operation is only valid on EcsPeriodic systems. If it is invoked on
 * handles of other systems or entities it will be ignored. An application may
 * only set the period outside ecs_progress.
 *
 * Note that a system will never be invoked more often than ecs_progress is
 * invoked. If the specified period is smaller than the interval at which
 * ecs_progress is invoked, the system will be invoked at every ecs_progress,
 * provided that the delta_time provided to ecs_progress is accurate.
 *
 * @param world The world.
 * @param system The system for which to set the period.
 * @param period The period.
 */
FLECS_EXPORT
void ecs_set_period(
    ecs_world_t *world,
    ecs_entity_t system,
    float period);

/** Returns the enabled status for a system / entity.
 * This operation will return whether a system is enabled or disabled. Currently
 * only systems can be enabled or disabled, but this operation does not fail
 * when a handle to an entity is provided that is not a system. If this
 * operation is called on a non-system entity, the operation will return true.
 *
 * @param world The world.
 * @param system The system to check.
 * @returns True if the system is enabled, false if the system is disabled.
 */
FLECS_EXPORT
bool ecs_is_enabled(
    ecs_world_t *world,
    ecs_entity_t system);

/** Run a specific system manually.
 * This operation runs a single system manually. It is an efficient way to
 * invoke logic on a set of entities, as manual systems are only matched to
 * tables at creation time or after creation time, when a new table is created.
 *
 * Manual systems are useful to evaluate lists of prematched entities at
 * application defined times. Because none of the matching logic is evaluated
 * before the system is invoked, manual systems are much more efficient than
 * manually obtaining a list of entities and retrieving their components.
 *
 * An application may pass custom data to a system through the param parameter.
 * This data can be accessed by the system through the param member in the
 * ecs_rows_t value that is passed to the system callback.
 *
 * Any system may interrupt execution by setting the interrupted_by member in
 * the ecs_rows_t value. This is particularly useful for manual systems, where
 * the value of interrupted_by is returned by this operation. This, in
 * cominbation with the param argument lets applications use manual systems
 * to lookup entities: once the entity has been found its handle is passed to
 * interrupted_by, which is then subsequently returned.
 *
 * @param world The world.
 * @param system The system to run.
 * @param delta_time: The time passed since the last system invocation.
 * @param param A user-defined parameter to pass to the system.
 * @returns handle to last evaluated entity if system was interrupted.
 */
FLECS_EXPORT
ecs_entity_t ecs_run(
    ecs_world_t *world,
    ecs_entity_t system,
    float delta_time,
    void *param);

/** Run system with offset/limit and type filter.
 * This operation is the same as ecs_run, but filters the entities that will be
 * iterated by the system.
 * 
 * Entities can be filtered in two ways. Offset and limit control the range of
 * entities that is iterated over. The range is applied to all entities matched
 * with the system, thus may cover multiple archetypes.
 * 
 * The type filter controls which entity types the system will evaluate. Only
 * types that contain all components in the type filter will be iterated over. A
 * type filter is only evaluated once per table, which makes filtering cheap if
 * the number of entities is large and the number of tables is small, but not as
 * cheap as filtering in the system signature.
 * 
 * @param world The world.
 * @param system The system to invoke.
 * @param delta_time: The time passed since the last system invocation.
 * @param filter A component or type to filter matched entities.
 * @param param A user-defined parameter to pass to the system.
 * @returns handle to last evaluated entity if system was interrupted.
 */
FLECS_EXPORT
ecs_entity_t _ecs_run_w_filter(
    ecs_world_t *world,
    ecs_entity_t system,
    float delta_time,
    uint32_t offset,
    uint32_t limit,
    ecs_type_t filter,
    void *param);

#define ecs_run_w_filter(world, system, delta_time, offset, limit, type, param)\
    _ecs_run_w_filter(world, system, delta_time, offset, limit, T##type, param)

/** Set system context.
 * This operation allows an application to register custom data with a system.
 * This data can be accessed using the ecs_get_system_context operation, or
 * through the 'param' field in the ecs_rows_t parameter passed into the system
 * callback.
 *
 * @param world The world.
 * @param system The system on which to set the context.
 * @param ctx A pointer to a user defined structure.
 */
FLECS_EXPORT
void ecs_set_system_context(
    ecs_world_t *world,
    ecs_entity_t system,
    const void *ctx);

/** Get system context.
 * Get custom data from a system previously set with ecs_set_system_context.
 *
 * @param world The world.
 * @param system The system of which to obtain the context.
 * @returns The system context.
 */
FLECS_EXPORT
void* ecs_get_system_context(
    ecs_world_t *world,
    ecs_entity_t system);

/** Set system status action.
 * The status action is invoked whenever a system is enabled or disabled. Note
 * that a system may be enabled but may not actually match any entities. In this
 * case the system is enabled but not _active_.
 *
 * In addition to communicating the enabled / disabled status, the action also
 * communicates changes in the activation status of the system. A system becomes
 * active when it has one or more matching entities, and becomes inactive when
 * it no longer matches any entities.
 * 
 * A system switches between enabled and disabled when an application invokes the
 * ecs_enable operation with a state different from the state of the system, for
 * example the system is disabled, and ecs_enable is invoked with enabled: true.
 *
 * Additionally a system may switch between enabled and disabled when it is an
 * EcsOnDemand system, and interest is generated or lost for one of its [out]
 * columns.
 *
 * @param world The world.
 * @param system The system for which to set the action.
 * @param action The action.
 * @param ctx Context that will be passed to the action when invoked.
 */
FLECS_EXPORT
void ecs_set_system_status_action(
    ecs_world_t *world,
    ecs_entity_t system,
    ecs_system_status_action_t action,
    const void *ctx);

/** Obtain a pointer to column data. 
 * This function is to be used inside a system to obtain data from a column in
 * the system signature. The provided index corresponds with the index of the
 * element in the system signature, starting from one. For example, for the
 * following system signature:
 * 
 * Position, Velocity
 * 
 * Position is at index 1, and Velocity is at index 2.
 * 
 * This function is typically invoked through the `ECS_COLUMN` macro which
 * automates declaring a variable of the correct type in the scope of the system
 * function.
 * 
 * When a valid pointer is obtained, it can be used as an array with rows->count
 * elements if the column is owned by the entity being iterated over, or as a
 * pointer if the column is shared (see ecs_is_shared).
 * 
 * @param rows The rows parameter passed into the system.
 * @param index The index identifying the column in a system signature.
 * @returns A pointer to the column data if index is valid, otherwise NULL.
 */
FLECS_EXPORT
void* _ecs_column(
    ecs_rows_t *rows,
    size_t size,
    uint32_t column);

#define ecs_column(rows, type, column)\
    ((type*)_ecs_column(rows, sizeof(type), column))

/** Test if column is shared or not. 
 * The following signature shows an example of owned components and shared
 * components:
 * 
 * Position, CONTAINER.Velocity, MyEntity.Mass
 * 
 * Position is an owned component, while Velocity and Mass are shared 
 * components. While these kinds of relationships are expressed explicity in a
 * system signature, inheritance relationships are implicit. The above signature
 * matches both entities for which Position is owned as well as entities for
 * which Position appears in an entity that they inherit from.
 * 
 * If a system needs to support both cases, it needs to test whether the
 * component is shared or not. This test only needs to happen once per system
 * callback invocation, as all the entities being iterated over will either own
 * or not own the component.
 * 
 * @param rows The rows parameter passed into the system.
 * @param index The index identifying the column in a system signature.
 * @returns true if the column is shared, false if it is owned.
 */
FLECS_EXPORT
bool ecs_is_shared(
    ecs_rows_t *rows,
    uint32_t column);

/** Obtain a single field. 
 * This is an alternative method to ecs_column to access data in a system, which
 * accesses data from individual fields (one column per row). This method is
 * slower than iterating over a column array, but has the added benefit that it
 * automatically abstracts between shared components and owned components. 
 * 
 * This is particularly useful if a system is unaware whether a particular 
 * column is from a prefab, as a system does not explicitly state in an argument
 * expression whether prefabs should be matched with, thus it is possible that
 * a system receives both shared and non-shared data for the same column.
 * 
 * When a system uses fields, these differences will be transparent, and it is
 * therefore the method that provides the most flexibility with respect to the
 * kind of data the system can accept.
 */
FLECS_EXPORT
void *_ecs_field(
    ecs_rows_t *rows,
    size_t size,
    uint32_t column,
    uint32_t row);

#define ecs_field(rows, type, column, row)\
    ((type*)_ecs_field(rows, sizeof(type), column, row))

/** Obtain the source of a column from inside a system.
 * This operation lets you obtain the entity from which the column data was
 * resolved. In most cases a component will come from the entities being
 * iterated over, but when using prefabs or containers, the component can be
 * shared between entities. For shared components, this function will return the
 * original entity on which the component is stored.
 * 
 * If a column is specified for which the component is stored on the entities
 * being iterated over, the operation will return 0, as the entity id in that
 * case depends on the row, not on the column. To obtain the entity ids for a
 * row, a system should access the entity column (column zero) like this:
 * 
 * ecs_entity_t *entities = ecs_column(rows, ecs_entity_t, 0);
 * 
 * @param rows Pointer to the rows object passed into the system callback.
 * @param index An index identifying the column for which to obtain the component.
 * @return The source entity for the column. 
 */
FLECS_EXPORT
ecs_entity_t ecs_column_source(
    ecs_rows_t *rows,
    uint32_t column);

/** Obtain the component for a column inside a system.
 * This operation obtains the component handle for a column in the system. This
 * function wraps around the 'components' array in the ecs_rows_t type.
 * 
 * Note that since component identifiers are obtained from the same pool as
 * regular entities, the return type of this function is ecs_entity_t.
 * 
 * When a system contains an argument that is prefixed with 'ID', the resolved
 * entity will be accessible through this function as well.
 * 
 * Column indices for system arguments start from 1, where 0 is reserved for a
 * column that contains entity identifiers. Passing 0 to this function for the
 * column index will return 0.
 * 
 * @param rows Pointer to the rows object passed into the system callback.
 * @param index An index identifying the column for which to obtain the component.
 * @return The component for the specified column, or 0 if failed.
 */
FLECS_EXPORT
ecs_entity_t ecs_column_entity(
    ecs_rows_t *rows,
    uint32_t column);

/** Obtain the type of a column from inside a system. 
 * This operation is equivalent to ecs_column_entity, except that it returns
 * a type, instead of an entity handle. Invoking this function is the same as
 * doing:
 * 
 * ecs_type_from_entity( ecs_column_entity(rows, index));
 * 
 * This function is wrapped in the following convenience macro which ensures
 * that the type variable is named so it can be used with functions like ecs_add
 * and ecs_set:
 * 
 * ECS_COLUMN_COMPONENT(rows, Position, 1);
 * 
 * After this macro you can invoke functions like ecs_set as you normally would:
 * 
 * ecs_set(world, e, Position, {10, 20});
 * 
 * @param rows Pointer to the rows object passed into the system callback.
 * @param index An index identifying the column for which to obtain the component.
 * @return The type for the specified column, or 0 if failed.
 */ 
FLECS_EXPORT
ecs_type_t ecs_column_type(
    ecs_rows_t *rows,
    uint32_t column);

/** Get type of table that system is currently iterating over. */
FLECS_EXPORT
ecs_type_t ecs_table_type(
    ecs_rows_t *rows);

/** Get type of table that system is currently iterating over. */
FLECS_EXPORT
void* ecs_table_column(
    ecs_rows_t *rows,
    uint32_t column);

/* -- Functions used in convenience macro's -- */

/** Convenience function to create an entity with id and component expression.
 * This is equivalent to calling ecs_new with a type that contains all 
 * components provided in the 'component' expression. In addition, this function
 * also adds the EcsId component, which will be set to the provided id string.
 *
 * This function is wrapped by the ECS_ENTITY convenience macro.
 *
 * @param world The world.
 * @param id The entity id.
 * @param components A component expression.
 * @returns A handle to the created entity.
 * @see ecs_new_component ecs_new_system ecs_new_prefab ecs_new_type ecs_new_child ecs_new ecs_new_w_count
 */
FLECS_EXPORT
ecs_entity_t ecs_new_entity(
    ecs_world_t *world,
    const char *id,
    const char *components);

/** Create a new component.
 * This operation creates a new component with a specified id and size. After
 * this operation is called, the component can be added to entities by using
 * the returned handle with ecs_add.
 *
 * Components represent the data of entities. An entity can be composed out of
 * zero or more components. Internally compoments are stored in tables that
 * are created for active combinations of components in a world.
 *
 * This operation accepts a size, which is the size of the type that contains
 * the component data. Any native type can be used, and the size can be
 * obtained with the built-in sizeof function. For convenience, an application
 * may use the ECS_COMPONENT macro instead of calling this function directly.
 *
 * Components are stored internally as entities. This operation is equivalent
 * to creating an entity with the EcsComponent and EcsId components. The
 * returned handle can be used in any function that accepts an entity handle.
 *
 * @param world The world.
 * @param id A unique component identifier.
 * @param size The size of the component type (as obtained by sizeof).
 * @returns A handle to the new component, or 0 if failed.
 */
FLECS_EXPORT
ecs_entity_t ecs_new_component(
    ecs_world_t *world,
    const char *id,
    size_t size);

/** Create a new system.
 * This operation creates a new system with a specified id, kind and action.
 * After this operation is called, the system will be active. Systems can be
 * created with three different kinds:
 *
 * - EcsOnUpdate: the system is invoked when ecs_progress is called.
 * - EcsOnAdd: the system is invoked when a component is committed to memory.
 * - EcsOnRemove: the system is invoked when a component is removed from memory.
 * - EcsManual: the system is only invoked on demand (ecs_run)
 *
 * The signature of the system is a string formatted as a comma separated list
 * of component identifiers. For example, a system that wants to receive the
 * Location and Speed components, should provide "Location, Speed" as its
 * signature.
 *
 * The action is a function that is invoked for every entity that has the
 * components the system is interested in. The action has three parameters:
 *
 * - ecs_entity_t system: Handle to the system (same as returned by this function)
 * - ecs_entity_t entity: Handle to the current entity
 * - void *data[]: Array of pointers to the component data
 *
 * Systems are stored internally as entities. This operation is equivalent to
 * creating an entity with the EcsSystem and EcsId components. The returned
 * handle can be used in any function that accepts an entity handle.
 *
 * @param world The world.
 * @param id The identifier of the system.
 * @param kind The kind of system.
 * @param signature The signature that describes the components.
 * @param action The action that is invoked for matching entities.
 * @returns A handle to the system.
 */
FLECS_EXPORT
ecs_entity_t ecs_new_system(
    ecs_world_t *world,
    const char *id,
    EcsSystemKind kind,
    const char *sig,
    ecs_system_action_t action);

/** Get handle to type.
 * This operation obtains a handle to a type that can be used with
 * ecs_new. Predefining types has performance benefits over using
 * ecs_add/ecs_remove multiple times, as it provides constant
 * creation time regardless of the number of components. This function will
 * internally create a table for the type.
 *
 * If a type had been created for this set of components before with the same
 * identifier, the existing type is returned. If the type had been created
 * with a different identifier, this function will fail.
 *
 * The ECS_TYPE macro wraps around this function.
 *
 * @param world The world.
 * @param components A comma-separated string with the component identifiers.
 * @returns Handle to the type, zero if failed.
 */
FLECS_EXPORT
ecs_entity_t ecs_new_type(
    ecs_world_t *world,
    const char *id,
    const char *components);

/** Create a new prefab entity.
 * Prefab entities allow entities to share a set of components. Components of
 * the prefab will appear on the specified entity when using any of the API
 * functions and ECS systems.
 *
 * A prefab is a regular entity, with the only difference that it has the
 * EcsPrefab component.
 *
 * The ECS_PREFAB macro wraps around this function.
 *
 * Changing the value of one of the components on the prefab will change the
 * value for all entities that added the prefab, as components are stored only
 * once in memory. This makes prefabs also a memory-saving mechanism; there can
 * be many entities that reuse component records from the prefab.
 *
 * Entities can override components from a prefab by adding the component with
 * ecs_add. When a component is overridden, its value will be copied from the
 * prefab. This technique can be combined with types to automatically
 * initialize entities, like this:
 *
 * ECS_PREFAB(world, MyPrefab, Foo);
 * ECS_TYPE(world, MyType, MyPrefab, Foo);
 * ecs_entity_t e = ecs_new(world, MyType);
 *
 * In this code, the entity will be created with the prefab and directly
 * override 'Foo', which will copy the value of 'Foo' from the prefab.
 *
 * Prefabs are explicitly stored on the component list of an entity. This means
 * that two entities with the same set of components but a different prefab are
 * stored in different tables.
 *
 * Prefabs can be part of the component list of other prefabs. This allows for
 * creating hierarchies of prefabs, where the leaves are the most specialized.
 *
 * Only one prefab may be added to an entity.
 */
FLECS_EXPORT
ecs_entity_t ecs_new_prefab(
    ecs_world_t *world,
    const char *id,
    const char *sig);


/* -- Error handling & error codes -- */

/** Get description for error code */
FLECS_EXPORT
const char* ecs_strerror(
    uint32_t error_code);

FLECS_EXPORT
void ecs_print_error_string(const char *signature, const char *system_id, const char *error_description, char *component_id, int count, ...);

/** Abort */
FLECS_EXPORT
void _ecs_abort(
    uint32_t error_code,
    const char *param,
    const char *file,
    uint32_t line);

/** Assert */
FLECS_EXPORT
void _ecs_assert(
    bool condition,
    uint32_t error_code,
    const char *param,
    const char *condition_str,
    const char *file,
    uint32_t line);

#define ecs_abort(error_code, param) _ecs_abort(error_code, param, __FILE__, __LINE__); abort()

#ifdef NDEBUG
#define ecs_assert(condition, error_code, param)
#else
#define ecs_assert(condition, error_code, param) _ecs_assert(condition, error_code, param, #condition, __FILE__, __LINE__); assert(condition)
#endif

#define ECS_INVALID_HANDLE (1)
#define ECS_INVALID_PARAMETER (2)
#define ECS_INVALID_COMPONENT_ID (3)
#define ECS_INVALID_EXPRESSION (4)
#define ECS_INVALID_TYPE_EXPRESSION (5)
#define ECS_INVALID_SIGNATURE (6)
#define ECS_UNKNOWN_COMPONENT_ID (7)
#define ECS_UNKNOWN_TYPE_ID (8)
#define ECS_TYPE_NOT_AN_ENTITY (9)
#define ECS_MISSING_SYSTEM_CONTEXT (10)
#define ECS_NOT_A_COMPONENT (11)
#define ECS_INTERNAL_ERROR (12)
#define ECS_MORE_THAN_ONE_PREFAB (13)
#define ECS_ALREADY_DEFINED (14)
#define ECS_INVALID_COMPONENT_SIZE (15)
#define ECS_OUT_OF_MEMORY (16)
#define ECS_MODULE_UNDEFINED (17)
#define ECS_COLUMN_INDEX_OUT_OF_RANGE (18)
#define ECS_COLUMN_IS_NOT_SHARED (19)
#define ECS_COLUMN_IS_SHARED (20)
#define ECS_COLUMN_HAS_NO_DATA (21)
#define ECS_COLUMN_TYPE_MISMATCH (22)
#define ECS_INVALID_WHILE_MERGING (23)
#define ECS_INVALID_WHILE_ITERATING (24)
#define ECS_INVALID_FROM_WORKER (25)
#define ECS_UNRESOLVED_IDENTIFIER (26)
#define ECS_OUT_OF_RANGE (27)
#define ECS_COLUMN_IS_NOT_SET (28)
#define ECS_UNRESOLVED_REFERENCE (29)
#define ECS_THREAD_ERROR (30)
#define ECS_MISSING_OS_API (31)
#define ECS_TYPE_TOO_LARGE (32)
#define ECS_INVALID_PREFAB_CHILD_TYPE (33)
#define ECS_UNSUPPORTED (34)
#define ECS_NO_OUT_COLUMNS (35)
#define ECS_CANT_USE_NOT_IN_OR_EXPRESSION (36)
#define ECS_CANT_USE_OR_WITH_EMPTY_FROM_EXPRESSION (37)
#define ECS_ZERO_CAN_ONLY_APPEAR_BY_ITSELF (38)
#define ECS_UNSESOLVED_COMPONENT_NAME (39)
#define ECS_UNRESOLVED_ENTITY_NAME (40)

/* -- Convenience macro's for wrapping around generated types and entities -- */

/** Translate C type to entity variable */
#define ecs_entity(type) E##type

/** Translate C type to type variable */
#define ecs_type(type) T##type

/** Translate module name into handles struct */
#define ecs_module(type) M##type

/** Declare type variable */
#define ECS_TYPE_VAR(type)\
    ecs_type_t ecs_type(type)

/** Declare entity variable */
#define ECS_ENTITY_VAR(type)\
    ecs_entity_t ecs_entity(type)


/* -- Convenience macro's for declaring Flecs objects -- */

#ifndef __BAKE_LEGACY__

/** Wrapper around ecs_new_entity. */ 
#define ECS_ENTITY(world, id, ...)\
    ecs_entity_t id = ecs_new_entity(world, #id, #__VA_ARGS__);\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, id);\
    (void)id;\
    (void)ecs_type(id);

/** Wrapper around ecs_new_component.
 * This macro provides a convenient way to register components with a world. It
 * can be used like this:
 *
 * ECS_COMPONENT(world, Position);
 * ecs_entity_t e = ecs_new(world, Position);
 *
 * In this example, "Position" must be a valid C type name. The macro will 
 * define two local variables, one for a type handle and one for an entity
 * handle. These handles can be accessed with ecs_type(Position) and 
 * ecs_entity(Position). */
#define ECS_COMPONENT(world, id) \
    ECS_ENTITY_VAR(id) = ecs_new_component(world, #id, sizeof(id));\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, ecs_entity(id));\
    (void)ecs_entity(id);\
    (void)ecs_type(id);\

/** Same as component, but no size */
#define ECS_TAG(world, id) \
    ecs_entity_t id = ecs_new_component(world, #id, 0);\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, id);\
    (void)id;\
    (void)ecs_type(id);\

/** Wrapper around ecs_new_type.
 * This macro provides a convenient way to register a type with the world.
 * It can be used like this:
 *
 * ECS_TYPE(world, MyType, Position, Velocity);
 * ecs_entity_t e = ecs_new(world, MyType);
 *
 * Creating a type and using it with ecs_new/ecs_add is faster
 * than calling ecs_add multiple types. */
#define ECS_TYPE(world, id, ...) \
    ecs_entity_t id = ecs_new_type(world, #id, #__VA_ARGS__);\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, id);\
    (void)id;\
    (void)ecs_type(id);\

/** Wrapper around ecs_new_prefab.
 * This macro provides a convenient way to register a prefab with the world. It
 * can be used like this:
 *
 * ECS_PREFAB(world, MyPrefab, Position, Velocity);
 * ecs_entity_t e = ecs_new_instance(world, MyPrefab);
 *
 * For more specifics, see description of ecs_new_prefab. */
#define ECS_PREFAB(world, id, ...) \
    ecs_entity_t id = ecs_new_prefab(world, #id, #__VA_ARGS__);\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, id);\
    (void)id;\
    (void)ecs_type(id);\

/** Wrapper around ecs_new_system.
 * This macro provides a convenient way to register systems with a world. It can
 * be used like this:
 *
 * ECS_SYSTEM(world, Move, EcsOnUpdate, Position, Velocity);
 *
 * In this example, "Move" must be the identifier to a C function that matches
 * the signature of ecs_system_action_t. The signature of this component will be
 * "Location, Speed".
 *
 * After the macro, the application will have access to a Move entity variable 
 * which can be accessed through ecs_entity(Move). */
#define ECS_SYSTEM(world, id, kind, ...) \
    ecs_entity_t F##id = ecs_new_system(world, #id, kind, #__VA_ARGS__, id);\
    ecs_entity_t id = F##id;\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, id);\
    (void)id;\
    (void)ecs_type(id);

#endif

/** Define module
 */
#define ECS_MODULE(world, id)\
    ECS_COMPONENT(world, id);\
    ecs_set_singleton(world, id, {0});\
    id *handles = ecs_get_singleton_ptr(world, id);\

/** Wrapper around ecs_import.
 * This macro provides a convenient way to load a module with the world. It can
 * be used like this:
 *
 * ECS_IMPORT(world, FlecsSystemsPhysics, 0);
 * 
 * This macro will define entity and type handles for the component associated
 * with the module. An application can retrieve the module component like this:
 * 
 * FlecsSystemsPhysics m = ecs_get_singleton(world, FlecsSystemsPhysics);
 * 
 * The contents of a module component are module specific, although they
 * typically contain handles to the content of the module.
 */
#define ECS_IMPORT(world, id, flags) \
    id M##id;\
    ECS_ENTITY_VAR(id) = ecs_import(world, id, flags, &M##id);\
    ECS_TYPE_VAR(id) = ecs_type_from_entity(world, ecs_entity(id));\
    id##ImportHandles(M##id);\
    (void)ecs_entity(id);\
    (void)ecs_type(id);\

/* -- Utilities for importing handles from within systems -- */

#define ECS_COLUMN(rows, type, id, column)\
    type *id = ecs_column(rows, type, column)

#define ECS_COLUMN_COMPONENT(rows, id, column)\
    ECS_ENTITY_VAR(id) = ecs_column_entity(rows, column);\
    ECS_TYPE_VAR(id) = ecs_column_type(rows, column);\
    (void)ecs_entity(id);\
    (void)ecs_type(id)

#define ECS_COLUMN_ENTITY(rows, id, column)\
    ecs_entity_t id = ecs_column_entity(rows, column);\
    ECS_TYPE_VAR(id) = ecs_column_type(rows, column);\
    (void)id;\
    (void)ecs_type(id)


/* -- Module convenience macro's -- */

/** Utility macro for declaring a component inside a handles type */
#define ECS_DECLARE_COMPONENT(type)\
    ECS_ENTITY_VAR(type);\
    ECS_TYPE_VAR(type)

/** Utility macro for declaring a system inside a handles type */
#define ECS_DECLARE_ENTITY(entity)\
    ecs_entity_t entity;\
    ECS_TYPE_VAR(entity)

/** Utility macro for setting a component in a module function */
#define ECS_SET_COMPONENT(type)\
    if (handles) handles->ecs_entity(type) = ecs_entity(type);\
    if (handles) handles->ecs_type(type) = ecs_type(type)

#define ECS_EXPORT_COMPONENT(type)\
    ECS_SET_COMPONENT(type)

/** Utility macro for setting a system in a module function */
#define ECS_SET_ENTITY(entity)\
    if (handles) handles->entity = entity;\
    if (handles) handles->ecs_type(entity) = ecs_type(entity)

#define ECS_EXPORT_ENTITY(type)\
    ECS_SET_ENTITY(type)

/** Utility macro for declaring handles by modules */
#define ECS_IMPORT_COMPONENT(handles, type)\
    ECS_ENTITY_VAR(type) = (handles).ecs_entity(type); (void)ecs_entity(type);\
    ECS_TYPE_VAR(type) = (handles).ecs_type(type); (void)ecs_type(type);\
    (void)ecs_entity(type);\
    (void)ecs_type(type)

/** Utility macro for declaring handles by modules */
#define ECS_IMPORT_ENTITY(handles, entity)\
    ecs_entity_t entity = (handles).entity;\
    ECS_TYPE_VAR(entity) = (handles).ecs_type(entity); (void)ecs_type(entity);\
    (void)entity;\
    (void)ecs_type(entity)

/** Utility macro for importing all handles for a module from a system column */
#define ECS_IMPORT_COLUMN(rows, module, column) \
    module *M##module##_ptr = ecs_column(rows, module, column);\
    ecs_assert(M##module##_ptr != NULL, ECS_MODULE_UNDEFINED, #module);\
    ecs_assert(ecs_is_shared(rows, column), ECS_COLUMN_IS_NOT_SHARED, NULL);\
    module M##module = *M##module##_ptr;\
    module##ImportHandles(M##module)


/* -- Misc macro's -- */

/** Calculate offset from address */
#define ECS_OFFSET(o, offset) (void*)(((uintptr_t)(o)) + ((uintptr_t)(offset)))

/* Include stats at the end so it gets all the declarations */
#include <flecs/util/stats.h>

#ifdef __cplusplus
}
#endif

#endif
